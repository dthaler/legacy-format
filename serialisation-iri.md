---
title: "Extended Legacy Format (ELF)"
subtitle: Serialisation Format
date: 15 October 2017
numbersections: true
...
# ELF Serialisation Format

{.ednote ...} This is an **exploratory draft** of the serialisation
format for FHISO's proposed suite of Extended Legacy Format (ELF)
standards.  This document is not endorsed by the FHISO membership, and
may be updated, replaced or obsoleted by other documents at any time.

Comments on this draft should be directed to the
[tsc-public@fhiso.org](http://tech.fhiso.org/tsc-public) mailing list.
{/}

FHISO's **Extended Legacy Format** (or **ELF**) is a hierarchical
serialisation format and genealogical data model that is fully
compatible with GEDCOM, but with the addition of a structured
extensibility mechanism.  It also clarifies some ambiguities that were
present in GEDCOM and documents best current practice. 

The **GEDCOM** file format developed by The Church of Jesus Christ of
Latter-day Saints is the *de facto* standard for the exchange of
genealogical data between applications and data providers.  Its most
recent version is GEDCOM 5.5.1 which was produced in 1999, but despite
many technological advances since then, GEDCOM has remained unchanged.

{.note} Strictly, [GEDCOM 5.5] was the last version to be publicly
released back in 1995.  However a draft dated 2 October 1999 of a
proposed [GEDCOM 5.5.1] was made public; it is generally considered to
have the status of a standard and has been widely implemented as such.

FHISO are undertaking a program of work to produce a modernised yet
backward-compatible reformulation of GEDCOM under the name ELF, the new
name having been chosen to avoid confusion with any other updates or
extensions to GEDCOM, or any future use of the term by The Church of
Jesus Christ of Latter-day Saints.  This document is one of two that
form the initial suite of ELF standards:

* **ELF: Serialisation Format**.  This standard defines a
  general-purpose serialisation format based on the GEDCOM data format
  which encodes a *dataset* as a hierarchical series of *lines*, and
  provides low-level facilities such as escaping and extensibility
  mechanisms.

* **ELF: Data Model**.  This standard defines a data model based on the
  lineage-linked GEDCOM form, reformulated in terms of the
  serialisation model described in this document.  It is not a major
  update to the GEDCOM data model, but rather a basis for future
  extension.

## Conventions used

Where this standard gives a specific technical meaning to a word or
phrase, that word or phrase is formatted in bold text in its initial
definition, and in italics when used elsewhere.
The key words **must**, **must not**, **required**, **shall**, 
**shall not**, **should**, **should not**, **recommended**,
**not recommended**, **may** and **optional** in this standard are to be
interpreted as described in
&#x5B;[RFC 2119](https://tools.ietf.org/html/rfc2119)].

An application is **conformant** with this standard if and only if it
obeys all the requirements and prohibitions contained in this
document, as indicated by use of the words *must*, *must not*,
*required*, *shall* and *shall not*, and the relevant parts of its
normative references.  Standards referencing this standard *must not*
loosen any of the requirements and prohibitions made by this standard,
nor place additional requirements or prohibitions on the constructs
defined herein.  

{.note} Derived standards are not allowed to add or remove requirements
or prohibitions on the facilities defined herein so as to preserve
interoperability between applications.  Data generated by one
*conformant* application must always be acceptable to another
*conformant* application, regardless of what additional standards each
may conform to. 

If a *conformant* application encounters data that does not conform to
this standard, it *may* issue a warning or error message, and *may*
terminate processing of the document or data fragment.

This standard depends on FHISO's **Basic Concepts for Genealogical
Standards** standard.  To be *conformant* with this standard, an
application *must* also be *conformant* with [Basic Concepts].  Concepts
defined in that standard are used here without further definition.

{.note} In particular, precise meaning of *string*, *character*,
*whitespace* and *term* are given in [Basic Concepts].

Indented text in grey or coloured boxes does not form a normative part
of this standard, and is labelled as either an example or a note.  

{.ednote} Editorial notes, such as this, are used to record outstanding
issues, or points where there is not yet consensus; they will be
resolved and removed for the final standard.  Examples and notes will be
retained in the standard.

The grammar given here uses the form of EBNF notation defined in §6 of
&#x5B;[XML](https://www.w3.org/TR/xml11/)], except that no significance is
attached to the capitalisation of grammar symbols.  *Conforming*
applications *must not* generate data not conforming to the syntax given
here, but non-conforming syntax *may* be accepted and processed by a
*conforming* application in an implementation-defined manner.

## Overview of ELF

The ELF serialisation format is a structured, line-based text format for
encoding data in a form that is both machine-readable and
human-readable.  An ELF document consists of a sequence *structures*, 
which are recursive data structures that allow arbitrary information to
be represented in a hierarchical manner.  Each *structure* *may* have a
*payload*, which is either a *string* or a *pointer* to another
structure, and a list of child *structures* known as *substructures*.

{.note} The expressiveness of ELF is similar to that of XML.  ELF's
*structures* serve the same role as elements in XML, and nest similarly.

Each *structure* is encoded as sequence of *lines*.  The type of
*structure* is encoded on the first *line*, together with its
*payload*; *substructures* are encoded in order on subsequent
*lines*.  Each *line* is prefixed by a *level*, which is a number that
states how many levels of *substructures* deep the current *structure*
is.

{.example ...}
    0 HEAD
    1 GEDC
    2 VERS 5.5.1
    2 ELF 1.0.0
    2 FORM LINEAGE-LINKED
    1 CHAR UTF-8
    0 INDI
    1 NAME Charlemagne
    0 TRLR

The ELF document has three *lines* with *level* `0` which mark the start
of the three top-level *structures*.  These *structures* have,
respectively, two, one and zero *substructures*, which are denoted by
the *lines* with *level* `1`.   The *structure* represented by the
`CHAR` *line* is a *substructure* of the *structure* that begins on the
`HEAD` *line* because there is no intervening *line* with *level* one
less than `1` (i.e. `0`); the *structure* represented by the `NAME`
*line* is a *substructure* of the `INDI` *structure* as that is the
preceding *line* with a *level* `0`.
{/}

## Structures and pseudo-structures

A dataset consists of **structures**; as part of encoding as a *string*, these are augmented by a set of **pseudo-structures**, *structure*-like constructs that are not part of the data model.

### Structures   {#Structure}

**Structures**, as defined in [ELF-DataModel], each have

-   a *structure type*; each *structure type* has
    
    -   a unique *structure type identifier*, which is a *term name* and
    -   a (possibly empty) set of *supertypes*

-   a *superstructure* (which may be a *structure* or the dataset itself).
-   optionally, a *payload*, which may be either a *pointer* to a *record* or a *string*.
-   a (possibly empty) set of *substructures*; if multiple *substructures* have the same *structure type*,
    the order of those *substructures* is also preserved by the *structure*.

A *record* is a *structure* that has, as its *superstructure*, the dataset itself (which has the *structure type identifier* `elf:Document`).

Each *structure type* may have any number of *supertype*s, as defined by the data model.
A *structure type identifier* $X$ is an **eventual supertype** of a *structure* $Y$ if $X = Y$ or $X$ is an *eventual supertype* of a *supertype* of $Y$.

### Pseudo-structures

A **pseudo-structure** is a *structure*-like construct introduced to encode metadata associated with (de)serialisation.
*Pseudo-structures* are not part of the dataset, but are part of the serialised dataset.

All of the serialisation content in this document that refers to a *structure* also applies to a *pseudo-structure*.


## Tag Mapping Table {#tag-table}

The **tag mapping table**, used in both serialisation and deserialisation, is a set of **tag mappings**:
triples $(I, S, T)$ where $I$ and $S$ are *structure type identifier*s
and $T$ matches production Tag:

    Tag  ::= [0-9a-zA-Z_]+

Every entry in the *tag mapping table* *must* have $I$ be the *structure type identifier* of a *concrete type*.

If two entries in the *tag mapping table* have the same $T$, then

- they *must* have distinct $S$s, and
- their $S$s *must not* identify types where one is an *eventual supertype* of the other, and
- if both $S$ identify *abstract types* and have the same $I$, then both *must* have the same *T*.

{.ednote} The third constraint above is intended to prevent multiple inheritance from getting the same substructure with different tags from different supertypes. It assumes you cannot inherit from two concrete types. It also might not prove necessary; consider removing it.

It is *recommended* that all mappings with the same $I$ have the same $T$;
but distinct $T$s for the same $I$ *may* be used to aid in merging datasets using distinct tags for the same structure type.

No *tag mapping*'s $T$ value may be "`CONC`" or "`CONT`", as those are special values reserved for pseudo-structures that may appear almost anywhere.

All constraints on the *tag mapping table* must remain satisfied if all *tag mappings* in [Appendix A](#appendix-a) are added to the table.

### Tag to structure type {#from-tag}

Given a *structure* with *tag* $T$ in a superstructure with *structure type identifier* $S'$,
the *structure*'s *structure type identifier* is the $I$ of the *tag mapping* $(I, S, T)$ where either $S = S'$ or $S$ is an *eventual supertype* of $S'$.

If there is no such *tag mapping*, the *structure* is an **undocumented extension type** and *should* be treated like an *extension type* with which the implementation is unfamiliar.
The tag $T$ *should* be preserved and re-used on export of the data.

If there is more than one such *tag mapping* then the *tag mapping table* is *non-conformant* and the application may terminate or proceed in an implementation-defined manner.
Applications that proceed *should* alert the user that data loss may result due to non-conformant input.

## Structure type to tag {#to-tag}

Given a *structure* with *structure type identifier* $I$ in a superstructure with *structure type identifier* $S'$,
the *structure*'s *tag* is the $T$ of the a *tag mapping* $(I, S, T)$ where either $S = S'$ or $S$ is an *eventual supertype* of $S'$.

If there is no such *tag mapping*, a suitable *tag mapping* *must* be added to the *tag mapping table*, conforming to all limitations on the *tag mapping table*.
This new *tag* *should* begin with an underscore (U+005F, `_`) and be at least two characters long.
It is *recommended* that implementations consistently generate the same *tag* for a given *structure type* each time that *structure type* is serialised across all datasets.

If there are two or more such *tag mappings*, each implementation *must* consistently chose the same one each time.
This *should* be the "preferred" mapping as indicated by serialization order of the *tag mapping table*, but *may* be a different mapping provided that the same mapping is chosen throughout the serialisation process.


## Serialisation

To serialise a dataset,

1. Assign a tag for each structure to populate the *tag mapping table*.
2. Populate the `SCHMA` and `CHAR` *pseudo-structure*s of the `elfm:HEADER`.
3. Serialise the `elfm:HEADER`.
4. Assign identifiers to all *records*.
5. Serialise all *records* (in any order).
6. Serialise a `TRLR` *pseudo-structure*

Each of the serialization steps includes several substeps:

a. Convert each structure to an *extended line*.
b. Identify split points and add `CONT` and `CONC` *psuedo-structures* as needed.
c. Convert everything from characters to octets.
d. Order and serialize any *substructures*

### Assign tags

Assign each *structure* a **tag**, as defined in {§to-tag}.
As this may result in adding new *tag mappings* to the *tag mapping table*, it should be performed in full before serialising that table.

### Add header pseudo-structures

The first *pseudo-structure* in every ELF serialisation *must* be an `elfm:HEADER`.
Its *level* is 0, its *tag* is `HEAD`, and it has no *identifier* nor *payload string*.

Each `elfm:HEADER` has several data-model-level metadata *substructures*, as outlined in [ELF-DataModel].
In addition, it has several two serialisation-specific metadata *pseudo-substructure* which *shall* be added as part of serialisation:
exactly one `CHAR` and at most one `SCHMA`.

#### CHAR

The `CHAR` *pseudo-structure* has a payload taken from the following four options:

------    --------------------------------------------------------------------------
Encoding  Description
------    --------------------------------------------------------------------------
`ASCII`   The US version of ASCII defined in [ASCII].

`ANSEL`   The extended Latin character set for bibliographic use defined
          in [ANSEL].

`UNICODE` Either the UTF-16LE or the UTF-16BE encodings of Unicode
          defined in [ISO 10646].

`UTF-8`   The UTF-8 encodings of Unicode defined in [ISO 10646].
------    --------------------------------------------------------------------------

The character encoding selected
MUST be able to encode all code points in all payloads in every *structure* within the dataset.
It is RECOMMENDED that `UTF-8` be used for all datasets.

The payload of the `CHAR` *pseudo-structure* *must* correctly represent the character encoding used to convert the dataset into octets.

#### SCHMA

The`SCHMA` *pseudo-structure* has no payload and may contain any number of `PRFX` *pseudo-substructures* followed by any number of `IRI` *pseudo-substructures*.

##### Prefix abbreviation {#prefix}

A `PRFX` *pseudo-structure* has no substructures, and its payload matched production `Prefix`:

    Prefix ::= PfxName ' ' IRI
    PfxName ::= [A-Za-z_] ([A-Za-z0-9_#x2D#x2E])*

where `IRI` is the `IRI` production in §2.2 of
&#x5B;[RFC 3987](https://tools.ietf.org/html/rfc3987)]. 

{.note} `PfxName` is more restrictive than `NCName` in §3 of &#x5B;[Names]], being limited to 7-bit ASCII to reduce serialisation order dependency.

Each `PRFX` payload defines an IRI-shortening prefix.
If an IRI begins with an IRI in a `PRFX` payload,
that prefix may be replaced with that payload's PfxName and a colon.

{.example ...} Given a `PRFX`

    2 PRFX elf https://fhiso.org/elf/

the IRI `https://fhiso.org/elf/ADDRESS` may be abbreviated as `elf:ADDRESS`.
{/}


### Assign record identifiers

Assign each *record* an **identifier** matching production ID:

    ID  ::= [0-9A-Z_a-z] [#x20-#x3F#x41-#x7E]*

Within a given dataset, each *record*'s *identifier* *must* be unique.
    
{.note} The production `ID` is an alphanum followed by any number of non-control non-`@` 7-bit ASCII characters.  This is more limited than GEDCOM (which also allows the non-ASCII characters in ANSEL), but I am unaware of any GEDCOM implementation that uses those extra characters.

{.note ...} Some software have traditionally made additional assumptions of identifiers, such as
 
-   identifier strings are durable, expressing historical identity
-   having all `elf:NOTE_RECORD`'s identifiers match `N[1-9][0-9]*`
-   using a specific custom identifier for the `elf:INDIVIDUAL_RECORD` representing the user

... and so on.
While implementations are welcome to use such patterns themselves, they MUST NOT rely on them being true in imported data.
{/}




### Convert structures to extended lines

The **level** of a *structure* is 0 if the *structure* is a *record*; otherwise it is 1 more than the *level* of its *superstructure*.

The **payload string** of a *structure* is determined based on the kind of payload the *structure* contains:

| Payload | Payload String                                                     |
|:--------|:-------------------------------------------------------------------|
| None    | the empty string                                                   |
| *string*| the *payload* itself                                               |
|*pointer*| the *identifier* assigned to the pointed-to *structure*, surrounded by U+0040 (`@`) |

The **tag** of a *structure* is determined by its *type* and *superstructure* and the *tag mapping table*, as defined in {§to-tag}.

A *structure*'s **extended line** consists of its *level*, *identifier* if any, *tag*, and *payload string*.

### Order substructures

For each *structure*, create an ordered list of *substructures*.
The order of *substructures* with the same *structure type* are defined by the dataset;
the order of *substructures* with different *structure type*s may be selected arbitrarily.

{.note} Only the order of identical *structure type*s are constrained by the dataset itself; distinct subtypes of a common supertype may be ordered arbitrarily.

Each *substructure* of a *structure* is serialized immediately after the *extended line* of the *structure*.

### Split lines using CONT and CONC pseudo-structures

Identify a (possibly empty) set of split points in each *payload string*.
A split point *must* be placed at each *line break*,
*must not* be placed in the *payload string* created from a *pointer*-valued *payload*,
and *may* be added between any two non-*whitespace* characters
that are not part of a substring matching the `Escape` production.

    Escape  ::= "@#" [^#x40#xA#xD]* "@"

It is *recommended* that split points be identified at least once every 240 characters.

{.ednote} Jones asserts that leading white-space on a line is supported, even though GEDCOM suggests it is not. The above matches GEDCOM. We should probably investigate the prevalence of leading whitespace in practice before committing to this.

For each split point identified, add a *pseudo-substructure* to the *structure*,
with a *payload string* of the characters following that split point and preceding the next split point.
If the split point was placed at a *line break*, the *pseudo-structure*'s *tag* is `CONT`;
otherwise it is `CONC`.
The portion of the *payload string* preceding the first split point (or the entire string if there are no split points) is used as the new *payload string* of the *structure*.

{.example ...}
Suppose a structure's *extended line* was *level* = 2, *tag* = `NOTE`, and *payload string* "`This is a test\nwith one line break`".
This *payload string* requires at least one split point (because it contains one *line break*) and may contain more.
It could be serialised in many ways, such as

````gedcom
2 NOTE This is a test
3 CONT with one line break
````

or

````gedcom
2 NOTE This i
3 CONC s a test
3 CONT with on
3 CONC e line break
````
{/}


Any `CONT` and/or `CONC` *pseudo-substructures* of a *structure* *must* be serialized before any of the *structure*'s other *substructures*.

### Escape `@`

Replace any COMMERCIAL AT (U+0040, `@`) in a *payload string* that is not the initial or final character of a substring matching the `Escape` production with two adjacent COMMERCIAL ATs (i.e., "`@@`")

### Convert to a string

For each *extended line* (whether a *structure* or *pseudo-structure*, it's *line string* is

1. The *level* as a base-10 integer with no leading 0
2. If there is an *identifier*,
    1. A SPACE character U+0200
    2. A COMMERCIAL AT chracter U+040 `@`
    3. The characters of the *identifier*
    4. A COMMERCIAL AT chracter U+040 `@`
3. A SPACE character U+0200
4. The characters of the *tag*
5. If there is a *payload*,
    1. A SPACE character U+0200
    2. The characters of the *payload string*
6. A **line break**, being a *string* matching the production `LB`:

        LB  ::=  #xD #xA? | #xA
    
    The same *line break* *should* be used at the end of each *line string*.

### Convert to octets

Given a *string* and character encoding, the *string* is converted into a sequence of octets as specified by that encoding.
It is RECOMMENDED that the encoding used should be able to represent all code points within the *string*.
Any code points that cannot be directly represented as octets within the character encoding SHALL be encoded as follows:

1.  Replace the codepoint with the *string* made of
    1.  The three characters U+0040, U+0023, and U+0055 (i.e., "`@#U`")
    1.  A hexadecimal encoding of the code point
    1.  The two characters U+0040 and U+0020 (i.e., "`@ `")
1.  Encode the *string* with the character encoding

{.note} While GEDCOM has no provision for escaping unecodable code points, it does provide an "escape" construct `@#[^@]*@` which this addition uses.
GEDCOM also does not define what is done with unknown code points, so the above definition does not violate what GEDCOM requires.

{.ednote} Should we instead REQUIRE an encoding that accepts all code points in use?




## Deserialisation

To deserialise a dataset,

1. Detect the character encoding used.
2. Populate the *tag mapping table* from the `SCHMA` *pseudo-structure*s of the `elfm:HEADER`.
3. Deserialise the `elfm:HEADER`.
4. Deserialise each *record*.


Each of the serialization steps includes several substeps:

a. Covert octets to a string.
b. Convert each *line string* into an *extended line*.
d. Associate *substructures* with their *superstructures*.
c. Remove any `CONT` and `CONC` *psuedo-substructures*.

### Octets to string   {#octet2string}

In order to parse an ELF document, an application must determine how to
map the raw stream of octets read from the network or disk into
characters.  This is mapping is called the **character encoding** of
the document.  Determining it is a two-stage process, with the first
stage is to determine the **detected character encoding** of the
document per {§chardetect}.

{.note}  The *detected character encoding* might not be the actual
*character encoding* used in the document, but if the document is
*conformant*, it will be similar enough to allow a limited degree of
parsing as basic ASCII *character* will be correctly identified.


#### Detected character encoding                        {#chardetect}

If a character encoding is specified via any supported external means,
such as an HTTP `Content-Type` header, this *should* be the *detected
character encoding*.

{.example ...}  Suppose the ELF file was download using HTTP and the
response included this header:

    Content-Type: text/plain; charset=UTF-8

If an application supports taking the *detected character encoding* from
an HTTP `Content-Type` header, the *detected character encoding*
*should* be UTF-8.

Note that the use of the MIME type `text/plain` is *not recommended* for
ELF.  It is used here purely as an example. 
{/}

Otherwise, if the document begins with a byte-order mark (U+FEFF)
encoded in UTF-8, or UTF-16 of either endianness, this encoding *shall*
be the *detected character encoding*.  The byte-order mark is removed
from the data stream before further processing.

Otherwise, if the document begins with the digit `0` (U+0030) encoded in
UTF-16 of either endianness, this encoding *shall* be the *detected
character encoding*.

{.note}  The digit `0` is tested for because an ELF file *must* begin
with the *line* "`0 HEAD`".

Otherwise, applications *may* try to detect other character encodings by
examining the octet stream, but it is *not recommended* that they do so.

{.note}  One situation where it might be desirable to try to detect
another encoding is if the application needs to support (as an
extension) a character encoding like EBCDIC which is not compatible with
ASCII.

Otherwise, there is no *detected character encoding*.

{.note ...} These cases can be summarised as follows:

----------------  -------------------------------------------------
Initial octets    Detected character encoding
----------------  -------------------------------------------------
EF BB BF          UTF-8 (with byte-order mark)

FF FE             UTF-16, little endian (with byte-order mark) 

FE FF             UTF-16, big endian (with byte-order mark)

30 00             UTF-16, little endian (without byte-order mark)

00 30             UTF-16, big endian (without byte-order mark)

Otherwise         None
----------------  -------------------------------------------------
{/}

#### Character encoding

A prefix of octet stream shall be decoded using the *detected character encoding*,
or an unspecified ASCII-compatible encoding if there is no *detected character encoding*.
This prefix is parsed into *lines*, stopping at the second instance of a *line* with *level* 0.   If a *line* with *level* 1 and *tag* `CHAR` was found, its *payload* is the **specified character encoding** of the document.

If there is a *specified character encoding*, it SHALL be used as the *character encoding* of the octet stream.
Otherwise, if there is a *detected character encoding*, it SHALL be used as the *character encoding* of the octet stream.
Otherwise, the *character encoding* SHALL be determined to be ANSEL.

#### Decoding

Given an octet stream and a character encoding,
the octet stream is converted into a sequence of characters as specified by that encoding.

If any subsequence of the decoded *string* matches the production `UEsc`:

    hex  ::= [0-9A-Fa-f]+
    UEsc ::= "@#U" hex "@" #x20?

that substring SHALL be replaced by the code point represented by the hexadecimal number included within the escape sequence.

{.note} While GEDCOM does not have the UEsc provision, this provision will not cause an ELF decoder to misinterpret the output of any known GEDCOM exporter.

{.ednote}  This is specified at the wrong time in the decoding process.
Escape decoding must be done after *lines* have been parsed, otherwise
it is not possible to use "`1 NOTE @#U20@`" to encode a *string*
consisting of just a single space *character*.



### Extended line parsing

The *string* resulting from character decoding *shall* be split on every LINE FEED U+000A and CARRIAGE RETURN U+000D, creating a list of **line**s.
Any *line* containing only characters matching production `S` from &#x5B;[XML](https://www.w3.org/TR/xml11/)] *shall* be discarded.

    S  ::=  (#x20 | #x9 | #xD | #xA)+

Each *line* shall be converted to an *extended line* as follows:

1. Strip off the leading decimal integer and its following SPACE U+0020.
    This integer is the *level* of the *extended line*.

2. If the next character is U+0040 (`@` COMMERCIAL AT) then the *extended line*'s *identifier* is the substring of the *line* between that U+0040 and the following U+0040.
    Strip off this identifier, its surrounding `@`, and the U+0020 following it.
    
    Otherwise, the *line* has no *identifier*.

3. The next part of the *line* matches the production `Tag` and is the *tag* of the *extended line*.

    Strip off this *tag* and its following U+0020.

4. The remainder of the *line* is the *extended line*'s *payload string*.
    
If any *line* cannot be processed as listed above (e.g., it does not begin with an integer and a space, it does not have a tag, it has a malformed identifier, etc.) then the dataset is not valid ELF and *should* be rejected.

If the first *extended line*'s *level* is not 0
or any *extended line*'s level is more than 1 larger than the *level* of the preceding *extended line*
then the dataset is not valid ELF and *should* be rejected.

{.ednote} It is not clear if we should add a "strip leading and trailing whitespace" here or not. GEDCOM suggests implementations should assume whitespace could have been stripped, but also does not suggest that white space should be stripped.

### Extending lines

If an *extended line* with level $n$ has as its *tag* `CONT` or `CONC`, and the line before is neither a `CONT`- or `CONC`-tagged line with *level* $n$ nor a line with a different *tag* with *level* $n-1$
then the dataset is not valid ELF and *should* be rejected.

{.ednote} It is also an error to have a pointer-valued payload followed by a `CONT` or `CONC`. Is this worth trying to add to this specification?


The following two operations *shall* be repeated until no *extended line*s with *tags* `CONT` and `CONC` remain:

- If an *extended line* with level $n$ is followed by an *extended line* with level $n+1$ and *tag* `CONC`, the *payload string* of the `CONC` line *shall* be appended to the *payload string* of the preceding line and the `CONC` line removed.

- If an *extended line* with level $n$ is followed by an *extended line* with level $n+1$ and *tag* `CONT`, a *line break* followed by the *payload string* of the `CONT` line *shall* be appended to the *payload string* of the preceding line and the `CONT` line removed.


{.ednote} Insert missing steps here


## Appendix A: Known Tags                                       {#appendix-a}

The following lists *tag mappings* for all concrete types listed in [Elf-DataModel].

| $I$                            | $S$                            | $T$   |
|:-------------------------------|:-------------------------------|:------|
| elf:ADDRESS                    | elf:Agent                      | ADDR  |
| elf:ADDRESS                    | elf:Event                      | ADDR  |
| elf:ADDRESS_CITY               | elf:ADDRESS                    | CITY  |
| elf:ADDRESS_COUNTRY            | elf:ADDRESS                    | CTRY  |
| elf:ADDRESS_EMAIL              | elf:Agent                      | EMAIL |
| elf:ADDRESS_FAX                | elf:Agent                      | FAX   |
| elf:ADDRESS_LINE1              | elf:ADDRESS                    | ADR1  |
| elf:ADDRESS_LINE2              | elf:ADDRESS                    | ADR2  |
| elf:ADDRESS_LINE3              | elf:ADDRESS                    | ADR3  |
| elf:ADDRESS_POSTAL_CODE        | elf:ADDRESS                    | POST  |
| elf:ADDRESS_STATE              | elf:ADDRESS                    | STAE  |
| elf:ADDRESS_WEB_PAGE           | elf:Agent                      | WWW   |
| elf:ADOPTED_BY_WHICH_PARENT    | elf:ADOPTIVE_FAMILY            | ADOP  |
| elf:ADOPTION                   | elf:INDIVIDUAL_RECORD          | ADOP  |
| elf:ADOPTIVE_FAMILY            | elf:ADOPTION                   | FAMC  |
| elf:ADULT_CHRISTENING          | elf:INDIVIDUAL_RECORD          | CHRA  |
| elf:AGE_AT_EVENT               | elf:IndividualEvent            | AGE   |
| elf:AGE_AT_EVENT               | elf:Parent1Age                 | AGE   |
| elf:AGE_AT_EVENT               | elf:Parent2Age                 | AGE   |
| elf:ALIAS_POINTER              | elf:INDIVIDUAL_RECORD          | ALIA  |
| elf:ANCESTOR_INTEREST_POINTER  | elf:INDIVIDUAL_RECORD          | ANCI  |
| elf:ANNULMENT                  | elf:FAM_RECORD                 | ANUL  |
| elf:ASSOCIATION_STRUCTURE      | elf:INDIVIDUAL_RECORD          | ASSO  |
| elf:ATTRIBUTE_DESCRIPTOR       | elf:INDIVIDUAL_RECORD          | FACT  |
| elf:AUTOMATED_RECORD_ID        | elf:Record                     | RIN   |
| elf:BAPTISM                    | elf:INDIVIDUAL_RECORD          | BAPM  |
| elf:BAR_MITZVAH                | elf:INDIVIDUAL_RECORD          | BARM  |
| elf:BAS_MITZVAH                | elf:INDIVIDUAL_RECORD          | BASM  |
| elf:BINARY_OBJECT              | elf:MULTIMEDIA_RECORD          | BLOB  |
| elf:BIRTH                      | elf:INDIVIDUAL_RECORD          | BIRT  |
| elf:BLESSING                   | elf:INDIVIDUAL_RECORD          | BLES  |
| elf:BURIAL                     | elf:INDIVIDUAL_RECORD          | BRI   |
| elf:CASTE_NAME                 | elf:INDIVIDUAL_RECORD          | CAST  |
| elf:CAUSE_OF_EVENT             | elf:Event                      | CAUS  |
| elf:CENSUS#Family              | elf:FAM_RECORD                 | CENS  |
| elf:CENSUS#Individual          | elf:INDIVIDUAL_RECORD          | CENS  |
| elf:CERTAINTY_ASSESSMENT       | elf:SOURCE_CITATION            | QUAY  |
| elf:CHANGE_DATE                | elf:Record                     | CHAN  |
| elf:CHANGE_DATE_DATE           | elf:CHANGE_DATE                | DATE  |
| elf:CHILD_LINKAGE_STATUS       | elf:CHILD_TO_FAMILY_LINK       | STAT  |
| elf:CHILD_POINTER              | elf:FAM_RECORD                 | CHIL  |
| elf:CHILD_TO_FAMILY_LINK       | elf:INDIVIDUAL_RECORD          | FAMC  |
| elf:CHRISTENING                | elf:INDIVIDUAL_RECORD          | CHR   |
| elf:CONFIRMATION               | elf:INDIVIDUAL_RECORD          | CONF  |
| elf:CONTINUED_BINARY_OBJECT    | elf:MULTIMEDIA_RECORD          | OBJE  |
| elf:COPYRIGHT_GEDCOM_FILE      | elfm:HEADER                    | COPR  |
| elf:COPYRIGHT_SOURCE_DATA      | elf:NAME_OF_SOURCE_DATA        | COPR  |
| elf:COUNT_OF_CHILDREN#Family   | elf:FAM_RECORD                 | NCHI  |
| elf:COUNT_OF_CHILDREN#Individual | elf:INDIVIDUAL_RECORD          | NCHI  |
| elf:COUNT_OF_MARRIAGES         | elf:INDIVIDUAL_RECORD          | NMR   |
| elf:CREMATION                  | elf:INDIVIDUAL_RECORD          | CREM  |
| elf:DATE_PERIOD                | elf:EVENTS_RECORDED            | DATE  |
| elf:DATE_VALUE                 | elf:Event                      | DATE  |
| elf:DEATH                      | elf:INDIVIDUAL_RECORD          | DEAT  |
| elf:DEFAULT_PLACE_FORMAT       | elfm:HEADER                    | PLAC  |
| elf:DESCENDANT_INTEREST_POINTER | elf:INDIVIDUAL_RECORD          | DESI  |
| elf:DESCRIPTIVE_TITLE          | elf:MULTIMEDIA_FILE_REFERENCE  | TITL  |
| elf:DESCRIPTIVE_TITLE          | elf:MULTIMEDIA_LINK            | TITL  |
| elf:DESCRIPTIVE_TITLE          | elf:MULTIMEDIA_RECORD          | TITL  |
| elf:DIVORCE                    | elf:FAM_RECORD                 | DIV   |
| elf:DIVORCE_FILED              | elf:FAM_RECORD                 | DIVF  |
| elf:DOCUMENT_SOURCE            | elfm:HEADER                    | SOUR  |
| elf:EMIGRATION                 | elf:INDIVIDUAL_RECORD          | EMIG  |
| elf:ENGAGEMENT                 | elf:FAM_RECORD                 | ENGA  |
| elf:ENTRY_RECORDING_DATE       | elf:SOURCE_CITATION_DATA       | DATE  |
| elf:EVENT#Family               | elf:FAM_RECORD                 | EVEN  |
| elf:EVENT#Individual           | elf:INDIVIDUAL_RECORD          | EVEN  |
| elf:EVENTS_RECORDED            | elf:SOURCE_RECORD_DATA         | EVEN  |
| elf:EVENT_OR_FACT_CLASSIFICATION | elf:Event                      | TYPE  |
| elf:EVENT_TYPE_CITED_FROM      | elf:SOURCE_CITATION            | EVEN  |
| elf:FAM_RECORD                 | elfm:Document                  | FAM   |
| elf:FILE_NAME                  | elfm:HEADER                    | FILE  |
| elf:FIRST_COMMUNION            | elf:INDIVIDUAL_RECORD          | FCOM  |
| elf:GEDCOM_CONTENT_DESCRIPTION | elfm:HEADER                    | NOTE  |
| elf:GEDCOM_FORM                | elf:GEDCOM_FORMAT              | FORM  |
| elf:GEDCOM_FORMAT              | elfm:HEADER                    | GEDC  |
| elf:GRADUATION                 | elf:INDIVIDUAL_RECORD          | GRAD  |
| elf:IMMIGRATION                | elf:INDIVIDUAL_RECORD          | IMMI  |
| elf:INDIVIDUAL_RECORD          | elfm:Document                  | INDI  |
| elf:LANGUAGE_OF_TEXT           | elfm:HEADER                    | LANG  |
| elf:LANGUAGE_PREFERENCE        | elf:SUBMITTER_RECORD           | LANG  |
| elf:MAP_COORDINATES            | elf:PLACE_STRUCTURE            | MAP   |
| elf:MARRIAGE                   | elf:FAM_RECORD                 | MARR  |
| elf:MARRIAGE_BANN              | elf:FAM_RECORD                 | MARB  |
| elf:MARRIAGE_CONTRACT          | elf:FAM_RECORD                 | MARC  |
| elf:MARRIAGE_LICENSE           | elf:FAM_RECORD                 | MARL  |
| elf:MARRIAGE_SETTLEMENT        | elf:FAM_RECORD                 | MARS  |
| elf:MULTIMEDIA_FILE_REFERENCE  | elf:MULTIMEDIA_LINK            | FILE  |
| elf:MULTIMEDIA_FILE_REFERENCE  | elf:MULTIMEDIA_RECORD          | FILE  |
| elf:MULTIMEDIA_FORMAT          | elf:MULTIMEDIA_FILE_REFERENCE  | FORM  |
| elf:MULTIMEDIA_FORMAT          | elf:MULTIMEDIA_LINK            | FORM  |
| elf:MULTIMEDIA_FORMAT          | elf:MULTIMEDIA_RECORD          | FORM  |
| elf:MULTIMEDIA_LINK            | elf:Event                      | OBJE  |
| elf:MULTIMEDIA_LINK            | elf:FAM_RECORD                 | OBJE  |
| elf:MULTIMEDIA_LINK            | elf:INDIVIDUAL_RECORD          | OBJE  |
| elf:MULTIMEDIA_LINK            | elf:SOURCE_CITATION            | OBJE  |
| elf:MULTIMEDIA_LINK            | elf:SOURCE_RECORD              | OBJE  |
| elf:MULTIMEDIA_LINK            | elf:SUBMITTER_RECORD           | OBJE  |
| elf:MULTIMEDIA_RECORD          | elfm:Document                  | OBJE  |
| elf:NAME_OF_BUSINESS           | elf:DOCUMENT_SOURCE            | CORP  |
| elf:NAME_OF_PRODUCT            | elf:DOCUMENT_SOURCE            | NAME  |
| elf:NAME_OF_REPOSITORY         | elf:REPOSITORY_RECORD          | NAME  |
| elf:NAME_OF_SOURCE_DATA        | elf:DOCUMENT_SOURCE            | DATA  |
| elf:NAME_PHONETIC_VARIATION    | elf:PERSONAL_NAME_STRUCTURE    | FONE  |
| elf:NAME_PIECE_GIVEN           | elf:PersonalName               | GIVN  |
| elf:NAME_PIECE_NICKNAME        | elf:PersonalName               | NICK  |
| elf:NAME_PIECE_PREFIX          | elf:PersonalName               | NPFX  |
| elf:NAME_PIECE_SUFFIX          | elf:PersonalName               | NSFX  |
| elf:NAME_PIECE_SURNAME         | elf:PersonalName               | SURN  |
| elf:NAME_PIECE_SURNAME_PREFIX  | elf:PersonalName               | SPFX  |
| elf:NAME_ROMANIZED_VARIATION   | elf:PERSONAL_NAME_STRUCTURE    | ROMN  |
| elf:NAME_TYPE                  | elf:PERSONAL_NAME_STRUCTURE    | TYPE  |
| elf:NATIONAL_ID_NUMBER         | elf:INDIVIDUAL_RECORD          | IDNO  |
| elf:NATIONAL_OR_TRIBAL_ORIGIN  | elf:INDIVIDUAL_RECORD          | NATI  |
| elf:NATURALIZATION             | elf:INDIVIDUAL_RECORD          | NATU  |
| elf:NOBILITY_TYPE_TITLE        | elf:INDIVIDUAL_RECORD          | TITL  |
| elf:NOTE_RECORD                | elfm:Document                  | NOTE  |
| elf:NOTE_STRUCTURE             | elf:ASSOCIATION_STRUCTURE      | NOTE  |
| elf:NOTE_STRUCTURE             | elf:CHANGE_DATE                | NOTE  |
| elf:NOTE_STRUCTURE             | elf:CHILD_TO_FAMILY_LINK       | NOTE  |
| elf:NOTE_STRUCTURE             | elf:Event                      | NOTE  |
| elf:NOTE_STRUCTURE             | elf:PLACE_STRUCTURE            | NOTE  |
| elf:NOTE_STRUCTURE             | elf:PersonalName               | NOTE  |
| elf:NOTE_STRUCTURE             | elf:Record                     | NOTE  |
| elf:NOTE_STRUCTURE             | elf:SOURCE_CITATION            | NOTE  |
| elf:NOTE_STRUCTURE             | elf:SOURCE_RECORD_DATA         | NOTE  |
| elf:NOTE_STRUCTURE             | elf:SOURCE_REPOSITORY_CITATION | NOTE  |
| elf:NOTE_STRUCTURE             | elf:SPOUSE_TO_FAMILY_LINK      | NOTE  |
| elf:OCCUPATION                 | elf:INDIVIDUAL_RECORD          | OCCU  |
| elf:ORDINATION                 | elf:INDIVIDUAL_RECORD          | ORDN  |
| elf:PARENT1_POINTER            | elf:FAM_RECORD                 | HUSB  |
| elf:PARENT2_POINTER            | elf:FAM_RECORD                 | WIFE  |
| elf:PEDIGREE_LINKAGE_TYPE      | elf:CHILD_TO_FAMILY_LINK       | PEDI  |
| elf:PERSONAL_NAME_STRUCTURE    | elf:INDIVIDUAL_RECORD          | NAME  |
| elf:PHONETIC_TYPE              | elf:NAME_PHONETIC_VARIATION    | TYPE  |
| elf:PHONETIC_TYPE              | elf:PLACE_PHONETIC_VARIATION   | TYPE  |
| elf:PHONE_NUMBER               | elf:Agent                      | PHON  |
| elf:PHYSICAL_DESCRIPTION       | elf:INDIVIDUAL_RECORD          | DSCR  |
| elf:PLACE_HIERARCHY            | elf:DEFAULT_PLACE_FORMAT       | FORM  |
| elf:PLACE_HIERARCHY            | elf:PLACE_STRUCTURE            | FORM  |
| elf:PLACE_LATITUDE             | elf:MAP_COORDINATES            | LATI  |
| elf:PLACE_LONGITUDE            | elf:MAP_COORDINATES            | LONG  |
| elf:PLACE_PHONETIC_VARIATION   | elf:PLACE_STRUCTURE            | FONE  |
| elf:PLACE_ROMANIZED_VARIATION  | elf:PLACE_STRUCTURE            | ROMN  |
| elf:PLACE_STRUCTURE            | elf:Event                      | PLAC  |
| elf:POSSESSIONS                | elf:INDIVIDUAL_RECORD          | PROP  |
| elf:PROBATE                    | elf:INDIVIDUAL_RECORD          | PROB  |
| elf:PUBLICATION_DATE           | elf:NAME_OF_SOURCE_DATA        | DATE  |
| elf:Parent1Age                 | elf:FamilyEvent                | HUSB  |
| elf:Parent2Age                 | elf:FamilyEvent                | WIFE  |
| elf:RECEIVING_SYSTEM_NAME      | elfm:HEADER                    | DEST  |
| elf:RELATION_IS_DESCRIPTOR     | elf:ASSOCIATION_STRUCTURE      | RELA  |
| elf:RELIGIOUS_AFFILIATION      | elf:Event                      | RELI  |
| elf:RELIGIOUS_AFFILIATION#Individual | elf:INDIVIDUAL_RECORD          | RELI  |
| elf:REPOSITORY_RECORD          | elfm:Document                  | REPO  |
| elf:RESIDENCE                  | elf:FAM_RECORD                 | RESI  |
| elf:RESIDES_AT                 | elf:INDIVIDUAL_RECORD          | RESI  |
| elf:RESPONSIBLE_AGENCY         | elf:Event                      | AGNC  |
| elf:RESPONSIBLE_AGENCY         | elf:SOURCE_RECORD_DATA         | AGNC  |
| elf:RESTRICTION_NOTICE         | elf:Event                      | RESN  |
| elf:RESTRICTION_NOTICE         | elf:FAM_RECORD                 | RESN  |
| elf:RESTRICTION_NOTICE         | elf:INDIVIDUAL_RECORD          | RESN  |
| elf:RETIREMENT                 | elf:INDIVIDUAL_RECORD          | RETI  |
| elf:ROLE_IN_EVENT              | elf:EVENT_TYPE_CITED_FROM      | ROLE  |
| elf:ROMANIZED_TYPE             | elf:NAME_ROMANIZED_VARIATION   | TYPE  |
| elf:ROMANIZED_TYPE             | elf:PLACE_ROMANIZED_VARIATION  | TYPE  |
| elf:SCHOLASTIC_ACHIEVEMENT     | elf:INDIVIDUAL_RECORD          | EDUC  |
| elf:SEX_VALUE                  | elf:INDIVIDUAL_RECORD          | SEX   |
| elf:SOCIAL_SECURITY_NUMBER     | elf:INDIVIDUAL_RECORD          | SSN   |
| elf:SOURCE_CALL_NUMBER         | elf:SOURCE_REPOSITORY_CITATION | CALN  |
| elf:SOURCE_CITATION            | elf:ASSOCIATION_STRUCTURE      | SOUR  |
| elf:SOURCE_CITATION            | elf:Event                      | SOUR  |
| elf:SOURCE_CITATION            | elf:FAM_RECORD                 | SOUR  |
| elf:SOURCE_CITATION            | elf:INDIVIDUAL_RECORD          | SOUR  |
| elf:SOURCE_CITATION            | elf:PersonalName               | SOUR  |
| elf:SOURCE_CITATION_DATA       | elf:SOURCE_CITATION            | DATA  |
| elf:SOURCE_DESCRIPTIVE_TITLE   | elf:SOURCE_RECORD              | TITL  |
| elf:SOURCE_FILED_BY_ENTRY      | elf:SOURCE_RECORD              | ABBR  |
| elf:SOURCE_JURISDICTION_PLACE  | elf:EVENTS_RECORDED            | PLAC  |
| elf:SOURCE_MEDIA_TYPE          | elf:MULTIMEDIA_FORMAT          | MEDI  |
| elf:SOURCE_MEDIA_TYPE          | elf:SOURCE_CALL_NUMBER         | MEDI  |
| elf:SOURCE_ORIGINATOR          | elf:SOURCE_RECORD              | AUTH  |
| elf:SOURCE_PUBLICATION_FACTS   | elf:SOURCE_RECORD              | PUBL  |
| elf:SOURCE_RECORD              | elfm:Document                  | SOUR  |
| elf:SOURCE_RECORD_DATA         | elf:SOURCE_RECORD              | DATA  |
| elf:SOURCE_REPOSITORY_CITATION | elf:SOURCE_RECORD              | REPO  |
| elf:SPOUSE_TO_FAMILY_LINK      | elf:INDIVIDUAL_RECORD          | FAMS  |
| elf:SUBMITTER_NAME             | elf:SUBMITTER_RECORD           | NAME  |
| elf:SUBMITTER_POINTER          | elf:FAM_RECORD                 | SUBM  |
| elf:SUBMITTER_POINTER          | elf:INDIVIDUAL_RECORD          | SUBM  |
| elf:SUBMITTER_POINTER          | elfm:HEADER                    | SUBM  |
| elf:SUBMITTER_RECORD           | elfm:Document                  | SUBM  |
| elf:TEXT_FROM_SOURCE           | elf:SOURCE_CITATION            | TEXT  |
| elf:TEXT_FROM_SOURCE           | elf:SOURCE_CITATION_DATA       | TEXT  |
| elf:TEXT_FROM_SOURCE           | elf:SOURCE_RECORD              | TEXT  |
| elf:TIME_VALUE                 | elf:CHANGE_DATE_DATE           | TIME  |
| elf:TIME_VALUE                 | elf:TRANSMISSION_DATE          | TIME  |
| elf:TRANSMISSION_DATE          | elfm:HEADER                    | DATE  |
| elf:USER_REFERENCE_NUMBER      | elf:Record                     | REFN  |
| elf:USER_REFERENCE_TYPE        | elf:USER_REFERENCE_NUMBER      | TYPE  |
| elf:VERSION_NUMBER             | elf:DOCUMENT_SOURCE            | VERS  |
| elf:VERSION_NUMBER             | elf:GEDCOM_FORMAT              | VERS  |
| elf:VERSION_NUMBER             | elfm:CHARACTER_SET             | VERS  |
| elf:WHERE_WITHIN_SOURCE        | elf:SOURCE_CITATION            | PAGE  |
| elf:WILL                       | elf:INDIVIDUAL_RECORD          | WILL  |
| elf:WITHIN_FAMILY              | elf:BIRTH                      | FAMC  |
| elf:WITHIN_FAMILY              | elf:CHRISTENING                | FAMC  |
| elfm:CHARACTER_SET             | elfm:HEADER                    | CHAR  |
| elfm:ELF_SCHEMA                | elfm:HEADER                    | SCHMA |
| elfm:EXTENDS                   | elfm:STRUCTURE_TYPE            | ISA   |
| elfm:HEADER                    | elfm:Document                  | HEAD  |
| elfm:IRI_PREFIX                | elfm:ELF_SCHEMA                | PRFX  |
| elfm:STRUCTURE_TYPE            | elfm:ELF_SCHEMA                | IRI   |
| elfm:TAG                       | elfm:STRUCTURE_TYPE            | TAG   |
| elfm:Trailer                   | elfm:Document                  | TRLR  |




## References


### Normative references

[ANSEL]
:   NISO (National Information Standards Organization).
    *ANSI/NISO Z39.47-1993.
    Extended Latin Alphabet Coded Character Set for Bibliographic Use*.
    1993.  (See 
    <http://www.niso.org/apps/group_public/project/details.php?project_id=10>.)
    Standard withdrawn, 2013.

[Basic Concepts]
:   FHISO (Family History Information Standards Organisation).
    *Basic Concepts for Genealogical Standards*.  Public draft.
    (See <https://fhiso.org/TR/basic-concepts>.)

[ELF-DataModel]
:   FHISO (Family History Information Standards Organisation).
    *Extended Legacy Format (ELF): Data Model*.  First public draft.
    (See <https://fhiso.org/TR/elf-data-model>.)

[ASCII]
:   ANSI (American National Standards Institute).
    *ANSI X3.4-1986.
    Coded Character Sets -- 7-Bit American National Standard Code for Information Interchange (7-Bit ASCII)*.
    1986.

[ISO 10646]
:   ISO (International Organization for Standardization).
    *ISO/IEC 10646:2014.
    Information technology &mdash; Universal Coded Character Set (UCS).*
    2014.

[RFC 2119]
:   IETF (Internet Engineering Task Force).
    *RFC 2119:
    Key words for use in RFCs to Indicate Requirement Levels.*
    Scott Bradner, 1997.
    (See <http://tools.ietf.org/html/rfc2119>.)

[Vocabularies]
:   FHISO (Family History Information Standards Organisation)
    *Preferred nature of vocabularies.*
    See <http://tech.fhiso.org/policies/vocabularies>.

[XML]
:   W3C (World Wide Web Consortium).
    *Extensible Markup Language (XML) 1.1*, 2nd edition.
    Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, and John Cowan eds., 2006.
    W3C Recommendation.
    (See <https://www.w3.org/TR/xml11/>.)

### Other references

[GEDCOM 5.5.1]
:   The Church of Jesus Christ of Latter-day Saints.
    *The GEDCOM Standard*, draft release 5.5.1.  2 Oct 1999.

[GEDCOM 5.5]
:   The Church of Jesus Christ of Latter-day Saints.
    *The GEDCOM Standard*, release 5.5.  1996.

[XML Names]
:   W3 (World Wide Web Consortium).
    *Namespaces in XML 1.1*, 2nd edition.
    Tim Bray, Dave Hollander, Andrew Layman and Richard Tobin, eds., 2006.
    W3C Recommendation.
    See <https://www.w3.org/TR/xml-names11/>.

[ELF-DM]
:   FHISO (Family History Information Standards Organisation)
    *Extended Legacy Format (ELF): Data Model.*
