---
title: "Extended Legacy Format (ELF)"
subtitle: Serialisation Format
date: 25 January 2019
numbersections: true
...

# ELF Serialisation Format

{.ednote ...} This is an **exploratory draft** of the serialisation
format for FHISO's proposed suite of Extended Legacy Format (ELF)
standards.  This document is not endorsed by the FHISO membership, and
may be updated, replaced or obsoleted by other documents at any time.

Comments on this draft should be directed to the
[tsc-public@fhiso.org](http://tech.fhiso.org/tsc-public) mailing list.
{/}

FHISO's **Extended Legacy Format** (or **ELF**) is a hierarchical
serialisation format and genealogical data model that is fully
compatible with GEDCOM, but with the addition of a structured
extensibility mechanism.  It also clarifies some ambiguities that were
present in GEDCOM and documents best current practice. 

The **GEDCOM** file format developed by The Church of Jesus Christ of
Latter-day Saints is the *de facto* standard for the exchange of
genealogical data between applications and data providers.  Its most
recent version is GEDCOM 5.5.1 which was produced in 1999, but despite
many technological advances since then, GEDCOM has remained unchanged.

{.note} Strictly, [GEDCOM 5.5] was the last version to be publicly
released back in 1995.  However a draft dated 2 October 1999 of a
proposed [GEDCOM 5.5.1] was made public; it is generally considered to
have the status of a standard and has been widely implemented as such.

FHISO are undertaking a program of work to produce a modernised yet
backward-compatible reformulation of GEDCOM under the name ELF, the new
name having been chosen to avoid confusion with any other updates or
extensions to GEDCOM, or any future use of the name by The Church of
Jesus Christ of Latter-day Saints.  This document is one of three that
form the initial suite of ELF standards, known collectively as ELF 1.0.0:

* **ELF: Serialisation Format**.  This standard defines a
  general-purpose serialisation format based on the GEDCOM data format
  which encodes a *dataset* as a hierarchical series of *lines*, and
  provides low-level facilities such as escaping and extensibility
  mechanisms.

* **ELF: Date, Age and Time Microformats**.  This standard defines
  microformats for representing dates, ages and times in arbitrary calendars,
  together with how they are applied to the Gregorian, Julian, French
  Republican and Hebrew calendars.  

* **ELF: Data Model**.  This standard defines a data model based on the
  lineage-linked GEDCOM form, reformulated in terms of the
  serialisation model described in this document.  It is not a major
  update to the GEDCOM data model, but rather a basis for future
  extension.

## Conventions used

Where this standard gives a specific technical meaning to a word or
phrase, that word or phrase is formatted in bold text in its initial
definition, and in italics when used elsewhere.
The key words **must**, **must not**, **required**, **shall**, 
**shall not**, **should**, **should not**, **recommended**,
**not recommended**, **may** and **optional** in this standard are to be
interpreted as described in
&#x5B;[RFC 2119](https://tools.ietf.org/html/rfc2119)].

An application is **conformant** with this standard if and only if it
obeys all the requirements and prohibitions contained in this
document, as indicated by use of the words *must*, *must not*,
*required*, *shall* and *shall not*, and the relevant parts of its
normative references.  Standards referencing this standard *must not*
loosen any of the requirements and prohibitions made by this standard,
nor place additional requirements or prohibitions on the constructs
defined herein.  

{.note} Derived standards are not allowed to add or remove requirements
or prohibitions on the facilities defined herein so as to preserve
interoperability between applications.  Data generated by one
*conformant* application must always be acceptable to another
*conformant* application, regardless of what additional standards each
may conform to. 

If a *conformant* application encounters data that does not conform to
this standard, it *must* present a warning or error message to the user,
and *should* terminate processing of the document or data fragment.  If
it continues processing, it does so in an implementation-defined manner.

This standard depends on FHISO's **Basic Concepts for Genealogical
Standards** standard.  To be *conformant* with this standard, an
application *must* also be *conformant* with the referenced parts of
[Basic Concepts].  Concepts defined in that standard are used here
without further definition.

{.note} In particular, precise meaning of *string*, *character*,
*whitespace*, *whitespace normalisation* and *term* are given in [Basic
Concepts].

Certain facilities in this standard are described as **deprecated**,
which is a warning that they are likely to be removed from a future
version of this standard.  This has no bearing on whether a *conformant*
application must implement the facility: they may be *required*,
*recommended* or *optional* as described in this standard.  

Indented text in grey or coloured boxes does not form a normative part
of this standard, and is labelled as either an example or a note.  

{.ednote} Editorial notes, such as this, are used to record outstanding
issues, or points where there is not yet consensus; they will be
resolved and removed for the final standard.  Examples and notes will be
retained in the standard.

The grammar given here uses the form of EBNF notation defined in §6 of
&#x5B;[XML](https://www.w3.org/TR/xml11/)], except that no significance is
attached to the capitalisation of grammar symbols.  *Conforming*
applications *must not* generate data not conforming to the syntax given
here, but non-conforming syntax *may* be accepted and processed by a
*conforming* application in an implementation-defined manner.

{.note} In this form of EBNF, *whitespace* is only permitted where it
is explicitly stated in the grammar.  It is not automatically permitted
between arbitrary tokens in the grammar.

The grammar productions in this standard uses the `S` and `Char`
productions defined in §2 of [Basic Concepts] to match any non-empty
sequence of *whitespace* *characters* or any valid *character*,
respectively.

This standard uses the *prefix notation*, as defined in §4.3 of [Basic
Concepts], when discussing specific *terms*.  The following *prefix*
bindings are assumed in this standard:

------           -----------------------------------------------
`elf`            `https://terms.fhiso.org/elf/`
`ex`             `https://example.com/`
------           -----------------------------------------------

{.note} Although *prefix notation* is included in this standard document
(see {§prefix}), that is only in the context of serialised data.
When used outside of a serialised example, prefix notation is simply a
notational convenience to make the standard easier to read.

{.ednote} Review the previous note.

## Overview                                                        {#overview}

The ELF serialisation format is a structured, line-based text format for
encoding data in a hierarchical manner that is both machine-readable and
human-readable.  

At a logical level, an ELF document is built from **structures**, the name
ELF gives to the basic hierarchical data structures used to represent
data.  Each *structure* consists of:

*  a *type identifier*, which is a *term* that encodes the meaning of
   the *structure*;
*  an *optional* *payload*, which is either a *string* or a *pointer* to
   another *structure*; and 
*  a sequence of zero or more child *structures* known as its
   *substructures*.  

A top-level *structure* which is not a *substructure* of any other
*structure* is called a **record**.  An ELF document or **dataset** can
have arbitrarily many *records*.

{.ednote}  This is either not strictly true or at least misleading,
because `HEAD` and `TRLR` are not *records*.  Probably.

{.note} The expressiveness of ELF is similar to that of XML.  ELF's
*structures* serve the same role as elements in XML, and nest similarly.
But unlike XML, which has a single root-level element, an ELF *dataset*
typically has multiple *records*.

The ELF serialisation format is a general purpose format that can be
used to represent arbitrary data, depending on the *type identifiers*
used in the *dataset*.  A particular set of *type identifiers*, together
with their meanings and restrictions on how they are to be used, is
called a **data model**.  

{.note}  The ELF serialisation format is designed to be useable with
various *data models*; however it is anticipated that most files using
the ELF serialisation format will use the data model described in [ELF
Data Model], which is based on and compatible with GEDCOM's
lineage-linked form.

At a lexical level, a *structure* is encoded as sequence of **lines**,
each terminated with a *line break*.  The first *line* encodes the *type
identifier* and *payload* of the *structure*, while any *substructures*
are encoded in order on subsequent *lines*.  Each *line* consists of the
following components, in order:

*  a *level*, which is a non-negative decimal *integer* that records how
   many levels of *substructures* deep the current *structure* is nested;
*  an *optional* *structure identifier*, which is an identifier written
   between two "at" signs (U+0040) that can be referenced by a *pointer*
   in the payload of another *structure*; 
*  a *tag*, which encodes the *type identifier* of the *structure*; and
*  the *optional* *payload* of the *structure* encoded by the *line*.

{.example ...}
    0 HEAD
    1 GEDC
    2 VERS 5.5.1
    2 ELF 1.0.0
    2 FORM LINEAGE-LINKED
    1 CHAR UTF-8
    0 INDI
    1 NAME Charlemagne
    0 TRLR

This ELF document has three *lines* with *level* `0` which mark the
start of the three top-level *structures* or *records*.  These *records*
have, respectively, three, one and zero *substructures*, which are
denoted by the *lines* with *level* `1`.   The *structure* represented
by the *line* with a `CHAR` *tag* is a *substructure* of the `HEAD`
*record* because there is no intervening *line* with *level* one less
than `1` (i.e.  `0`); the *structure* represented by the `NAME` *line*
naming Charlemagne is a *substructure* of the `INDI` *record*, as that
is the preceding *line* with a *level* `0`.   The `TRLR` *record* is an
example of a *record* with no *substructures*.

Five of the *lines* in this example document have a *payload*.  For
example, the *payload* of the `FORM` *line* is the *string*
"`LINEAGE-LINKED`", while the *payload* of the `NAME` *line* is the
*string* "`Charlemagne`".  None of the *lines* in this example have
*payload* which are *pointers*, nor do any have a *structure
identifier*.
{/}

The input to an ELF parser is an **octet stream**, which is a sequence of
8-bit bytes or **octets** each with a value between 0 and 255.

{.note}  An *octet stream* is typically read from a disk or the network.
This standard does not define how these should be read, now how the
*octets* are represented in storage or in transit on a network.

This document specifies how an *octet stream* is parsed into a
*dataset*, and how a *dataset* is serialised into an *octet stream*.
Overviews of these processes can be found in {§parsing} and
{§serialising}, respectively.

### Parsing                                                         {#parsing}
    
The parsing process can be summarised as follows:

1. An *octet stream* is converted to a sequence of *line strings* by

    a. determining its *character encoding* by 
    
        i.  detecting a *character encoding* per {§detected-enc}, and 
        ii. using that *detected character encoding* to look for a
            *specified character encoding* in the *serialisation
            metadata* per {§specified-enc};
    
    b. converting *octets* to *characters* using that *character
       encoding*; and
    c. splitting on *line breaks* per {§line-strings}.

2. *Line strings* are parsed as *lines* by

    - parsing the *level*, *tag*, *xref_id*, and *payload* of each
      *line*; 
    - creating an *error line* if that fails.

3. *Lines* are parsed into *xref structures* by

    - re-merging `CONC` and `CONT`-split *payloads*; violations of splitting rules are ignored
    - using *levels* to properly nest *xref structures*
    - converting to *error lines* before parsing if the *levels* are inconsistent

4. *xref structures* are parsed into *tagged structures* by simultaneously

    - converting *xrefs* to *pointers*, with a special "point to null" if this fails
    - unescaping `@` *characters*
    - preserving valid *escapes* and removing others
    - converting *unicode escapes* into their represented *characters*,

5. the *tagged structures* that represent the *schema* are parsed

6. *tags* are converted into *structure type identifiers* using the *schema*
    and the resulting *structures* placed in the *metadata* or *document* as appropriate.
    *Tags* with no corresponding *structure type identifier* are converted into appropriate *undefined tag identifiers*.


### Serialisation                                               {#serialising}

The semantics of serialisation are defined by the following procedural outline.

1. Each *structure* is assigned a *tag* based on its *structure type identifier*, *superstructure type identifier*, and a *schema* which MAY be augmented during serialisation to allow all *structures* to have a *tag*.

2. The *tagged structures* are ordered and additional *tagged structures* created to represent *serialisation metadata*.
    
    This step cannot happen before tagging because tagging may generate *serialisation metadata* that needs to be included in the *tagged structures*.

3. Payloads are converted to create *xref structures* by simultaneously
    
    - assigning *xref_ids* and replacing *pointer*-valued *payloads* with *string*-valued *xrefs*
    - escaping `@` *characters*
    - preserving valid *escapes*
    - escaping unrepresentable *characters*
    
    Semantically, these actions must happen concurrently because none of them should be applied to the others' results.
    
    This step cannot happen before tagging because tags are needed to determine the set of valid *escapes*.
    This step cannot happen before adding *serialisation metadata* because it is applied to the *serialisation metadata* as well.

4. The *dataset* is converted to a sequence of *lines* by

    - assigning *levels*
    - splitting *payloads*, if needed, using `CONT` and `CONC`
    - ordering *substructures* in a preorder traversal of the *tagged structures*
    
    This step cannot happen before payload conversion because valid split points are dependant on proper escaping.
    This step must happen before encoding as octets because valid split points are determined by *character*, not octet.

5. The sequence of *lines* is converted to an octet stream by

    - concatenating the *lines* with *line-break* terminators
    - converting *strings* to octets using the *character encoding*


### Constructs

This document uses five externally-visible constructs:
*dataset*, *metadata*, *document*, *structure*, and *octet stream*.
For clarity of presentation, it also uses several intermediate constructs internally:
*line*, *xref structure*, and *tagged structure*.
Each is defined in {§glossary}.

### Glossary                                                       {#glossary}

{.ednote}  *Line*, *octet*, *octet stream*, *record* and *structure* are
now defined in {§overview}, while *character encoding* is defined in
{§parsing-enc}, and *line break* is defined in {§line-strings}.  The
notion of a *delimiter* is being removed.  *Dataset* and *document* are
very nearly defined in {§overview} too, but we don't currently discuss
*metadata* there &mdash; this is an issue which needs resolving.

Character encoding
:   The scheme used to map between an *octet stream*
    and a *string* of *characters*.

Dataset
:   *Metadata* and a *document*.

Delimiter
:   A sequence of one or more space or tabulation characters.

        Delim ::= [#20#9]+
    
    During serialisation, a single space (U+0020) SHOULD be used
    each place a *delimiter* is expected.

Document
:   An unordered set of *structures*.

Line
:   1. A *level*, a non-negative *integer*
    2. An optional *xref_id*
    3. A *tag*, a *string* matching production `Tag`
    4. An optional *payload*, which is a *string* containing any number of *characters*, but which *must not* contain a *line-break*.

Line break
:   A sequence of one or more newline and/or carriage return characters.

        LB ::= [#A#D]+

    During serialisation, each *line break* MUST be one of 
    
    - a single newline (U+000A)
    - a single carriage return (U+000D)
    - a single carriage return followed by a single newline (U+000D U+000A)
    
    The same string SHOULD be used each place a *line break* is expected.

Metadata
:   A collections of *structures* intended to describe information about the dataset as a whole.
    
    The relative order of *structures* with the same *structure type identifier* SHALL be preserved within this collection;
    the relative order of *structures* with distinct *structure type identifiers* is not defined by this specification.

Octet
:   One of 256 values, often represented as the numbers 0 through 255.
    Also called a "byte."

Octet Stream
:   A sequence of octets.

Record
:   A *structure*, *tagged structure*, or *xref structure* whose *superstructure* is the *document*.

ELF Schema
:   Information needed to correctly parse *tagged structures* into *structures*:
    a mapping between *structure type identifiers* and *tags*
    and metadata relating to valid *escapes* and *prefixes*.

Serialisation Metadata
:   *Tagged structures* inserted during serialisation
    and removed (with all its *substructures*) during parsing.
    They are used to serialise the *character encoding* and *ELF schema*
    as well as to separate the *metadata* and the *document*.

Structure
:   - A **structure type identifier**, which is a *term*.
    - Optionally, a **payload** which is one of
        - A **pointer** to another *structure*, which *must* be a *record* within the same *dataset*.
        - A *string* or subtype thereof.
    - One **superstructure**, which is one of
        - Another *structure*; *superstructure* links MUST be acyclic.
        - The *document*.
        - The *metadata*.
    - A collection of any number of **substructures**, which are *structures*.

        The relative order of *structures* with the same *structure type identifier* SHALL be preserved within this collection;
        the relative order of *structures* with distinct *structure type identifiers* is not defined by this specification.

Superstructure type identifier
:   A *term* identifying the type of the *superstructure* of a *structure*.
    If the *superstructure* is the *document*, this is `elf:Document`.
    If the *superstructure* is the *metadata*, this is `elf:Metadata`.
    Otherwise, this is the *structure type identifier* of a *structures*'s *superstructure*.
    
{.note} *Superstructure type identifier* is not transitive, applying only to the immediate superstructure.

{.example ...} Suppose 
an `elf:INDIVIDUAL_RECORD` is the superstructure of an `elf:GRADUATION`
and the `elf:GRADUATION` is the superstructure of an `elf:AGE_AT_EVENT`.
The *superstructure type identifier* of the `elf:AGE_AT_EVENT` is `elf:GRADUATION`,
not `elf:INDIVIDUAL_RECORD`.
{/}


Tagged Structure
:   Like a *structure*, except 
    
    - it has a *tag* instead of a *structure type identifier*.
    - its *substructures* are stored in a sequence with defined order, not in a partially-ordered collection.

Undefined tag identifier
:   A *term* containing a single `#` (U+0023)
    with `elf:Undefined` before it
    and a *string* matching production `Tag` after it.
    The *string* after the U+0023 is called the *tag* of the *undefined tag identifier*.

Xref Structure
:   Like a *tagged structure*, except
    
    - it may have an optional *xref_id*.
    - its payload, if present, is always a *string*, not a *pointer*.

## Parsing and serialising lines                                {#parsing-enc}

In order to parse an ELF document, an application *shall* first convert
the *octet stream* into a sequence of *lines*.  The way in which
*octets* are mapped to *characters* is called the **character encoding**
of the document.  ELF supports several different *character encodings*.
Determining which is used is a two-stage process, with the first stage
being to determine the **detected character encoding** of the *octet
stream* per {§detected-enc}.  Frequently there will be no *detected
character encoding*.  

{.note}  The purpose of this step is twofold: first, it allows
non-ASCII-compatible *character encodings* like UTF-16 to be supported;
and secondly, it removes any byte-order mark that might be present in
the *octet stream*.

Next, the initial portion of the *octet stream* is converted to
*characters* using the *detected character encoding*, failing which in
an ASCII-compatible manner.  This *character* sequence is then scanned
for a `CHAR` *line* whose *payload* identifies the **specified character
encoding**.  This process is described in {§specified-enc}.  If there is
a *specified character encoding*, it is used as the *character encoding*
for the ELF document; otherwise the *detected character encoding* is
used, failing which the default is the ANSEL *character encoding*.
Considerations for reading specific *character encodings* can be found
in {§encodings}.

### Detecting a character encoding                             {#detected-enc}

{.note} For applications that choose not to support the *optional*
UTF-16 *character encoding*, the process described in this section can
be as simple as skipping over a UTF-8 byte-order mark, and determining
the *detected character encoding* to be UTF-8 if a byte-order mark was
present.

If a *character encoding* is specified via any supported external means,
such as an HTTP `Content-Type` header, this *should* be taken as to be
the *detected character encoding*.

{.example ...}  Suppose the ELF file was download using HTTP and the
response included this header:

    Content-Type: text/plain; charset=UTF-8

If an application supports taking the *detected character encoding* from
an HTTP `Content-Type` header, the *detected character encoding*
*should* be UTF-8.

Note that the use of the MIME type `text/plain` is *not recommended* for
ELF.  It is used here purely as an example. 
{/}

Otherwise, if the *octet stream* begins with a byte-order mark (U+FEFF)
encoded in UTF-8, the *detected character encoding* *shall* be UTF-8; or
if the application supports the *optional* UTF-16 encoding and the
*octet steam* begins with a byte-order mark encoded in UTF-16 of either
endianness, the *detected character encoding* *shall* be UTF-16 of the
appropriate endianness.  The byte-order mark *shall* be removed from the
*octet stream* before further processing.

Otherwise, if the application supports the *optional* UTF-16 encoding
and the *octet stream* begins with any ASCII *character* (U+0001 to
U+007F) encoded in UTF-16 of either endianness, this encoding *shall* be
the *detected character encoding*. 

{.example} ELF files typically begin with the *character* "`0`".  In
the big endian form of UTF-16, sometimes called UTF-16BE, this is
encoded with the hexadecimal *octets* `00 30`.  These two *octets* will
be detected as an ASCII *character* encoded in UTF-16, and the *detected
charcter encoding* will be determined to be UTF-16BE.

Otherwise, applications *may* try to detect other encodings by examining
the *octet stream* in an implementation-defined manner, but this is 
*not recommended*.

{.note}  One situation where it might be necessary to try to detect
another encoding is if the application needs to support (as an
extension) a *character encoding* like EBCDIC or UTF-32 which is not
compatible with ASCII.

Otherwise, there is no *detected character encoding*.

{.note ...} In this case, for the *octet stream* to be understood, it
must use a 7- or 8-bit *character encoding* that is sufficiently
compatible with ASCII that the `CHAR` *line* can be read.  The only 7 or
8-bit *character encodings* defined in this standard are ASCII, ANSEL
and UTF-8 which encode ASCII *characters* identically.  These will all
be understood correctly if there is no *detected character encoding*.

Some *character encodings* with minor differences from ASCII can also be
understood correctly.  An example is the Japanese Shift-JIS *character
encoding* which uses the *octets* 5C and 7E to encode the yen currency
sign (U+00A5) and overline *character* (U+203E) where ASCII has a
backslash (U+005C) and tilde (U+007E).  An application does not need to
understand these *characters* in order to scan for a `CHAR` *line*.
{/}

{.note ...} These cases can be summarised as follows, where `xx` denotes
any *octet* with a hexadecimal value between `01` and `7F`, inclusive:

----------------  -------------------------------------------------
Initial octets    Detected character encoding
----------------  -------------------------------------------------
`EF BB BF`        UTF-8, with byte-order mark

`FF FE`           UTF-16, little endian, with byte-order mark

`FE FF`           UTF-16, big endian, with byte-order mark

`xx 00`           UTF-16, little endian, without byte-order mark

`00 xx`           UTF-16, big endian, without byte-order mark

Otherwise         None
----------------  -------------------------------------------------
{/}

### Specified character encodings                             {#specified-enc}

To determine the *specified character encoding*, the initial portion of
the *octet stream* *shall* temporarily be converted to *characters*
using the *detected character encoding*.  

If there is no *detected character encoding*, the application *shall*
convert each *octet* to the *character* whose *code point* is the value
of *octet*.  An application *may* given an error if the null *octet*
`00` is encountered.

{.note}  This is equivalent to using the ISO-8859-1 *character encoding*
if there is no *detected character encoding*.  As defined in §2 of
[Basic Concepts], *code point* U+0000 does not correspond to a valid
*character*.  In principle, the *octet* `00` might occur in the
representation of a valid *character* in some *character encoding*, but
most *character encodings* avoid this and it cannot happen in the ASCII,
ANSEL or UTF-8 *character encodings*.  The same is true of octets
corresponding to those control *characters* matching the
`RestrictedChar` production in §2 of [Basic Concepts], which [Basic
Concepts] allows an application to reject.

*Characters* from the initial portion of the *octet stream* are
parsed into *lines strings* as described in {§line-strings}, each
*line string* is *whitespace normalised* as described in §2 of [Basic
Concepts], and all lowercase ASCII *characters* (U+0061 to U+007A)
converted to the corresponding uppercase *characters* (U+0041 to
U+005A).

{.note} *Whitespace normalisation* and conversion to uppercase only
applies for the purpose of determining the *specified character set*.
Neither process is otherwise applied to all *line strings*.  It is done
here to simplify scanning for the *specified character set*, but without
requiring full parsing of *line strings* into a *lines*, which might
result in errors if actual *character encoding* is different to the one
being used provisionally while scanning for the *specified character
encoding*.

Once normalised in this manner, the first *line string* of the file
*must* be exactly "`0 HEAD`"; otherwise the application *must*
issue an error and cease parse the *octet stream* as ELF.  If
the application encounters a subsequent normalised *line string*
beginning with a `0` digit (U+0030) followed by a space *character*
(U+0020), the application *shall* stop scanning for a *specified
character encoding*.

{.note}  A *line string* beginning with a "`0`" encodes the start of the
next *record*, and therefore the end of the `HEAD` *record*.  The
*specified character encoding* is given in a `CHAR` *line* in the `HEAD`
*record*; a `CHAR` *line* found elsewhere in the file *must not* be used
to supply the *specified character encoding*.

If the application encounters a *line string* beginning with "`1 CHAR`"
followed by a space *character* (U+0020) while scanning for the
*specified character encoding*, then the remainder of the *line string*
*shall* be used to determine the *specified character encoding*.

If the remainder of the *line string* is exactly "`ASCII`", "`ANSEL`" or
"`UTF-8`", then the *specified character encoding* *shall* be ASCII,
ANSEL or UTF-8, respectively.

{.example ...}  It is *recommended* that all ELF documents use UTF-8 and
record this using a `CHAR` *line* as follows:

    0 HEAD
    1 CHAR UTF-8

This `CHAR` *line string* will be found while scanning for the
*specified character encoding*.  The *line string* begins with "`1
CHAR`" followed by a space *character*; the remainder of the *line
string* is "`UTF-8`" so the *specified character encoding* is recognised
as UTF-8.
{/}

Otherwise, if the remainder of the *line string* is exactly "`UNICODE`"
and the *detected character encoding* is UTF-16 in either endianness,
the *specified character encoding* *shall* be the UTF-16 in that
endianness.

{.note} [GEDCOM 5.5.1] says that the *string* "`UNICODE`" is used to
specify the UTF-16 encoding, though without naming the encoding as such,
and without specifying which endianness is meant.  If the *octet stream*
is a valid ELF document encoded in UTF-16 and the application supports
UTF-16, then the *detected character encoding* will have been determined
accordingly.

Otherwise, the application *may* determine the *specified character
encoding* from the remainder of the *line string* and the *detected
character encoding* in an implementation-defined way.  The application
*may* read one further *line string*, and if it begins with "`2 VERS`"
followed by a space *character* (U+0020), the application *may* also use
the remainder of that *line string* in determining the *specified
character encoding*.

{.example ...}  It is fairly common to find "`ANSI`" on the `CHAR`
*line*, though this has never been a legal option in any version of
GEDCOM.  It typically refers to one of several Windows code pages, most
frequently CP-1252 which was the Windows default code page for English
language installations and for several other Western European languages.
However other code pages exist, and an application localised for, say,
Hungarian might encode the file using CP-1250.  In principle a `VERS`
*line* could contain information to specify the particular code page
used, as in the following ELF fragment, but in practice this is rare.  

    0 HEAD
    1 CHAR ANSI
    2 VERS 1250
{/}

Otherwise, there is no *specified character encoding*.

If there is a *specified character encoding*, it *shall* be used as the
*character encoding* of the *octet stream*.  Otherwise, if there is a
*detected character encoding*, it *shall* be used as the *character
encoding* of the octet stream.  Otherwise, the *character encoding*
*shall* default to be ANSEL.

{.note}  ANSEL is the default *character encoding* for compatibility
with GEDCOM, despite being it being *deprecated* in ELF.

If the *character encoding* is one which the application does not
support, the application *shall* issue an error and stop reading the
file.

### Character encodings                                           {#encodings}

Support for reading the ASCII, ANSEL and UTF-8 *character encodings* is
*required* by this standard.  Application support for the 
UTF-16 *character encoding* is *optional*.  Applications *may* support
it in either its big or little endian forms, both, or neither.  The
ANSEL or UTF-16 *character encodings* are *deprecated*.

{.ednote}  We considered making support for ANSEL *optional*, but after
researching  how frequently current GEDCOM files were encoded using
ANSEL (as opposed to claiming to be ANSEL but actually using the ASCII
subset of ANSEL), the TSC felt it had to be *required*.

The UTF-8 and UTF-16 *character encodings* are the Unicode encoding
forms defined in §2.5 of [ISO 10646], and the specifics of the big and
little endian forms of UTF-16 are defined in §2.6 of [ISO 10646].  

{.note}  UTF-8 is a variable-width *character encoding* that uses
between one and four *octets* to encode a *character*.  It is backwards
compatible with ASCII, so ASCII *characters* are encoded to a single
*octet* and other *characters* require more.  For example, the Czech
given name "Miloš" is encoded using the *octet* sequence `4D 69 6C 6F C5
A1` where the last two *octets* encode the *character* "š".  Only
*characters* outside Unicode's Basic Multilingual Plane &mdash; that is
*characters* with a *code point* of U+10000 or higher &mdash; are
encoded with four *octets*.  An example is the ancient Chinese
*character* "𠀡" which is encoded using the *octets* `F0 A0 80 A1`.
Such *characters* can occasionally be found encoded using six *octets*
(e.g. `ED A1 80 ED B0 A1` for "𠀡").  This form, which is called CESU-8
and is not valid UTF-8, typically results from an incorrect
serialisation of UTF-16 data as UTF-8.  ELF neither requires nor
prohibits *conformant* applications from reading these CESU-8 forms, but
they *must not* be generated when serialising data as UTF-8.

{.note}  UTF-16 is also a variable-width *character encoding* which
normally uses two *octets* to encode a *character*, but uses four
*octets* for *characters* outside the Basic Multilingual Plane.  When
only two *octets* are used, UTF-16 is identical to an earlier
fixed-width *character encoding* called UCS-2 which was unable to encode
*characters* outside the Basic Multilingual Plane.  *Conformant*
applications are *required* by §2 of [Basic Concepts] to support
*characters* outside the Basic Multilingual Plane, and therefore
applications which opt to support UTF-16 *must* ensure they do not
implement support for only UCS-2.

{.note}  As UTF-8 and UTF-16 are encodings of Unicode, they naturally
decode into a sequence of Unicode *characters* without requiring
conversion between character sets.

The *character encoding* referred to as ASCII in this standard is the US
version of ASCII which, for the purpose of this standard, is defined as
the subset of UTF-8 which uses only Unicode characters U+0001 to U+007F.

{.note} The US ASCII *character encoding* is nominally defined in
[ASCII], but this standard defines it in terms of [ISO 10646].  This is
partly to avoid uncertainty over which of several incompatible
definitions of ASCII is meant, partly because the Unicode standard is
much more readily available than the ASCII one, and partly because ASCII
allows certain punctuation marks a be used as combining diacritics when
they follow the backspace *character* (U+0008).  This use of ASCII
combining diacritics is not included in [ISO 10646], and is forbidden in
both GEDCOM and ELF as the backspace *character* *must not* occur.
Unicode provides a separate set of combining diacritics which are
permitted in ELF.

ANSEL refers to the Extended Latin Alphabet Coded Character Set for
Bibliographic Use defined in [ANSEL].  If an ELF file is determined to
use the ANSEL *character encoding* it *must* be converted into a
sequence of Unicode *characters* before it can be processed further.
This is discussed in {§ansel}.

If other *character encodings* are supported, they too must be converted
into a sequence of Unicode *characters* for further processing.

{.note}  This standard makes no recommendation on how applications
should represent sequences of Unicode *characters* internally, and the
UTF-8, UTF-16 and UTF-32 *character encodings* each have advantages.

{.ednote}  This standard currently makes no distinction between a
*character set* and a *character encoding*, but arguably it would be
cleaner to make this distinction.  Then UTF-16 and UTF-8 are different
*character encodings* of the same Unicode *character set*, and ASCII may
be regarded as such too for our purpose; but ANSEL is a different
*character set* and required conversion to Unicode.  [ISO 10646] makes
a further distinction between *encoding forms* like UTF-8 and UTF-16, and
*encoding schemes* like UTF-16BE and UTF-16LE.

#### Converting ANSEL to Unicode                                      {#ansel}

{.ednote} Add material from `ansel-to-unicode.md`.

### Line strings                                               {#line-strings}

Before *characters* from the *octet stream* can be parsed into *lines*,
they must be assembled into **line strings**, which are *strings*
containing the lexical representations of *lines* before they have been
parsed.

*Characters* are appended to the *line string* until a *line break* is
encountered, at which point the *character* or *characters* forming the
*line break* are discarded and a new *line string* is begun.  A **line
break** is defined as a line feed (U+000A), or carriage return (U+000D)
followed by an *optional* line feed (U+000A).  It matches the following
`LB` production:

    LB  ::=  #xD #xA? | #xA

{.note}  This definition of a *line break* matches the form of line
endings used on Unix, Linux and modern Mac OS (U+000A), the
traditional Mac OS form (U+000D), and Windows line endings (U+000D
U+000A).  Unlike the equivalent production in [GEDCOM 5.5.1], this does
not match a line feed followed by a carriage return (U+000A U+000D)
which was used as a line ending on BBC and Acorn computers in some
specific contexts.  In ELF, this sequence is parsed as two *line breaks*
with an intervening blank *line string* which gets ignored.

Any leading *whitespace* *shall* be removed from the *line string*, and
any trailing *whitespace* *should* also be removed.  If this results in
a *line string* which is an empty *string*, the empty *line string* is
discarded.

{.note ...} These operations resolve ambiguities in [GEDCOM 5.5.1], and
might therefore be a change from some current implementations'
interpretation of the GEDCOM standard.  On the one hand, §1 of [GEDCOM
5.5.1] say that leading *whitespace*, including extra line terminators,
should be allowed and ignored when reading;  on the other hand, the
relevant grammar production does not permit any such leading
*whitespace*.  For maximal compatibility with existing data, a
*conformant* ELF application *must* accept and ignore leading
*whitespace* and blank lines, but *must not* generate them.

For trailing *whitespace*, [GEDCOM 5.5.1] is even less clear.  Twice,
once in §2 and again Appendix&nbsp;A, it states that applications
sometimes remove trailing *whitespace*, but without saying whether this
behaviour is legal; certainly it implies it is not required.  There
is little consistency in the behaviour of current applications, so any
resolution to this will result in an incompatibility some applications.
In ELF, the removal of trailing *whitespace* is *recommended*, and a
future version of ELF is likely to make this *required*.  It is
explicitly not *required* in this standard so that applications *may*
decide whether to remove trailing *whitespace* based on the identity of
the application that produce the file.  Applications *should not* leave
trailing *whitespace* on *line strings* unconditionally.

The Unicode escape mechanism defined in {§unicode-escape} provides ELF
applications with a way of serialising a value which legitimately ends
in *whitespace* without it being removed.
{/}

{.ednote}  FHISO's general philosophy regarding *whitespace* is that,
where possible, ELF should avoid placing any significance on invisible
difference in *whitespace*.  This includes the difference between spaces
and tabs, and trailing *whitespace* on *lines*.

### Parsing lines                                                     {#lines}

To parse a *line string* into a *line*, the *line string* *must* match
the following `Line` production:

    Line ::= Number S (XRefID S)? Tag (S Pointer | S String)?

{.note ...}  The `Line` production does not allow leading or trailing
*whitespace* because this has already been removed in the process of
creating *line strings*.  The `S` production is defined in §2 of [Basic
Concepts] and matches any on-empty sequence of *whitespace*
*characters*, though because carriage returns and line feeds are always
treated as *line breaks* which delimit *line strings*, in practice the
`S` production can only match space or horizontal tab *characters*.
Allowing tabs or multiple space *characters* is a departure from [GEDCOM
5.5.1], but one that is commonly implemented in current applications.

*Whitespace* is *required* between each of the four components of the
*line*.  This is a change from [GEDCOM 5.5.1] where the grammar says
that the delimiter is an *optional* space character.  Documents written
using very early versions of GEDCOM frequently took advantage of this to
merge the *level*, *structure identifier* and *tag* together, as in
"`0@I1@INDI`".  This is not permitted permitted in ELF.
{/}

{.ednote}  It would be simple enough to modify the grammar so that
"`0@I1@INDI`" would still be supported, and this could make ELF
Serialisation backwards compatible with GEDCOM 1.0.  However the
facility is almost never found in GEDCOM 5.5 or 5.5.1 files, and is
often not supported in applications.  It may even be a error that it is
still permitted in the GEDCOM grammar.  Files created for earlier
versions of GEDCOM are only very rarely encountered and their data model
is incompatible with [ELF Data Model].  There seems to be little benefit
to supporting earlier versions of GEDCOM in the serialisation layer but
not in the data model.

The `Line` production contains an ambiguity as any *string* which
matches the `Pointer` production necessarily also matches the `String`
production.  *Conformant* applications *must* treat the payload as a
*pointer* if it matches the `Pointer` production, and only as a *string*
if it does not.

{.ednote ...}  An earlier draft of this standard used the following
`PayloadString` production in place of the general-purpose `String`
production.  This ensures that only strings with correctly escaped "at"
signs (U+0040) are allowed in a *payload*.  This removes this ambiguity
from the grammar by ensuring *pointers* do not match the `PayloadString`
production.

    PayloadString ::= PayloadItem*
    PayloadItem   ::= [^#x40] | "@@" | Escape
    Escape        ::= "@#" [^#x40#xA#xD]* "@"

This draft does not do this because it would require all "at" signs to
be correctly escaped.   In practice, unescaped "at" signs are fairly
commonly found in GEDCOM files, particularly in the *payload* of `EMAIL`
*lines*.  It is fairly easy to specify ELF so that these can be
accommodated and this draft does so at the cost of introducing this
ambiguity into the grammar.  In practice it is not anticipated that the
ambiguity will cause implementers difficulties and many current products
appear to allow unescaped "at" signs in the manner proposed here.
{/}

The `Line` production contains a second ambiguity: when there are
multiple *characters* of *whitespace* following a *tag* on a *line*
whose *payload* is a *string*, the second and subsequent *whitespace*
*characters* can be parsed by the `S` production or the `String`
production.  Applications *should* resolve this ambiguity by matching
the `S` production to the shortest possible non-empty sequence of
*whitespace* so that any additional *whitespace* is considered to be
part of the *payload*.

{.note ...} This ambiguity is inherited from [GEDCOM 5.5.1].  On the one
hand, the grammar in §1 of [GEDCOM 5.5.1] allows at most one space
*character* and any further space *characters* are therefore considered
part of the *payload*.  On the other hand, Appendix&nbsp;A says that
some applications look for the first non-space *character* to denote the
start of the *payload*, and recommends against doing this with the
*payload* of the `CONT` tag.

This ambiguity is most problematic on `CONC` *lines* where it can result
in unwanted *whitespace* being inserted in the middle of a word, or 
necessary *whitespace* being lost between words; it can also cause
problems with any *payload* which has leading *whitespace* which needs
to be preserved.
To avoid this, using the `CONC` mechanism to split the *payload* next to
*whitespace* is *not recommended*, and the Unicode escaped in
{§unicode-escape} provides a means of preventing important leading
*whitespace* from being lost.  These allow ELF applications to avoid
depending on this undefined behaviour.
{/}

{.ednote}  This standard could have *required* leading *whitespace* to
be preserved in *payloads*.  This standard doesn't do that in part to
discourage applications from relying on it instead of avoiding the
problem.  In general, we would rather the standard did not attach
significance to differences in *whitespace*, and it is possible FHISO
might want to remove the ambiguity in the future by requiring the
*payload* to begin with a non-*whitespace* *character*.  Ensuring valid
ELF files do not have leading *whitespace* in *payloads* should help
make this possible.

The `Number`, `XRefID` and `Tag` productions encodes the *level*, the
*structure identifier* and the *tag* of the *line*, respectively.  The
`String` and `Pointer` productions encode the *payload* of the *line*,
depending on whether the *payload* is a *string* or a *pointer*,
respectively.  The *structure identifier* and *payload* are both
*optional*.

    Number  ::= "0" | [1-9] [0-9]*
    XRefID  ::= "@" [a-zA-Z0-9_] [^@:!]* "@"
    Tag     ::= [0-9a-zA-Z_]+
    String  ::= Char+
    Pointer ::= "@" [a-zA-Z0-9_] [^@]* "@"

{.ednote} The current working draft of [Basic Concepts] has a `String`
production which is defined as `Char*`.  The `String` production here
only matches a non-empty *string*.  This is to avoid any difference
arising between a *line* with no *payload* and a *line* whose payload is
an empty *string*.  However it may be better to remove this potential
ambiguity in a different way.

{.example ...}
    0 @I1@ INDI
    1 NAME Cleopatra
    1 FAMC @F2@

This ELF fragment contains three *lines*.  The first *line* has a
*level* of `0`, a *structure identifier* of `@I1@`, and a *tag* of
`INDI`; it has no *payload*.  Neither the second nor the third *line*
has a *structure identifier*, and both have a *payload*: on the second
line the *payload* is the *string* "`Cleopatra`", while the *payload* of
the third *line* is a pointer, `@F2@`.
{/}

### Serialising lines

{.ednote} The payload needs escaping, either here or in the next
section.

Each *line* *shall* be converted to a *line string* by concatenating
together the *level*, *structure identifier*, *tag* and *payload* as
described by the `Line` *production* given in {§lines}.  

If most of the *lines* being serialised originated from the same ELF
file and are being re-serialised unaltered, a *conformant* application
*may* preserve the original syntactic form of these *line string*.
Otherwise, the application *must* serialise all *line strings* with a
single space *character* (U+0020) for each `S` production in the `Line`
production.

{.note}  This standard allows applications to preserve the syntactic
form of *line strings* so that applications which carry out small
in-place edits to an ELF file are *conformant*.  Otherwise, this is 
*not recommended*.

*Line strings* *shall* be concatenated into a single *string*, with a
*line break* between each *line string* and after the last one.  All 
*line breaks* inserted *must* have identical lexical forms matching the
`LB` production in {§line-strings}.

{.note}  Applications can choose whether to use Windows line endings
(U+000D U+000A), traditional Mac OS line endings (U+000D), or the line
endings used on Unix, Linux and modern Mac OS (U+000A), but *must not*
to use mix these in the same file.

Finally, the resulting *string* is encoded into an *octet stream*
using the *character encoding* that was documented in the *serialisation
metadata* *tagged structure* with *tag* "`CHAR`" (see
{§encoding}).  Applications are only *required* to support the UTF-8
*character encoding* when serialising, and this *should* be the default.

{.ednote} Check the above paragraph.

## Levels and lines

Each *xref structure* is encoded as a sequence of one or more *lines*.

These are of three kinds, in order:

1. The **first line** of the *xref structure*
2. Zero or more **additional lines** of the *xref structure*
3. The *lines* that encode each of the *xref structure*'s *substructures* (if any)

{.note} The constraint that *additional lines* come before the *lines* of *substructures* is never mentioned by [GEDCOM 5.5.1]. ELF includes it because it appears to have been universally applied by GEDCOM implementations, and some may depend upon it.

The **level** of each line is a non-negative integer.
The *level* of a *first line* is 0 if the *xref structure* is a *record*
or the *serialisation metadata* *tagged structures* with *tag* "`HEAD`" and "`TRLR`";
otherwise it is one greater than the *level* of the *first line* of its *superstructure*.
The *level* of an *additional line* is one greater than the *level* of its *xref structure*'s *first line*.

Each *first line* has the same *xref_id* (if any) and *tag* as its corresponding *xref line*.
Each *additional line* has no *xref_id* and either "`CONT`" or "`CONC`" as its *tag*.

{.note} Because an *xref structure* MUST NOT have either "`CONC`" or "`CONT`" as its *tag* (see {§tag-serialisation}), it is unambiguous which *lines* are *additional lines* and which *first line* they correspond to.

The *payload* of the *xref structure*
is the concatenation of the *payloads* of the *first line* and all *additional lines*,
with a *line break* inserted before the *payload* of each *additional line* with *tag* "`CONT`".
Because the *payload* of a *line* MUST NOT contain a *line-break*, there MUST be exactly one "`CONT`"-*tagged* *additional line* per *line-break* in the *xref structure*'s *payload*.
The number of "`CONC`"-*tagged* *additional lines* may be picked arbitrarily, subject to the following:

- Each *line* SHOULD be no more than 255 octets after being encoded in the *character encoding*.

{.note} GEDCOM *required* that *lines* not exceed 255 *characters*;
this does not seem to be a real restriction in most current applications,
and hence has been reduced to *recommended* status.
We recommend bytes instead of *characters* because the implied 
purpose of this limit (enabling code to use fixed-width buffers)
would limit by bytes, not characters.


- The *payload* of a *line* preceding a "`CONC`"-*tagged* *line* SHOULD NOT have an empty *payload*.
- The *payload* of a *line* preceding a "`CONC`"-*tagged* *line* MUST NOT end with a *delimiter*.
- A "`CONC`"-*tagged* *line*' *payload* SHOULD NOT begin with a *delimiter*.

{.note ...} [GEDCOM 5.5.1] is inconsistent in its discussion of leading and trailing *whitespace*.

- The first of rule in the section "Grammar Rules" in Chapter 1 REQUIRES that spaces be after, not before, a `CONC` split; they (nonsensically) require the same for `CONT`s as well.
- The grammar for `optional_line_value` in Chapter 1 allows both leading and trailing space, with no permission to remove it.
- The definition of `CONC {CONCATENATION}` in Appendix A says an implementation MAY "look for the first non-space starting after the tag to determine the beginning of the value" and hence leading spaces MUST NOT appear.
- The definition of `CONT {CONTINUED}` in Appendix A says an implementation MUST keep leading spaces in a `CONT` as an exception to the usual rules.
- The definition of `NOTE_STRUCTURE` in Chapter 2 says that "most operating systems will strip off the trailing space and the space is lost in the reconstitution of the note."

The RECOMMENDATIONS above are compatible with the most restrictive of these,
while the REQUIREMENTS with the most limiting of them.
{/}

{.example ...}
Suppose an *xref structure*
*tag* is "`NOTE`";
it's *payload* is "`This is a test\nwith one line break`";
and its *superstructure*'s *superstructure* is a *record*.
This *xref structure* requires at least two *lines*
(because it contains one *line break*) and may use more.
It could be serialised in many ways, such as

````gedcom
2 NOTE This is a test
3 CONT with one line break
````

or

````gedcom
2 NOTE This i
3 CONC s a test
3 CONT with on
3 CONC e line break
````
{/}

- Each *line*'s *payload* MUST contain an even number of U+0040 (`@`).
    However, during parsing, this constraint SHALL NOT be enforced in any way.

{.note} [GEDCOM 5.5.1] gives no guidance how to handle unmatched "`@`", but they are relatively common in gedcom files. The above policy is intended to resolve common invalid files in an intuitive way.

{.example ...} Given the following non-*conformant* data

    1 EMAI name@example.com
    2 DATE @#DGREG
    3 CONC ORIAN@ 2 JAN 2019

a *conformant* application will concatenate these *lines* normally during parsing

    1 EMAI name@example.com
    2 DATE @#DGREGORIAN@ 2 JAN 2019

creating a valid date escape in the `DATE`-*tagged* *extended line*.
The unmatched `@` in the `EMAI`-*tagged* *line* is left unchanged during parsing.

Upon re-serialisation, the unmatched @ in the "`EMAI`" will be doubled when converting to an *xref structure*,
but the date escape will not be modified

    1 EMAI name@@example.com
    2 DATE @#DGREGORIAN@ 2 JAN 2019

If the serialisation decides to split either *extended line* with `CONC`s, it MUST NOT do so
in a way that splits up the pairs of "`@`"s.
{/}

### Error lines

A *line string* SHALL be parsed as an **error line**
if it is either *unparseable* or its *line* is *too deep*.

An **unparseable** line is one that does not match production `Parseable`

    Parseable ::= Delim? [0-9]+ (Delim XrefID)? Delim Tag (Delim [^#A#D]*)?

A **too deep** *line* is one that has a *level* more than one greater than its *previous level*.
The **previous level** of a *line* is the *level* of the closest preceding *line* that is not an *error line*
and has a *tag* that is neither "`CONT`" nor "`CONC`" nor "`ERROR`".
If there is no such preceding *line* then the *line* is *too deep* unless its *level* is 0.

An **error line** has *tag* `ERROR`;
and a *level* equal to the 1 + its *previous level*.
If generated by a *too deep* *line* with an *xref_id*,
the *error line* has that same *xref_id*; otherwise it has no *xref_id*.
Its *payload* is

- the entire *unparseable* line, if generated by an *unparseable* line; or
- the serialised *level*, *tag*, and *payload* of the *too deep* *line* otherwise.

{.ednote ...} To do: pick one of the following:

- The *line string* that represents an *error line* is just the *error line*'s *payload*;
    the *level* and *tag* MUST NOT be included.

- The *line string* that represents an *error line* SHALL include the *error line*'s *level* and *tag*,
    like any other *line*.

- The *line string* that represents an *error line* MAY either include the *error line*'s *level* and *tag*,
    like any other *line*; or MAY be just the *error line*'s *payload* with no *level* or *tag*.
{/}

{.note} Because "`ERROR`" MUST NOT be the *tag* of any *tag definition*,
the *structure type definition* of the *structure* corresponding to an *error line*
is the *undefined tag identifier* `elf:Undefined#ERROR`.

{.example ...} The following invalid input

    0 HEAD
    1 CHAR UTF-8
    1 SCHMA
    unexpected nonsense
    2 SCHMA https://fhiso.org/TR/elf-data-model/v1.0.0
    0 @N1@ NOTE This is text
    1 CONT more text
    2 CONT still more text
    1 SOUR @S1@
    1 CONT attached to nothing
    0 @S1@ SOUR
    2 @XYZ@ NOTE text
    0 TRLR

contains three *error lines*:

- "`unexpected nonsense`" is *unparseable*
    and is treated as it if were "`2 ERROR unexpected nonsense`"

- "`2 CONT still more text`" is *too deep*.
    It's *level* is 2 greater than the *previous level*
    (because the "`1 CONT more text`" line is not counted as a *previous level*)
    and is treated as it if were "`1 ERROR 2 CONT still more text`"

- "`2 @XYZ@ NOTE text`" has a *level* 2 greater than the *previous level*
    and is treated as it if were "`1 @XYZ@ ERROR 2 NOTE text`"

One other *line* will be identified as `elf:Undefined`:

- "`1 CONT attached to nothing`" is not an *additional line*
    as a *substructure* precedes it,
    and `CONT` has no *tag definition*
{/}


## Encoding with `@`

ELF uses the *character* U+0040 (commercial at, `@`)
to encode several special cases when encoding a *tagged structure*
as an *xref structure*.
In particular,

- *pointers* are encoded be assigning an *xref_id* to the pointed-to *tagged structure* and using it as an *xref* in the pointing *payload*
- *characters* outside the *character encoding* are encoded as *unicode escapes*
- *escapes* that are not *preserved escapes* are removed
- `@` that are not part of *escapes* are encoded as `@@`

All of these steps involve `@`s, and MUST NOT be applied to one another's `@`s;
semantically, they are applied concurrently.

During parsing, there is an inherent ambiguity when there are several contiguous `@` in the payload.
These SHALL be resolved in an earliest-match-first order.

{.example ...} The following *xref structure*'s *payloads* are split into sequences as indicated:

*payload* of *xref structure*       decomposed as
-------------------------------     ----------------------------------------------
"`name@example.com`"                "`name`", "`@`", "`example.com`"
"`name@@example.com`"               "`name`", "`@@`", "`example.com`"
"`name@@@example.com`"              "`name`", "`@@`", "`@`", "`example.com`"
"`name@@@@example.com`"             "`name`", "`@@`", "`@@`", "`example.com`"
"`some@#XYZ@ thing`"                "`some`", "`@#XYZ@ `", "`thing`"
"`some@@#XYZ@ thing`"               "`some`", "`@@`", "`#XYZ`", "`@`", "` thing`"
"`some@@@#XYZ@ thing`"              "`some`", "`@@`", "`@#XYZ@ `", "`thing`"
{/}

### Pointer conversion

If a *tagged structure* is pointed to by the *pointer*-valued *payload* of another *tagged structure*,
the pointe-to *tagged structure*'s corresponding *xref structure*
SHALL be given an **xref_id**, a *string* matching production `XrefID`.

    XrefID  ::= "@" ID "@"
    ID      ::= [0-9A-Z_a-z] [#x20-#x3F#x41-#x7E]*

It MUST NOT be the case that two different *xref structures* be given the same *xref_id*.
*Conformant* implementations MUST NOT attach semantic importance to the contents of an *xref_id*.

It is RECOMMENDED that an *xref_id* be no more than 22 characters (20 characters plus the leading and trailing U+0040)

{.note} [GEDCOM 5.5.1] REQUIRED that *xref_id* be no more than 22 characters. ELF weakens this to a RECOMMENDATION.

Each *record* SHOULD be given an *xref_id*;
each non-*record* *structure* SHOULD NOT;
and each *serialisation metadata* *tagged structure* MUST NOT be given an *xref_id*.

{.ednote} Since a pointed-to structure SHALL have an *xref_id* and a non-*record* MUST NOT,
implicitly a *structure* SHOULD NOT point to a non-*record*.
We should probably either make that explicit
or remove it---the latter may make more sense
as what is pointed to seems to be more a data model decision than a serialisation decision.
However, GEDCOM is fairly clear that pointers to non-*records*
might in the future be enabled with a non-standard *xref_id* syntax.

The *xref structure* that corresponds to a *tagged structure* with a *pointer*-valued *payload*
has, as its *payload*, an **xref**:
a *string* identical to the *xref_id* of the *xref structure* corresponding to
the pointed-to *tagged structure*.

When parsing, if *xref* *payloads* are encountered
that do not correspond to exactly one *xref structure*'s *xref_id*,
that *payload* SHALL be converted to to a *pointer* to a *record* with *tag* "`UNDEF`",
which SHALL NOT have a *payload* nor *substructures*.
It is *recommended* that one such "`UNDEF`" *tagged structure* be inserted
for each distinct *xref*.

{.note} The undefined pointer rule is designed to minimize the information loss
in the event of a bad serialised input.

{.note} This rule does not handle pointer-to-wrong-type; information needed to determine that is not known be serialisation and thus must be handled by the data model instead.

{.ednote} We could also allow pointer-to-nothing or pointer-to-multiple-things to be dropped from the dataset,
and/or provide disambiguation heuristics for pointer-to-multiple-things situations. This draft does not do so as it is not obvious that the benefit is worth the complexity.

### Escape preservation and removal

An **escape** is a substring of a *string*-valued *payload* of either a *tagged structure* or *xref structure*
which matched production `Escape`.
Its **escape type** is the portion of the *escape* that was matched by `EscType`.

    Escape   ::= "@#" EscType EscText "@ "
    EscType  ::= [A-Z]
    EscText  ::= [^#xA#xD#x40]*

If the **escape type** is `U` (U+0055), the *escape* is a *unicode escape* and its handling is discussed in {§unicode-escape};
otherwise, it is handled according to this section.

#### Serialisation

If an *escape* is in the *payload* of an *tagged structure* whose *tag* is an *escape preserving tag*,
and if the escape*'s *escape type* is in the *tag*'s set of *preserved escape types*,
then the *escape* SHALL be preserved unmodified in the corresponding *xref structure*'s *payload*.

{.example} If a "`DATE`" *tagged structure* has *payload* "`ABT @#DJULIAN@ 1540`",
its corresponding *xref structure*'s *payload* is also "`ABT @#DJULIAN@ 1540`".

Otherwise, a modification of the *escape* SHALL be placed in the *xref structure*'s *payload*
which is identical to the original *escape* except that each of the two `@`
SHALL each be replaced with a pair of consecutive U+0040 `@`.

{.example} If a "`NOTE`" *tagged structure* has *payload* "`ABT @#DJULIAN@ 1540`",
its corresponding *xref structure*'s *payload* is "`ABT @@#DJULIAN@@ 1540`".

#### Parsing

If an *escape* is in the *payload* of an *xref structure* whose *tag* is an *escape preserving tag*,
and the escape*'s *escape type* is in the *tag*'s set of *preserved escape types*,
the *escape* SHALL be preserved unmodified in the corresponding *tagged structure*'s *payload*.

{.example} If a "`DATE`" *xref structure* has *payload* "`ABT @#DJULIAN@ 1540`",
its corresponding *tagged structure*'s *payload* is also "`ABT @#DJULIAN@ 1540`".

Otherwise, the *escape* SHALL be omitted from the corresponding *tagged structure*'s *payload*.

{.example} If a "`NOTE`" *xref structure* has *payload* "`ABT @#DJULIAN@ 1540`",
its corresponding *tagged structure*'s *payload* is "`ABT 1540`".

{.note} The decision to remove most *escapes* is motivated in part
because [GEDCOM 5.5.1] does not provide any meaning for an *escape* other than a *date escape*.
This caused some ambiguity in how such escapes were handled, which ELF seeks to remove.
Lacking a semantics to assign these *escapes*, ELF chooses to simply remove them.
Implementations that had assigned semantics to them
were actually imposing non-standard semantics to those payloads
which are more accurately handled by using an alternative *ELF schema* to map those *tags*
to different *structure type identifiers* with those semantics documented.

### Unicode escapes                                          {#unicode-escape}

{.note} [GEDCOM 5.5.1] neither has a notion of *unicode escape*
nor any other feature for achieving the same end.
*Unicode escapes* are designed to provide a means for encoding any *character*
in any *character encoding*
in a way that is maximally backwards-compatible from [GEDCOM 5.5.1].

Any *character* MAY be represented with a **unicode escape** consisting of:

1.  The three characters U+0040, U+0023, and U+0055 (i.e., "`@#U`")
2.  A hexadecimal encoding of the *character*'s *code point*
3.  The two characters U+0040 and U+0020 (i.e., "`@ `")

A *unicode escape* MUST be used for each *character* that cannot be encoded
in the target *character encoding*;
and SHOULD NOT be used otherwise.

{.ednote} Earlier drafts of this specification suggested using `@#U20@` in place of U+0020
when a *line*'s *payload* begins or ends with a space.
Given the inherent ambiguity in the handling of *delimiters* at the ends of a *line*'s *payloads*,
it is not clear if that idea was better than simply clarifying that ambiguity.

{.example} If a *tagged structure*'s *payload* is "`João`" and the *character encoding* is `ASCII`,
the *xref structure*'s *payload* is "`Jo@#UE3@ o`" (or "`Joa@U#303@ o`" if the original used a combining diacritic).

### Encoding `@`s

{.ednote ...} It might be worthwhile to restrict this entire section to non-*escape preserving tags*;
without that we have a (somewhat obscure) problem with the current system:

Consider the *escape-preserving tag* `DATE`.
A serialisation/parsing sequence applied to the *string* "`@@#Dx@@ yz`" yields

1. encoded "`@@#Dx@@ yz`"
2. decoded "`@#Dx@ yz`"
3. encoded "`@#Dx@ yz`" -- not with `@@` because it matches a date escape
{/}

During serialisation, each U+0040 (`@`) that is not part of an *escape*
SHALL be encoded as two consecutive U+0040 (`@@`).

{.example} The *tagged structure* *payload* "`name@example.com`"
is serialised as the *xref structure* *payload* "`name@@example.com`"

During parsing, each consecutive pair of U+0040 (`@@`) SHALL be parsed as a single U+0040 (`@`).

{.example} The *xref structure* *payload* "`name@@example.com`"
is parsed as the *tagged structure* *payload* "`name@example.com`"

During parsing, a lone U+0040 is left unmodified.

{.example} If an *xref structure*'s *payload* is "`name@example.com`",
it is parsed as the *tagged structure* *payload* "`name@example.com`";
that in turn will be re-serialised as "`name@@example.com`".

## Serialisation metadata

The *tagged structures* representing the *dataset* are ordered as follows:

1. A *serialisation metadata* *tagged structure* with *tag* "`HEAD`" and the following *substructures*:
    
    - A *serialisation metadata* *tagged structure* with *tag* "`CHAR`" and *payload* identifying the *character encoding* used; see {§encoding} for details.
    
    - A *serialisation metadata* *tagged structure* with *tag* "`SCHMA`" and no *payload*, with *substructures* encoding the *ELF Schema*; see {§schema} for details.
    
    - Each *tagged structure* with the *superstructure type identifier* `elf:Metadata`,
        in an order consistent with the partial order of *structures* present in the *metadata*.

2. Each *tagged structure* with the *superstructure type identifier* `elf:Document`, in arbitrary order.

3. A *serialisation metadata* *tagged structure* with *tag* "`TRLR`" and no *payload* or *substructures*.
    
### Charcter encoding names                                        {#encoding}

The *character encoding* SHALL be serialised in the "`CHAR`" *tagged
structure*'s *payload* encoding name in the following table:

------    --------------------------------------------------------------------------
Encoding  Description
------    --------------------------------------------------------------------------
`ASCII`   The US version of ASCII defined in [ASCII].

`ANSEL`   The extended Latin character set for bibliographic use defined
          in [ANSEL].

`UNICODE` Either the UTF-16LE or the UTF-16BE encodings of Unicode
          defined in [ISO 10646].

`UTF-8`   The UTF-8 encodings of Unicode defined in [ISO 10646].
------    --------------------------------------------------------------------------

{.note}  This value is read as the *specified character encoding* per
{§specified-enc}.

It is REQUIRED that the encoding used should be able to represent all code points within the *string*;
*unicode escapes* (see {§unicode-escape}) allow this to be achieved for any supported encoding.
It is RECOMMENDED that `UTF-8` be used for all datasets.


### ELF Schema                                                       {#schema}

The **ELF Schema** is a *serialisation metadata* *tagged structure*
with *tag* "`SCHMA`" and no *payload*;
it may contain as *substructures* any number of 
*external schema structures*,
*prefix abbreviation structures*,
*IRI definition structures*,
and
*escape preservation structures*.

If, during parsing, no *ELF Schema* is found, the *default ELF schema* defined in {§default-schema} SHALL be used.

{.ednote} Do we need to make the default dependant on the `GEDC` metadata?

If multiple *ELF Schemas* are found, they SHALL be treated as if all of their *substructures* were part of the same *ELF schema*.

During serialisation exactly one *ELF Schema* SHOULD be included.

#### External schema structure

An **external schema structure** is a *tagged structure*
with an *ELF Schema* as its *superstructure*,
*tag* `SCHMA`, no *substructures*, and an IRI as its *payload*.
The IRI SHOULD use the `http` or `https` scheme
and an HTTP GET request sent to it with an `Accept` header of `application/x-fhiso-elf1-schema`
SHOULD return a *dataset* serialised in accordance with this specification
containing an *ELF Schema* defining the full data model in *structure type descriptions*.

{.ednote} Is `application/x-fhiso-elf1-schema` a MIME-type we are happy with?

{.example ...} When using the [ELF Data Model] version 1.0.0,
the *serialisation schema* could be serialised as

````gedcom
0 HEAD
1 SCHMA
2 SCHMA https://fhiso.org/TR/elf-data-model/v1.0.0
````
{/}

{.example} An HTTP GET request sent to it with an `Accept` header of `application/x-fhiso-elf1-schema` to `https://fhiso.org/TR/elf-data-model/v1.0.0` will return the contents of {§default-schema} or the equivalent.

When retrieving a serialised *dataset* via an HTTP GET request to the IRI of an *external schema structure*,
all contents of that *dataset* except *ELF Schemas* SHALL be ignored.
Additional *external schema structure* SHOULD NOT be present within that *ELF Schema*
and if they are, they MAY be ignored.

{.note} The recommendation against external schema structures inside other external schema structures is designed to simplify parsing.


#### Prefix abbreviation structure                                   {#prefix}

{.ednote} Should this section cite §4.3 of [Basic Concepts] instead of its current text?

A **prefix abbreviation structure** is a *tagged structure*
with an *ELF Schema* as its *superstructure*,
*tag* `PRFX`, and no *substructures*.
Its *payload* consist of two *whitespace*-separated tokens:
the first is a **prefix** and the second is that *prefix*'s corresponding IRI.

To **prefix expand** a *string*, if that *string* begins with a defined *prefix* followed by a colon (U+003A `:`) then replace that *prefix* and colon with the *prefix*'s corresponding IRI.
To **prefix shorten** a *string*, replace it with a *string* that *prefix expansion* would convert to the original *string*.

{.example ...} Given a `PRFX`

    2 PRFX elf https://fhiso.org/elf/

the IRI `https://fhiso.org/elf/ADDRESS` may be abbreviated as `elf:ADDRESS`.
{/}


#### IRI definition structure

An **IRI definition structure** is a *tagged structure*
with an *ELF Schema* as its *superstructure* and *tag* "`IRI`".
Its payload is an IRI,
which MAY be *prefix shortened* during serialisation and MUST be *prefix expanded* during parsing.
The remainder of this section calls this *prefix expanded* payload $I$.
An *IRI definition structure* may have, as *substructures*, any number of
*supertype definition structures* and 
*tag definition structures*.

A **supertype definition structure** is a *tagged structure*
with an *IRI definition structure* as its *superstructure*, *tag* "`ISA`", and no *substructures*.
Its payload is a *structure type identifier*
which MAY be *prefix shortened* during serialisation and MUST be *prefix expanded* during parsing.
The remainder of this section calls this *prefix expanded* payload $I'$.
Each *supertype definition structure* encodes a single *supertype definition*, specifying that $I'$ is a *supertype* of $I$.

{.example ...} That `elf:ParentPointer` is a *supertype* of `elf:PARENT1_POINTER` can be encoded in a *supertype definition structure* as

```gedcom
2 IRI elf:PARENT1_POINTER
3 ISA elf:ParentPointer
```
{/}


A **tag definition structure** is a *tagged structure*
with an *IRI definition structure* as its *superstructure*, *tag* "`TAG`", and no *substructure*.
Its payload is a *whitespace*-separated list of two or more tokens.
The first token $T$ MUST match production `Tag`;
each remaining token $S$ is an IRI,
which MAY be *prefix shortened* during serialisation and MUST be *prefix expanded* during parsing.
Each such $S$ encodes an *tag definition* between *structure type identifier* $I$ and (*tag*, *superstructure type identifier*) pair $(T, S)$.

{.example ...} The following *tag definitions*

- the *structure type identifier* of "`HUSB`" is `elf:Parent1Age` if its *superstructure* is an `elf:FamilyEvent`.
- the *structure type identifier* of "`HUSB`" is `elf:PARENT1_POINTER` if its *superstructure* is an `elf:FAM_RECORD`.
- the *structure type identifier* of "`FORM`" is `elf:MULTIMEDIA_FORMAT` if  its *superstructure* is an `elf:MULTIMEDIA_RECORD`.
- the *structure type identifier* of "`FORM`" is `elf:MULTIMEDIA_FORMAT` if  its *superstructure* is an `elf:MULTIMEDIA_FILE_REFERENCE`.
- the *structure type identifier* of "`EMAIL`" is `elf:ADDRESS_EMAIL` if  its *superstructure* is an `elf:Agent`.
- the *structure type identifier* of "`EMAI`" is `elf:ADDRESS_EMAIL` if  its *superstructure* is an `elf:Agent`.

can be encoded in *tag definition structures* as

```gedcom
0 HEAD
1 SCHMA
2 PRFX elf https://fhiso.org/elf/
2 IRI elf:PARENT1_POINTER
3 TAG HUSB elf:FAM_RECORD
2 IRI elf:Parent1Age
3 TAG HUSB elf:FamilyEvent
2 IRI elf:MULTIMEDIA_FORMAT
3 TAG FORM elf:MULTIMEDIA_FILE_REFERENCE elf:MULTIMEDIA_RECORD
2 IRI elf:ADDRESS_EMAIL
3 TAG EMAIL elf:Agent
3 TAG EMAI elf:Agent
```
{/}


#### Escape-preserving tags

{.note} This entire section, and all of the related functionality, is present to help cope with the idiosyncratic behaviour of date escapes in [GEDCOM 5.5.1]. Escapes in previous editions of GEDCOM were serialisation-specific and if encountered in ELF should generally be ignored, but date escapes are instead part of a microformat. While escape-preserving tags are not elegant, they are adequate to handle this idiosyncrasy.

{.ednote} I wrote the above note from somewhat fuzzy memory. It might be good to review and summarise all the uses of escapes in various GEDCOM releases...

Some *tags* may be defined as **escape-preserving tags**, each with a list of single-character **preserved escape types** each of which MUST match production `UserEscType`.

    UserEscType ::= [A-TV-Z]

An **escape preservation structure** is a *tagged structure*
with an *ELF schema* as its *superstructure*, *tag* "`ESC`", and no *substructures*.
Its payload is composed of two *whitespace*-separated tokens;
the first is the *escape-preserving tag* and the second is a concatenation of all *preserved escape types* of that *tag*;
each *preserved escape type* SHOULD be included in the second token only once.

Two *escape preservation structures* MUST NOT differ only in the set of *preserved escape sequences* they define for a given *tag*.

Escape-preserving tags are included for backwards compatibility,
and MUST NOT be used for new extensions.

{.note} The only known *escape-preserving tag* is "`DATE`", with the *preserved escape type* of "`D`"

{.example ...} The following is the only *escape preservation structure* in ELF 1.0.0:

    0 HEAD
    1 SCHMA
    2 ESC DATE D
{/}

{.example ...} The following defines *tag* `_OLD_EXTENSION` to preserve `G` and `Q` escapes:

    0 HEAD
    1 SCHMA
    2 ESC _OLD_EXTENSION QG

The `ESC` could have equivalently been written as 

    2 ESC _OLD_EXTENSION GQ

or even

    2 ESC _OLD_EXTENSION QGGQQQGGGG

... though that last version is needlessly redundant and verbose and is NOT RECOMMENDED.

Such a definition MUST NOT be used except as backwards compatibility support for an escape-dependent `_OLD_EXTENSION` that predates ELF 1.0.0.
{/}

{.note} This specification uses *tag* and not *structure type* to indicate *escape preservation*
because the main motivating case (`DATE`) applies it to all of the several *structure types* that share that *tag*.




## Tags

### Definitions                                                        {#tags}

A **tag** is a *string* that matches production `Tag`

    Tag ::= [0-9a-zA-Z_]+

A *tag* SHOULD be no more than 15 characters in length.

{.note} [GEDCOM 5.5.1] required tags to be unique within the first 15 characters and no more than 31 characters in length. As memory constraints that motivated those requirements are no longer common, ELF has changed that recommended status instead.

A *tag* SHOULD begin with an underscore (`_`, U+005F) unless it is defined in a FHISO standard.

{.note} [GEDCOM 5.5.1] required all tags other than those it defined to begin with an underscore. ELF's use of *structure type identifiers* largely obviates that need, but it remains *recommended* in ELF 1.0.0 to support legacy systems that have special-case handling for underscore-prefixed *tags*. FHISO is considering removing that recommendation in a subsequent version of ELF.

{.example} "`HEAD`" is a valid *tag*; so is "`_UUID`".
"`23`" and "`UUID`" are also valid, but SHOULD NOT be used as they are not defined in a FHISO standard and do not begin with an underscore.
"`_UNCLE_OF_THE_BRIDE`" is valid, but SHOULD NOT be used as it is 19 *characters* long, more than the 15-*character* recommended maximum length.

*Structure type identifiers* are serialised as *tags*
by utilizing *tag definitions* and *supertypes*, as outlined below.

#### Supertypes

A **supertype definition** specifies one *structure type identifier* that is defined to be a **supertype** of another.

{.example ...} The following are example *supertype definitions* in the *default ELF schema*:

- `elf:FamilyEvent` is a supertype of `elf:MARRIAGE`
- `elf:Event` is a supertype of `elf:FamilyEvent`
- `elf:Agent` is a supertype of `elf:SUBMITTER_RECORD`
- `elf:Record` is a supertype of `elf:SUBMITTER_RECORD`
{/}

An **eventual supertype** of a *structure type identifier* is either

- the *structure type identifier* itself
- an *eventual supertype* of at least one of the *structure type identifier*'s *supertypes*

{.example ...} Continuing the previous example,

- `elf:MARRIAGE`, `elf:FamilyEvent`, and `elf:Event` are *eventual supertypes* of `elf:MARRIAGE`
- `elf:FamilyEvent`, and `elf:Event` are *eventual supertypes* of `elf:FamilyEvent`
- `elf:SUBMITTER_RECORD`, `elf:Agent`, and `elf:Record` are *eventual supertypes* of `elf:SUBMITTER_RECORD`
{/}

If $X$ is an *eventual supertype* of $Y$, then $Y$ is an **eventual subtype** of $X$.

{.example ...} Continuing the previous example,

- `elf:MARRIAGE`, `elf:FamilyEvent`, and `elf:Event` are *eventual subtypes* of `elf:Event`
- `elf:SUBMITTER_RECORD` and `elf:Agent` are *eventual subtypes* of `elf:Agent`
- `elf:SUBMITTER_RECORD` and `elf:Record` are *eventual subtypes* of `elf:Record`
{/}

The *supertype* defined in this specification is only intended to facilitate *tag definitions*
and MUST NOT be taken to indicate any semantic relationship between the structure types they describe.

{.note} It is expected that underlying data models will often define
a semantic supertype-like relationship that mirrors the *supertype definitions* in this document;
see [Elf-DataModel] for an example of what this might look like.
The prohibition against assuming such from the *supertype definitions* alone
provides a clearer separation between data model and serialisation.

{.ednote} We could decide to REQUIRE that any *supertype definition*
has meaning in the underlying data model;
I chose not to do so in this draft as it required discussing semantics,
which this specification otherwise does not need to do.

#### Tag definitions                                        {#tag-definitions}

The correspondence between *tags* and *structure type identifiers* is provided by a set of **tag definitions**.
Each *tag definition* gives the unique *structure type identifier* that a particular *tag* corresponds to if its *superstructure type identifier* is an *eventual subtype* of a given *superstructure type identifier*.

{.example ...} The following are example *tag definitions* in the *default ELF schema*:

- the *structure type identifier* of "`HUSB`" is `elf:Parent1Age` if its *superstructure* is an `elf:FamilyEvent`.
- the *structure type identifier* of "`HUSB`" is `elf:PARENT1_POINTER` if its *superstructure* is an `elf:FAM_RECORD`.
- the *structure type identifier* of "`CAUS`" is `elf:CAUSE_OF_EVENT` if  its *superstructure* is an `elf:Event`.

If a *tagged structure* has *tag* "`CAUS`" and *superstructure type identifier* `elf:MARRIAGE`, it's *structure type identifier* is `elf:CAUSE_OF_EVENT` because of the last of the above *tag definitions*
and because `elf:MARRIAGE` is an *eventual subtype* of `elf:Event`.
{/}

The set of *tag definitions* and *supertype definitions*
MUST NOT provide two (or more) different *structure type identifiers* for any single *structure*.

{.example ...} The following, taken together, are not permitted

- `elf:Agent` is a *supertype* of `elf:SUBMITTER_RECORD`.
- `elf:Record` is a *supertype* of `elf:SUBMITTER_RECORD`.
- `ex:AgentKind` is the *structure type identifier* of an "`_EX_KIND`" if its *superstructure* is an `elf:Agent`.
- `ex:RecordKind` is the *structure type identifier* of an "`_EX_KIND`" if its *superstructure* is an `elf:Record`.

These provide two contradictory *tag definitions*
for the tag "`_EX_KIND`" as a *substructure* of an `elf:SUBMITTER_RECORD`.
{/}

{.example ...} The following, taken together, are permitted

- `elf:Agent` is a *supertype* of `elf:SUBMITTER_RECORD`.
- `elf:Record` is a *supertype* of `elf:SUBMITTER_RECORD`.
- `ex:Kind` is the *structure type identifier* of an "`_EX_KIND`" if its *superstructure* is an `elf:Agent`.
- `ex:Kind` is the *structure type identifier* of an "`_EX_KIND`" if its *superstructure* is an `elf:Record`.

These provide two *tag definitions*
for the tag "`_EX_KIND`" as a *substructure* of an `elf:SUBMITTER_RECORD`,
but because both provide the same *structure type identifier*
they are permitted.
{/}

A *tag definition* is said to apply to a *structure*
if and only if the *structure*'s *structure type identifier* is that of the *tag definition*
and its *superstructure type identifier* is an *eventual subtype* of the *tag definition*'s *superstructure type identifier*.

A *tag definition* is said to apply to a *tagged structure*
if and only if the *tagged structure*'s *tag* is that of the *tag definition*
and its *superstructure type identifier* is an *eventual subtype* of the *tag definition*'s *superstructure type identifier*.


### Serialisation                                         {#tag-serialisation}

During serialisation, a *conformant* application SHALL ensure the presence of sufficient *tag definitions*
that at each *structure* has a defined *tag*,
creating new *tag definitions* if needed to achieve this end.

{.note} The above is not the same as saying that a *tag definition* is created for each *structure type identifier*
because a *structure* with identifier "`elf:Undefined`" or an *undefined tag identifier*
has a defined *tag* without a *tag definition*.

New *tag definitions* may be selected arbitrarily, subject to the limitations on *tags* (see {§tags}) and *tag definitions* (see {§tag-definitions}) and to the following:

- the *tag* MUST NOT be "`CONT`", "`CONC`", "`ERROR`", "`UNDEF`",
    or the *tag* of any *undefined tag identifier* in the *dataset*.

{.note} "`CONT`", "`CONC`", "`ERROR`", and "`UNDEF`" are special *tags*
that can be created at any location within the dataset during deserialisation.

- the *structure type identifier* MUST NOT be any of 
    "`elf:Document`",
    "`elf:Metadata`",
    "`elf:Undefined`",
    or an *undefined tag identifier*.

{.note} "`elf:Undefined`" *structures* are used for errors and are serialised differently than other *structures*.

- the (*tag*, *superstructure type identifier*) pair MUST NOT be any of 
    (`HEAD`, `elf:Document`), 
    (`TRLR`, `elf:Document`), 
    (`CHAR`, `elf:Metadata`), or 
    (`SCHMA`, `elf:Metadata`).

{.note} These tags and contexts are reserved for encoding *serialisation metadata*.

- all *tag definitions* for a given *structure type identifier* SHOULD use the same *tag*

{.note} [GEDCOM 5.5.1] never intentionally violates the above RECOMMENDATION, but via a typo it provides both `EMAI` and `EMAIL` as *tags* for `elf:ADDRESS_EMAIL`. Other aliases exist due to similar mistakes in applications and to multiple extensions inserting the same concept via different *tags*. The ability to handle these aliases is the reason this is a RECOMMENDATION, not a REQUIREMENT, in ELF.

- the *tag definitions* in the default ELF Schema (see {§default-schema}) SHOULD be used in place of any alternative *tag definitions* for the same *structures* in the same contexts.

Each *structure* is converted to a *tagged structure* with the *tag* being

- `UNDEF` if the *structure type identifier* is `elf:Undefined`.

- The *tag* of the *undefined tag identifier* if the *structure type identifier* is an *undefined tag identifier*.

- The *tag* from one of the *tag definitions* that applies to that *structure* otherwise.

    In the event that more than one such *tag* exists, applications SHOULD select the same *tag* in each instance where this choice exists.

{.note} If processing *structures* into *tagged structures* in place,
it may be easiest to perform a postorder traversal of each *structure* hierarchy;
this way the *superstructure* of a *structure* being converted will still have a *structure type identifier*,
not a *tag*,
which will simplify looking up applicable *tag definitions*.

The *substructures* of a *tagged structure* are stored in a sequence, not set.
This ordering of *substructures* of a *tagged structure* MUST maintain the relative order
of those *substructures* that were ordered in the corresponding *structure*.
It is RECOMMENDED that all *substructures* with the same *tag* be grouped together, but doing so is NOT REQUIRED.

{.example ...} Consider the following *structure* hierarchy

- `elf:INDIVIDUAL_RECORD`
    - `elf:BIRTH`
        - `elf:DATE_VALUE` 20 JUN 1881
    - `elf:GRADUATION`s:
        1. `elf:GRADUATION`
            - `elf:AGE_AT_EVENT` 18
        2. `elf:GRADUATION`
            - `elf:AGE_AT_EVENT` 22

This may be converted to any of the following three *tagged structure* hierarchies, though the second is NOT RECOMMENDED:

- `INDI`
    1. `BIRTH`
        - `DATE` 20 JUN 1881
    2. `GRAD`
        - `AGE` 18
    3. `GRAD`
        - `AGE` 22

- `INDI`
    1. `GRAD`
        - `AGE` 18
    2. `BIRTH`
        - `DATE` 20 JUN 1881
    3. `GRAD`
        - `AGE` 22

- `INDI`
    1. `GRAD`
        - `AGE` 18
    2. `GRAD`
        - `AGE` 22
    3. `BIRTH`
        - `DATE` 20 JUN 1881

However, the following puts the *tagged structure* graduations in a different order than the corresponding *structure* graduations and MUST NOT be used:

- `INDI`
    1. `GRAD`
        - `AGE` 22
    2. `GRAD`
        - `AGE` 18
    3. `BIRTH`
        - `DATE` 20 JUN 1881
{/}

### Parsing

When parsing *tagged structures* into *structures*,
add the *structure type identifier* from the the applicable *tag definition*.

If there is no applicable *tag definition*, or if there are multiple applicable *tag definitions*
providing different *structure type identifiers*,
then the *structure type identifier* SHALL be `elf:Undefined` if the *tag* is `UNDEF`, or the *undefined tag identifier* constructed by concatenating `elf:Undefined#` and the *tag* otherwise.

{.note} The special tag "`ERROR`" does not require special handling;
because it never has a *tag definition*,
it becomes the *undefined tag identifier* `elf:Undefined#ERROR`.


## References


### Normative references

[ANSEL]
:   NISO (National Information Standards Organization).
    *ANSI/NISO Z39.47-1993.
    Extended Latin Alphabet Coded Character Set for Bibliographic Use*.
    1993.  (See 
    <http://www.niso.org/apps/group_public/project/details.php?project_id=10>.)
    Standard withdrawn, 2013.

[Basic Concepts]
:   FHISO (Family History Information Standards Organisation).
    *Basic Concepts for Genealogical Standards*.  Public draft.
    (See <https://fhiso.org/TR/basic-concepts>.)

[ASCII]
:   ANSI (American National Standards Institute).
    *ANSI X3.4-1986.
    Coded Character Sets -- 7-Bit American National Standard Code for Information Interchange (7-Bit ASCII)*.
    1986.

[ISO 10646]
:   ISO (International Organization for Standardization).
    *ISO/IEC 10646:2014.
    Information technology &mdash; Universal Coded Character Set (UCS).*
    2014.

[RFC 2119]
:   IETF (Internet Engineering Task Force).
    *RFC 2119:
    Key words for use in RFCs to Indicate Requirement Levels.*
    Scott Bradner, 1997.
    (See <http://tools.ietf.org/html/rfc2119>.)

[XML]
:   W3C (World Wide Web Consortium).
    *Extensible Markup Language (XML) 1.1*, 2nd edition.
    Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, and John Cowan eds., 2006.
    W3C Recommendation.
    (See <https://www.w3.org/TR/xml11/>.)

### Other references

[GEDCOM 5.5.1]
:   The Church of Jesus Christ of Latter-day Saints.
    *The GEDCOM Standard*, draft release 5.5.1.  2 Oct 1999.

[GEDCOM 5.5]
:   The Church of Jesus Christ of Latter-day Saints.
    *The GEDCOM Standard*, release 5.5.  1996.

[XML Names]
:   W3 (World Wide Web Consortium).
    *Namespaces in XML 1.1*, 2nd edition.
    Tim Bray, Dave Hollander, Andrew Layman and Richard Tobin, eds., 2006.
    W3C Recommendation.
    See <https://www.w3.org/TR/xml-names11/>.

[ELF Data Model]
:   FHISO (Family History Information Standards Organisation)
    *Extended Legacy Format (ELF): Data Model.*



## Appendix A: Default Schema                                  {#default-schema}

The following is a minimal ELF file with the default *ELF Schema*,
which includes all *tag definitions* and *supertype definitions* listed in [Elf-DataModel].

{#include schema.ged}

\vfill

----
Copyright © 2017–19, [Family History Information Standards Organisation,
Inc](https://fhiso.org/).
The text of this standard is available under the
[Creative Commons Attribution 4.0 International
License](https://creativecommons.org/licenses/by/4.0/).

