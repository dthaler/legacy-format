---
title: "Extended Legacy Format (ELF)"
subtitle: Serialisation Format
date: 31 October 2017
numbersections: true
...
# Extended Legacy Format (ELF):<br/> Serialisation Format

{.ednote ...} This is an **exploratory draft** of the serialisation
format for FHISO's proposed suite of Extended Legacy Format (ELF)
standards.  This document is not endorsed by the FHISO membership, and
may be updated, replaced or obsoleted by other documents at any time.

Comments on this draft should be directed to the
[tsc-public@fhiso.org](http://tech.fhiso.org/tsc-public) mailing list.
{/}

FHISO's **Extended Legacy Format** (or **ELF**) is a hierarchical
serialisation format and genealogical data model that is fully
compatible with GEDCOM, but with the addition of a structured
extensibility mechanism.  It also clarifies some ambiguities that were
present in GEDCOM and documents best current practice. 

The **GEDCOM** file format developed by The Church of Jesus Christ of
Latter-day Saints is the *de facto* standard for the exchange of
genealogical data between applications and data providers.  Its most
recent version is GEDCOM 5.5.1 which was produced in 1999, but despite
many technological advances since then, GEDCOM has remained unchanged.

{.note} Strictly, [GEDCOM 5.5] was the last version to be publicly
released back in 1996.  However a draft dated 2 October 1999 of a
proposed [GEDCOM 5.5.1] was made public; it is generally considered to
have the status of a standard and has been widely implemented as such.

FHISO are undertaking a program of work to produce a modernised yet
backward-compatible reformulation of GEDCOM under the name ELF, the new
name having been chosen to avoid confusion with any other updates or
extensions to GEDCOM, or any future use of the term by The Church of
Jesus Christ of Latter-day Saints.  This document is one of two that
form the initial suite of ELF standards:

* **ELF: Serialisation Format**.  This standard defines a
  general-purpose serialisation format based on the GEDCOM data format
  which encodes a *dataset* as a hierarchical series of *lines*, and
  provides low-level facilities such as escaping and extensibility
  mechanisms.

* **ELF: Data Model**.  This standard defines a data model based on the
  lineage-linked GEDCOM form, reformulated in terms of the
  serialisation model described in this document.  It is not a major
  update to the GEDCOM data model, but rather a basis for future
  extension.

## Conventions used

Where this standard gives a specific technical meaning to a word or
phrase, that word or phrase is formatted in bold text in its initial
definition, and in italics when used elsewhere.
The key words **must**, **must not**, **required**, **shall**, 
**shall not**, **should**, **should not**, **recommended**,
**not recommended**, **may** and **optional** in this standard are to be
interpreted as described in
&#x5B;[RFC 2119](https://tools.ietf.org/html/rfc2119)].

An application is **conformant** with this standard if and only if it
obeys all the requirements and prohibitions contained in this
document, as indicated by use of the words *must*, *must not*,
*required*, *shall* and *shall not*, and the relevant parts of its
normative references.  Standards referencing this standard *must not*
loosen any of the requirements and prohibitions made by this standard,
nor place additional requirements or prohibitions on the constructs
defined herein.  

{.note} Derived standards are not allowed to add or remove requirements
or prohibitions on the facilities defined herein so as to preserve
interoperability between applications.  Data generated by one
*conformant* application must always be acceptable to another
*conformant* application, regardless of what additional standards each
may conform to. 

If a *conformant* application encounters data that does not conform to
this standard, it *may* issue a warning or error message, and *may*
terminate processing of the document or data fragment.

This standard depends on FHISO's **Basic Concepts for Genealogical
Standards** standard.  To be *conformant* with this standard, an
application *must* also be *conformant* with [Basic Concepts].  Concepts
defined in that standard are used here without further definition.

{.note} In particular, precise meaning of *string*, *character*,
*whitespace* and *term* are given in [Basic Concepts].

Certain facilities in this standard are described as **deprecated**,
which is a warning that they may be removed from a future version of
this standard.  This has no affect on whether a *conformant* application
must implement the facility: they may be *required*, *recommended* or
*optional* as described in this standard.  

Indented text in grey or coloured boxes does not form a normative part
of this standard, and is labelled as either an example or a note.  

{.ednote} Editorial notes, such as this, are used to record outstanding
issues, or points where there is not yet consensus; they will be
resolved and removed for the final standard.  Examples and notes will be
retained in the standard.

The grammar given here uses the form of EBNF notation defined in §6 of
&#x5B;[XML](https://www.w3.org/TR/xml11/)], except that no significance is
attached to the capitalisation of grammar symbols.  *Conforming*
applications *must not* generate data not conforming to the syntax given
here, but non-conforming syntax *may* be accepted and processed by a
*conforming* application in an implementation-defined manner.

## Overview of ELF

The ELF serialisation format is a structured, line-based text format for
encoding data in a form that is both machine-readable and
human-readable.  An ELF document consists of a sequence *structures*, 
which are recursive data structures that allow arbitrary information to
be represented in a hierarchical manner.  Each *structure* *may* have a
*payload*, which is either a *string* or a *pointer* to another
structure, and a list of child *structures* known as *substructures*.

{.note} The expressiveness of ELF is similar to that of XML.  ELF's
*structures* serve the same role as elements in XML, and nest similarly.

Each *structure* is encoded as sequence of *lines*.  The type of
*structure* is encoded on the first *line*, together with its
*payload*; *substructures* are encoded in order on subsequent
*lines*.  Each *line* is prefixed by a *level*, which is a number that
states how many levels of *substructures* deep the current *structure*
is nested.

{.example ...}
    0 HEAD
    1 GEDC
    2 VERS 5.5.1
    2 ELF 1.0.0
    2 FORM LINEAGE-LINKED
    1 CHAR UTF-8
    0 INDI
    1 NAME Charlemagne
    0 TRLR

The ELF document has three *lines* with *level* `0` which mark the start
of the three top-level *structures*.  These *structures* have,
respectively, two, one and zero *substructures*, which are denoted by
the *lines* with *level* `1`.   The *structure* represented by the
`CHAR` *line* is a *substructure* of the *structure* that begins on the
`HEAD` *line* because there is no intervening *line* with *level* one
less than `1` (i.e. `0`); the *structure* represented by the `NAME`
*line* is a *substructure* of the `INDI` *structure* as that is the
preceding *line* with a *level* `0`.
{/}

The ELF serialisation format is a general purpose format that can be
used to represent arbitrary data, depending on the particular types of 
*structures* that are used.  A particular set of *structures*, together
with their meanings and restrictions on how they are to be used, is
called a **data model**.  The ELF serialisation format is designed to be
useable with various *data models*, however it is anticipated that most
files using the ELF serialisation format will use the data model
described in [ELF Data Model], which is based on and compatible with
GEDCOM's lineage-linked form.

## Parsing lines

Applications parsing an ELF file *shall* follow the steps outlined in
this section.  *Conformant* applications *may* deviate from this
processing sequence only if it has no effect on the observable behaviour
of the application.

{.note} In particular, this processing sequence implies multiple passes
over the input document. Applications *may* merge the steps in such a
way as to reduce the number of passes needed providing the behaviour is
the same as specified here.

In order to parse an ELF document, an application *shall* first convert
the raw stream of bytes which it has read from the network or disk into
a sequence of *strings* called *lines*.  The way in which a raw stream
of bytes, as read from the network or disk, is mapped to a *string* is
called the **character encoding** of the document.  Determining it is a
two-stage process, with the first stage is to attempt to detect a
*character encoding* using the process given in §3.1.

If no *character encoding* was detected, the *character encoding* is
assumed to be a 7 or 8-bit encoding that is sufficiently compatible with
ASCII that an application can locate and read a `CHAR` *structure* to
determine the actual *character encoding*.  This *shall* be done using
the process described in §3.2.  If no such `CHAR` *structure* is found,
the *character encoding* *shall* default to ANSEL.  Considerations for
reading specific *character encodings* can be found in §3.3.

### Detecting a character encoding

{.note} For applications that opt not to support UTF-16, the process
described in this section can be as simple as skipping over a UTF-8
byte-order mark, and determining the *character encoding* to be UTF-8 if
one was present.

If a character encoding is specified via any supported external means,
such as an HTTP `Content-Type` header, this *should* be used as the
*character encoding*.

{.example ...}  Suppose the ELF file was download using HTTP and the
response included this header:

    Content-Type: application/x-gedcom; charset=UTF-8

If an application has access to this `Content-Type` header and is able
to understand it, it *should* determine the *character encoding* to be
UTF-8.
{/}

Otherwise, if the document begins with a byte-order mark (U+FEFF)
encoded in UTF-8, or in UTF-16 of either endianness if the application
supports the *optional* UTF-16 encoding, this encoding *shall* be the
*character encoding*.  The byte-order mark *must* be removed from the
data stream before further processing.

Otherwise, if the document begins with any ASCII *character* (U+0001 to
U+007F) encoded in UTF-16 of either endianness, and if the application
supports the *optional* UTF-16 encoding, this encoding *shall* be the
*character encoding*.

{.note}  The digit `0` is tested for because an ELF file *must* begin
with the *line* "`0 HEAD`"; a space *character* or horizontal tab are
also accommodated to permit more flexible use of *whitespace* in the
file.

Otherwise, applications *may* try to detect other character encodings by
examining the octet stream, but it is *not recommended* that they do so.

{.note}  One situation where it may be necessary to attempt to detect
another encoding is if the application needs to support (as an
extension) a character encoding like UTF-32 which is not compatible with
ASCII.

Otherwise, there is no *character encoding* is detected.

{.note ...} These cases can be summarised as follows, where `xx` denotes
an arbitrary byte:

----------------  -------------------------------------------------
Initial bytes     Character encoding
----------------  -------------------------------------------------
EF BB BF          UTF-8 (with byte-order mark)

FF FE             UTF-16, little endian (with byte-order mark) 

FE FF             UTF-16, big endian (with byte-order mark)

xx 00             UTF-16, little endian (without byte-order mark)

00 xx             UTF-16, big endian (without byte-order mark)

Otherwise         None
----------------  -------------------------------------------------
{/}

### Scanning for a character encoding

If no *character encoding* was detected by the process given in §3.1,
the *character encoding* *must* be a 7 or 8-bit *character encoding*
(possibly a multibyte encoding like UTF-8), that is sufficiently
compatible with ASCII that the `CHAR` *structure* can be read.

{.note}  This standard does not define what constitutes sufficient
compatibility with ASCII.  The only 7 or 8-bit *character encodings*
defined in this standard are ASCII, ANSEL and UTF-8 which encode ASCII
*characters* identically to ASCII.  However an application *may* support
*character encodings* that have small differences from ASCII, such as
the Japanese Shift-JIS *character encoding* which uses the bytes 5C and
7E to encode the yen currency sign and overbar where ASCII has a
backslash and tilde.

The application *shall* scan the initial section of the byte stream
searching for a byte sequence that corresponds to a `CHAR`
*substructure* in a `HEAD` *record*.  Scanning proceeds *line* by
*line*, by assuming the file is encoded in ASCII; however, while doing
so, the application *must* accept 8-bit characters outside the range of
ASCII without issuing an error.

{.note} Equivalently, an application *may* assume a *character
encoding* of ISO-8859-1 for the purpose of scanning for the actual
*character encoding*.

Each *line* is read by reading bytes from the file and appending them to
the *line* until a byte is encountered that is the ASCII encoding of a
line feed (U+000A) or carriage return (U+000D), or the end of the file
is reached.  This byte is not not appended to the *line*.  Next, any
leading or trailing sequences of bytes that are ASCII encodings of space
*characters* (U+0020) or horizontal tabs (U+0009) are removed from the
*line*.  If this results in an empty *line*, another *line* is read
until either a non-empty *line* is read or the end of the file is
reached.

For the purpose of scanning for a *character encoding*, all *lines*
*shall* be *whitespace normalised*, and all lowercase ASCII letters
(U+0061 to U+007A) converted to the corresponding uppercase letter
(U+0041 to U+005A).  

Once normalised in this manner, the first non-empty *line* of
the file *must* be "`0 HEAD`"; if it is not, the application *should*
issue an error and stop reading the file.  After the first non-empty
*line*, if the application encounters another normalised *line* starting
with a `0` digit (U+0030) followed by a space *character* (U+0020), the
application *shall* cease scanning for a *character encoding* and
determine the *character encoding* to be ANSEL.

{.note}  ANSEL is the default *character encoding* for compatibility
with GEDCOM, despite being *deprecated* in ELF.

If the end of the file is reached while scanning for the *character
encoding*, the application should issue and error and stop reading the
file.

{.note}  A valid ELF file must end with a "`0 TRLR`" *line* which will
cause scanning to cease before the end of file is reached, even if the
file contains no other *record*.

If the application encounters a *line* beginning with "`1 CHAR`"
followed by a space *character* (U+0020) while scanning for the
*character encoding*, the remainder of the *line* *shall* be used to
determine the *character encoding* as follows, and then cease scanning
for a *character encoding*.

If the remainder of the *line* is "`ASCII`", "`ANSEL`" or "`UTF-8`" the
application *shall* determine the *character encoding* to be ASCII,
ANSEL or UTF-8, respectively.  *Conformant* applications are *required*
to support these three *character encodings*.

Otherwise, if the remainder of the *line* is "`UNICODE`", the
application *should* issue an error and stop reading the file.

{.note} The value `UNICODE` represents the UTF-16 encoding, and if the
file is genuinely in UTF-16, it will have been detected as such in §3.1
and the file will not be scanned for a *character encoding*.  The value
`UNICODE` is also ambiguous as it does not specify which endianness of
UTF-16 is to be used: this is detected by the process given in §3.1.

Otherwise the application *shall* determine the *character encoding* in
an implementation defined way.  In doing so, it *may* read one further
*line* and if it begins with "`2 VERS `", the application *may* use the
remainder of that *line* to provide further detail on *character
encoding*.  If the application is unable to determine the *character
encoding*, or if the *character encoding* is one which the application
does not support, it should issue an error and stop reading the file.

{.note}  Applications are encouraged to support other *character
encodings* where feasible, but most of the other values found on `CHAR`
*lines* are inherently ambiguous.  One of the more common is "`ANSI`"
which refers to any of several Windows code pages, most frequently
CP-1252 which was the Windows default code page for English and several
other Western European languages; however, other code pages exist, and
an application localised for, say, Hungarian might have included a  
"`1 CHAR ANSI`" *line* while encoding the file in CP-1250.  In principle
a `VERS` *line* could contain information to specify the particular code
page used, but in practice this is rare.

### Character encodings

Support for reading the ASCII, ANSEL and UTF-8 *character encodings* is
*required* by this standard.  Applications may *optionally* support the
UTF-16 *character encoding* in either or both the big and little endian
forms.   The use of any of these *character encodings* other than UTF-8
is *deprecated*.

The UTF-8 and UTF-16 *character encodings* are the Unicode encoding
forms defined in §2.5 of [ISO 10646], and the specifics of the big and
little endian forms of UTF-16 are defined in §2.6 of [ISO 10646].  

{.note}  As these are encodings of Unicode, they naturally decode into a
sequence of Unicode *characters* without requiring conversion between
character sets. 

The *character encoding* referred to as ASCII in this standard is the US
version of ASCII which, for the purpose of this standard, is defined as
the subset of UTF-8 which uses only Unicode characters U+0001 to U+007F.

{.note} The US ASCII *character encoding* is nominally defined in
[ASCII], but this standard defines it in terms of [ISO 10646].  This is
partly to avoid uncertainty over which of several incompatible
definitions of ASCII is meant, partly because the Unicode standard is
much more readily available than the ASCII one, and partly because ASCII
allows certain punctuation marks a be used as combining diacritics when
they follow the backspace *character* (U+0008).  This cannot be used
legally in GEDCOM as the backspace *character* is not peritted.  Unicode
provides separate combining diacritics and does not allow this use.

ANSEL refers to the Extended Latin Alphabet Coded Character Set for
Bibliographic Use defined in [ANSEL].  If an ELF file is determined to
used the ANSEL *character encoding* it *must* be converted into a
sequence of Unicode *characters* before it can be processed further.
This is discussed in §3.3.1.  

If other *character encodings* are supported, they too must be converted
into a sequence of Unicode *characters* for further processing.

{.note}  This standard makes no recommendation on how applications
should represent sequences of Unicode *characters* internally, and the
UTF-8, UTF-16 and UTF-32 *character encodings* each have advantages.

{.ednote}  This standard currently makes no distinction between a
*character set* and a *character encoding*, but arguably it would be
cleaner to make this distinction.  Then UTF-16 and UTF-8 are different
*character encodings* of the same Unicode *character set*, and ASCII may
be regarded as such too for our purpose; but ANSEL is a different
*character set* and required conversion to Unicode.  [ISO 10646] makes
a further distinction between *encoding forms* like UTF-8 and UTF-16, and
*encoding schemes* like UTF-16BE and UTF-16LE.

#### Converting ANSEL to Unicoed

{.ednote} Add material from `ansel-to-unicode.md`.

### Reading lines

Once the *character encoding* has been determined and the ELF file,
excluding any byte-order mark that was removed in §3.1, has been
converted to a sequence of Unicode *characters*, an application
reading an ELF file *shall* read *lines* from the beginning of the file
as described in this section.

{.note ...}  In practice it is expected that applications will typically
decode the *character encoding* while reading *lines*, rather than as a
separate step.

Applications that do not wish to make multiple passes over the `HEAD`
*record*, first when scanning for a *character encoding* per §3.2 and
again when reading *lines*, *may* store the lines read during scanning
immediately before they are *whitespace normalised* and converted to
uppercase.  These scanned *lines* will still be byte sequences that need
converting to the actual *character encoding* per §3.3, but otherwise
the rules for reading lines in §3.2 are the same as those here.
{/}

Each *line* is read by reading *characters* from the file and appending
them to the *line* until a line feed (U+000A) or carriage return
(U+000D) is encountered, or the end of the file is reached.  This
*character* is not not appended to the *line*.  Next, any leading or
trailing sequences of space *characters* (U+0020) or horizontal tabs
(U+0009) are removed from the *line*.  If this results in an empty
*line*, another *line* is read until either a non-empty *line* is read
or the end of the file is reached.

{.note ...}  Even though this process for reading *lines* only
explicitly handles the form of line endings used on Unix, Linux and
modern Mac OS (U+000A), and the traditional Mac OS form (U+000D),
Windows line endings (U+000D U+000A) are handled implicitly as a
traditional Mac OS *line* followed by an empty Unix *line* which is
discarded.  It is equivalent to splitting lines using a line terminator
that matches the production:

    Terminator  ::=  ((#x20 | #x9)* (#xD | #xA))+ (#x20 | #x9)*

This is more flexible that the equivalent production in GEDCOM,
however the GEDCOM specification notes that some applications indent
lines with *whitespace* and possibly include blank *lines* between
*records*.  Neither of these are permitted by the GEDCOM grammar, but
may parsers accept them;  this standard permits these constructs, though
their use is *not recommended*.
{/}

## Structures and pseudo-structures

A dataset consists of **structures**; as part of encoding as a *string*, these are augmented by a set of **pseudo-structures**, *structure*-like constructs that are not part of the data model.

### Structures   {#Structure}

Every *structure* consists of the following components:

Structure Type Identifier
:   Every *structure* has a *structure type identifier*, which is
    *shall* be a *term*.

Identifier
:   A *string* uniquely identifying this *structure* within this dataset.
    If present, the identifier MUST match the production ID:
        
        ID  ::= [0-9A-Z_a-z] [#x20-#x3F#x41-#x7E]*

Payload
:   If present, a *payload* is either a pointer to a *structure* within the dataset or a *string*.
    Each pointed-to *structure* MUST have a unique identifier within the dataset.

Substructures
:   *Structures* may contain zero or more other *structures*,
    which are called the *structure*'s **substructures**.

    The order of substructures that have distinct *structure type identifiers* is not significant,
    but the order of substructures with the same *structure type identifier* must be preserved.

Every dataset contains exactly one *structure* called the **head**
and any number of *structures* called **records**.
Within a serialisation, the *head* is always the first *structure*;
within a dataset, the *head* is always identified as such.
Neither the *head* nor the *records* are substructures of other *structures*.

The order of *records* is not significant and may be changed upon serialisation.
However, for backwards compatibility it is RECOMMENDED that
if there exits a *record* with the *structure type identifier* `http://terms.fhiso.org/elf/SUBN`, that *record* be placed before any other *record* within the serialisation.

{.ednote} GEDCOM REQUIRED `SUBN` to be immediately after the `HEAD` if present; the author of this specification is aware of no GEDCOM parser that fails to parse files violating that constraint, hence the RECOMMENDED rather than REQUIRED status.


### Pseudo-structures

A **pseudo-structure** consists of the following components:

Tag
:   Every *pseudo-structure* has a *tag*, a four-character *string* specified elsewhere in this document.

Payload
:   If present, a *string*.

Substructures
:   *Pseudo-structures* may contain zero or more  *Structures*,
    which are called the *pseudo-structure*'s **substructures**.

This specification documents six specific *pseudo-structures*:

-   `[CONT]` and `[CONC]` are used to encode multi-line (`[CONT]`) or long (`[CONC]`) *payloads*.
    As such, they may appear as pseudo-substructures of any *structure* with a *string* *payload*.
    The order of `[CONT]` and `[CONC]` *pseudo-structures* MUST be preserved.
    Any `[CONT]` and `[CONC]` pseudo-substructures MUST appear 
    before any other substructures or pseudo-substructures
    within any serialisation.

-   `[PRFX]` and `[DEFN]` are used to encode the [IRI Dictionary].
    They appear only as pseudo-substructures of the *head* *structure*.

-   `[CHAR]` is used to specify the character encoding of the dateaset's serialization.
    It appears only as pseudo-substructures of the *head* *structure*.

-   `[TRLR]` is always the last element of a serialised dataset.




## Encoding/Decoding a dataset

### Encoding a dataset

To encode a *dataset*,

1.  Determine a character encoding.
    The character encoding MUST be taken from the following options:

    ------    --------------------------------------------------------------------------
    Encoding  Description
    ------    --------------------------------------------------------------------------
    `ASCII`   The US version of ASCII defined in [ASCII].

    `ANSEL`   The extended Latin character set for bibliographic use defined
              in [ANSEL].

    `UNICODE` Either the UTF-16LE or the UTF-16BE encodings of Unicode
              defined in [ISO 10646].

    `UTF-8`   The UTF-8 encodings of Unicode defined in [ISO 10646].
    ------    --------------------------------------------------------------------------

    The character encoding selected
    MUST be able to encode all code points in all payloads in every *structure* within the dataset.
    It is RECOMMENDED that UTF-8 be used for all datasets.
    
1.  Add a `[CHAR]` *pseudo-structure* to the *head* with the encoding as its *payload*.

1.  Create an [*IRI dictionary*](#IRI-dictionary) that can map all *structure type identifiers* in the data into *tag*s.

1.  Add `[PRFX]` and `[DEFN]` *pseudo-structures* to the *head* to [encode the *IRI dictionary*](#IRI)

1.  Create a *string* by

    1.  Converting the *head* [into a *string*](#struct-string).
    1.  Appending to that *string* the *string* created by converting each *record* [into a *string*](#struct-string).
    1.  Appending the [*string* representation](#struct-string) of a trailer *pseudo-structure* (*level* 0, *tag* `TRLR`, no *payload*).

    If the encoding is either `UNICODE` or `UTF-8`,
    it is RECOMMENDED that the byte-order mark U+FEFF be prepended to the *string*.

1.  [Convert the *string* into a sequence of octets](#string2octet).

### Decoding a dataset

To decode a *dataset*,

1.  [Convert the sequence of octets into a *string*](#octet2string).

1.  Inspect the portion of the *string* that encodes the *head*,
    ignoring all lines other than those encoding `[PRFX]` and `[DEFN]` *pseudo-structures*.
    Use those `[PRFX]` and `[DEFN]` *pseudo-structures* to populate an [*IRI dictionary*](#IRI-dictionary).

1.  [Convert each line into a *structure* or *pseudo-structure*](#struct-string).
    The first *structure* is the dataset's *head*;
    each remaining *structure* is either one of the dataset's *records*
    or a substructure of another strucure or *pseudo-structure*.
    
    *Pseudo-structures* provide metadata or modify other *structures*
    and are not part of from the resulting dataset.
    Substructures of *pseudo-structures* have no meaning and SHALL be ignored.

{.ednote} Substrutures of pseudo-structures are *ignored* rather than *forbidden* because GEDCOM listed the `CHAR` pseudo-structure as having an optional `VERS` substructure with no defined semantics and because non-conformant GEDCOM producers might have placed substructures under any line.


## Structure to/from String  {#struct-string}

Each *structure* is mapped to a *string* through the intermediate form of a *line*.

### Lines     {#Line}

A **line** is a *string* that matches the following `Line` production.

    Line  ::=  Delim? Number Delim (XRef Delim)? Tag (Delim PLine)? Delim? LB

The components of a *line* are each separated by a *whitespace*
**delimiter**, defined as one or more space *characters* or
tabs.  It matches the production `Delim`:

    Delim  ::=  (#x20 | #x9)+

When creating a *line*, a *conformant* application *shall* use a single
space *character* (U+0020) for each required *delimiter* and *shall not*
use a *delimiter* where it is *optional* in grammar.

{.note} This requires an application to be permissive about where
*whitespace* is permitted when reading a *line*, but conservative in
where *whitespace* is placed when writing a *line*.  This ensures
maximum compatibility with existing applications, regardless of whether
they strictly conform to the [GEDCOM 5.5.1] standard.

Each *line* ends with a **line break** which is defined to be a carriage
return, a line feed, or a carriage return followed by a line feed.  It
matches the production `LB`:

    LB  ::=  #xD #xA? | #xA

{.note} This includes the form of line breaks used on Windows (U+000D
U+000A), the form used on Unix, Linux and modern Mac OS (U+000A), and
the traditional Mac OS form (U+000D).  However this standard makes no
requirement that an application running on one of these operating
systems should use the native form of line break.

Applications *should* use the same form of *line break* throughout any
given serialisation.

The non-*whitespace* components of a *line* have the following forms: 


1.  The **level**: a base-ten integer matching the production `Number`:
    
        Number  ::= "0" | [1-9] [0-9]*

2.  An *optional* **xref_id**: an identifier surrounded by at-signs, matching the production `XRef`:
    
        XRef  ::= "@" [a-zA-Z0-9_] [^#x40#xA#xD]* "@"

3.  A **tag**: a *string* (generally [mapping to a IRI](#IRIs-and-Tags)) matching the production `Tag`:
    
        Tag  ::= [0-9a-zA-Z_]+

4.  An *optional* **payload line**: a *string* matching the production `PLine`:
    
        PLine   ::= PItem ((PItem | #x20 | #x90)* PItem)? | XRef
        PItem   ::= [^#x40#x20#x9#xA#xD] | "@@" | Escape
        Escape  ::= "@#" [^#x40#xA#xD]* "@"

{.note}  The `PLine` production appears quite complicated when written
in EBNF.  In fact, it allows an arbitrary *string* except that it *must
not* begin or end with *whitespace*, and that any `@` sign must either
be doubled (to represent a literal `@`) or be part of an escape
sequence.  Writing the grammar like this avoides ambiguity as to whether
*whitespace* is part of the *payload line* or the *delimiter*.

### Structure to/from line(s)

Each [*Structure* or *pseudo-structure*](#Structure) is encoded as one or more lines as follows:

1.  The *level* of the *head*, of each *record*, and of the `[TRLR]` pseudo-structure is `0`.
    The *level* of a substructure is 1 greater than the *level* of its superstructure.
    
    For example,
    a substructure of the *head* has level `1`;
    a substructure of a substructure of the *head* has level `2`.

2.  If the *structure* has an *identifier*, that identifier surrounded by U+0040 (`@`) is the *xref_id*; otherwise, there is no *xref_id*.
    
    For example, the *xref_id* of a *structure* with *identifier* "S23" is `@S23@`.

3.  The *tag* is a sting which will map to the *structure*'s *structure type identifier*
    using the [IRI dictionary](#tag2iri).

    For example, the *tag* of an `http://terms.fhiso.org/elf/ADDR` *structure* is `ADDR`.

4.  The *payload line* has several possibilities:
    
    -   If the *payload* of the *structure* is None, there is no *payload line*.
    
    -   If the *payload* of the *structure* is a pointer, the *payload line* is the *identifier* of the pointed-to *structure* surrounded by U+0040 (`@`).
        
        For example, if the *payload* of a .`INDI`.`ALIA` points to an `INDI` with identifier "I45", the *payload line* is `@I45@`.
    
    -   If the *payload* of the *structure* is a *string*, the *payload line* is a prefix of the *payload* determined and encoded as described in [Payload String Encoding].

    If there is no *payload line* but the *structure* expects a *string*-valued *payload*, the *payload* is a string of length 0.
    If there is a *payload line* of length 0 but the *structure* expects no *payload*, there is no *payload*.

{.ednote} The length-0 passage above deals with the case were "`1 CONT`" should be parsed as a blank line, not as an error because it lacks the required *payload line*.

The [line(s)](#Line) encoding a *structure* is followed immediately by lines encoding each of its substructures and pseudo-substructures.
The order of substructures of different *structure type identifier*s is arbitrary, but the order of substructures with the same *structure type identifier* MUST be preserved.
It is RECOMMENDED that all substructures with the same *structure type identifier* be placed adjacent to one another.

{.example ...}
The following are all equivalent:

````gedcom
0 @jane@ SUBM
1 NAME Jane Doe
1 LANG Gujarati
1 LANG English
````

````gedcom
0 @jane@ SUBM
1 LANG Gujarati
1 NAME Jane Doe
1 LANG English
````

````gedcom
0 @jane@ SUBM
1 LANG Gujarati
1 LANG English
1 NAME Jane Doe
````

... though the second ordering places a `NAME` between two `LANG`s and is thus not recommended.
The following is *not* equivalent to any of the above:

````gedcom
0 @jane@ SUBM
1 NAME Jane Doe
1 LANG English
1 LANG Gujarati
````
{/}

{.example ...} It is the *structure type identifier* that determines if order must be preserved;
thus, the order of the two notes in the following must be preserved
even though one has a pointer as its *payload* and the other has a string:

````gedcom
1 NAME Jno. /Banks/
2 NOTE @N34@
2 NOTE This is probably an abbreviation for John
````
{/}


### Payload String Encoding

A *string*-valued *payload* is encoded into a *payload line* as follows:

1.  The *payload* is split on all *line break*s,
    and may also be split between any two non-*whitespace* characters
    that are not part of a substring matching the `Escape` production.

        Escape  ::= "@#" [^#x40#xA#xD]* "@"
    
    The portion before the first split point
    (or the entire *payload* if there are no splits)
    is encoded as the *payload line* of the *structure*'s line;
    the remaining portions are encoded in order
    as the *payload line*s of pseudo-substructures of the *structure*:
    a `[CONT]` *pseudo-structure* if the split point was a *line break*
    and a `[CONC]` *pseudo-structure* otherwise.

    It is RECOMMENDED that all payloads be split as needed
    to ensure that no *line* containing a portion of the *payload*
    exceeds 255 characters in length.

1.  Each U+0040 `@` in a *payload*
    which is not part of a substring that matches production `Escape`
    is replaced by two adjacent U+0040s `@@`.

1.  Each *delimiter* character that begins or ends a *payload*
    MUST be replaced by an escape sequence consisting of:

    1.  The three characters U+0040, U+0023, and U+0055 (i.e., "`@#U`")
    1.  A hexadecimal encoding of the code point of the *delimiter* character (i.e., either `20` or `9`)
    1.  The two characters U+0040 and U+0020 (i.e., "`@ `")

{.note} Delimiter escaping will never be used with any of the
*structures* documented in [ELF Data Model]
because all *payload*s there are either *whitespace normalised* or *line break normalised*.
Delimiter escaping is included in this specification to permit extensions where leading and trailing whitespace are significant.

{.ednote} The above leaves out the ability to split next to a space or tab, meaning *strings* of hundreds of spaces or tabs will of necessity exceed the 255-character limit.

{.example ...} If the payload of a .`HEAD`.`NOTE` would be represented in a C-like language as `"Example:\nmulti-line notes  \n supported."`, the `NOTE` could be encoded as

````gedcom
1 NOTE Example:
2 CONT multi-line notes
2 CONT supported.
````

or as

````gedcom
1 NOTE Example:
2 CONT mult
2 CONC i-lin
2 CONC e notes
2 CONT supported.
````

but *not* as

````gedcom
1 NOTE Example:
2 CONT multi-line
2 CONC notes
2 CONT supported.
````
{/}


### Payload String Decoding

A the *payload line*s
of a *structure*'s line
and all its `[CONT]` and `[CONC]` pseudo-substructure lines
are combined to create the *structure*'s *payload* as follows:

1.  Each adjacent pair of U+0040 in each *payload line* is replaced by a single U+0040.

1.  *Whitespace* at the beginning or end of each *payload line* is removed

1.  The *payload* is created by concatenating all *payload line*s in order;
    if a *payload line* is of a `[CONT]` *pseudo-structure*,
    it is preceded by a single *line break* prior to concatenation.

{.ednote} There is a problem with the above,
where "`@@#x@@`", "`@@#x@`", "`@#x@@`", and "`@#x@`" will all decode as the same *payload*.
The only solution to this that I have come up with involves moving the escapes to the data model.






## IRI to/from Tag

Each *structure type identifier* in a dataset
is represented by a **tag** in the serialisation format.
The mapping between *tag*s and *structure type identifier*s is handled by an **IRI dictionary**.
The *IRI dictionary* may also define a set of alternate IRIs for a *tag*.

{.note} The intent of the set of alternate IRIs
is to aid implementations in handling unknown extensions
without the overhead of a full discovery mechanism.

{.example ...} Suppose that `http://terms.fhiso.org/sources/authorName` is a subtype of `http://terms.fhiso.org/elf/AUTH` that provides additional structural information within the *payload*.  An implementation might create the mapping 

| Tag  | IRIs                                        |
|------|---------------------------------------------|
|`AUTH`|`http://terms.fhiso.org/sources/authorName` <br> `http://terms.fhiso.org/elf/AUTH`|

to inform implementations that lines tagged `AUTH`
are `authorName`s, 
but can be treated like `AUTH`s
if full `authorName` semantics are not understood.
{/}


### IRI dictionary format  {#IRI-dictionary}

The IRI dictionary contains any mix of

-   zero or one *default namespace definition*,
-   zero or more *namespace definitions*, and
-   zero or more *individual tag mappings*.

The *default namespace definition* specifies an absolute IRI.

Each *namespace definition* maps a key matching the production `Prefix` to an absolute IRI.
No two *namespace definition*s within a single dataset may share a key.

    Prefix  ::= [0-9A-Za-z]* "_"

Each *individual tag mapping* maps a key matching the production `Tag` to an ordered sequence of absolute IRIs.
No two *individual tag mapping*s within a single dataset may share a key.


### Tag to IRI {#tag2iri}

To convert a *tag* to an IRI, the following checks are performed in order; the first one that matches is used.

1.  If the *tag* is one of `CHAR`, `CONC`, `CONT`, `DEFN`, `PRFX`, or `TRLR`,
    the *tag* is identifying a *pseudo-structure* and does not map to an IRI.

1.  Otherwise, if the *tag* is a key of an *individual tag mapping*,
    the IRI associated with that *tag* is the first IRI in the IRI sequence of that mapping.
    Additional IRIs in that sequence provide *hints* to implementations that *structures* with this IRI MAY be treated like *structures* with other IRIs in the sequence, with a *preference* for the first usable IRI.

1.  Otherwise, if the *tag* contains one or more underscores,
    let *p* be the substring of the *tag* up to and including the first underscore
    and *s* be the substring after the first underscore.
    If *p* is a key in the prefix dictionary,
    the IRI associated with the *tag* 
    is the value associated with *p* concatenated with *s*.

1.  Otherwise, if there is a *default namespace definition*,
    the IRI associated with the *tag*
    is the IRI of the *default namespace definition* concatenated with the *tag*.

1.  Otherwise, the IRI associated with the *tag*
    is `http://terms.fhiso.org/elf/` concatenated with the *tag*.

{.example ...} Given the following namespace mappings dictionary entries:

Key     Value
------  ---------------------------------------------------------------
`X_`    `http://example.com/extensions/`
`_`     `http://example.com/old_extensions.html#`

and the following individual tag mapping:

Key     Value
------  -------------------------------------------
`_UID`  `http://example.com/UUID` <br> `http://purl.org/dc/terms/identifier`

the following tags convert to the following IRIs:

Tag         IRI
----------  ------------------------------------------------
`HEAD`      `http://terms.fhiso.org/elf/HEAD`
`X_LAT`     `http://example.com/extensions/LAT`
`_LOC`      `http://example.com/old_extensions.html#LOC`
`_UID`      `http://example.com/UUID`

Note that `http://purl.org/dc/terms/identifier` is *not* the IRI of `_UID`:
even if an implementation does not understand `http://example.com/UUID`,
the first element in the IRI sequence is always the IRI of a tag,
the others being instead hints about how to treat that type.
{/}


### IRI to Tag {#iri2tag}

Every *structure* type IRI MUST be replaced by a *tag* as part of serialisation,
and every such replacement MUST be reversible via the IRI dictionary.
The simplest technique to accomplish this is to create an *individual tag mapping* for every IRI with a unique key for each.
However, it is RECOMMENDED that more compact *namespace definition*s be used;
in particular, implementations SHOULD

-   use the default prefix for all *structure* types documented in the [Elf-DM].
-   use one *namespace definition* for each *namespace* (as defined in [Vocabularies]),
    with a key of two or more characters.
-   use just-underscore keys only for compatibility communication with implementations that expect particular *tag*s.
-   provide additional IRIs for extensions that extend *structure* types documented in the [Elf-DM].

{.ednote} Should we say "implementations MUST NOT use any of the six pseudo-structure tags" or add contexts to the definition of pseudo-structures?  In other words, is .INDI.NOTE.DEFN a pseudo-structure or can it be defined as a structure?

### IRI dictionary encoding {#IRI}

The IRI dictionary is encoded as a set pseudo-substructures of the *head*.

Each *namespace definition* is encoded as a *pseudo-structure* with *tag* `[PRFX]`
and *payload* consisting of
the key of the *namespace definition*, a *delimiter*, and the absolute IRI of the *namespace definition*.

Each *default namespace definition* is encoded as a *pseudo-structure* with *tag* `[PRFX]`
and *payload* consisting of
the absolute IRI of the *default namespace definition*.

Each *individual tag mapping* is encoded as a *pseudo-structure* with *tag* `[DEFN]`
and a *payload* consisting of
the key of the *individual tag mapping*, a *delimiter*, and the sequence of absolute IRIs of the *individual tag mapping* separated by *whitespace*.

{.note} The permission of *whitespace* separation allows either all IRIs to be encoded in a single line or some to be encoded in `[CONT]` lines.

{.example ...} Given the following namespace mappings dictionary entries:

Key     Value
------  ---------------------------------------------------------------
`X_`    `http://example.com/extensions/`
`_`     `http://example.com/old_extensions.html#`

and the following individual tag mapping:

Key     Value
------  ---------------------------------------------------------------
`_UID`  `http://example.com/UUID` <br> `http://purl.org/dc/terms/identifier`

the serialisation could begin

````
0 HEAD
1 CHAR UTF-8
1 DEFN _UID http://example.com/UUID
2 CONT http://purl.org/dc/terms/identifier
1 PRFX X_ http://example.com/extensions/
1 PRFX _ http://example.com/old_extensions.html#
````
{/}
















## String to/from octets

### String to octets  {#string2octet}

Given a *string* and character encoding, the *string* is converted into a sequence of octets as specified by that encoding.
It is RECOMMENDED that the encoding used should be able to represent all code points within the *string*.
Any code points that cannot be directly represented as octets within the character encoding SHALL be encoded as follows:

1.  Replace the codepoint with the *string* made of
    1.  The three characters U+0040, U+0023, and U+0055 (i.e., "`@#U`")
    1.  A hexadecimal encoding of the code point
    1.  The two characters U+0040 and U+0020 (i.e., "`@ `")
1.  Encode the *string* with the character encoding

{.note} While GEDCOM has no provision for escaping unecodable code points, it does provide an "escape" construct `@#[^@]*@` which this addition uses.
GEDCOM also does not define what is done with unknown code points, so the above definition does not violate what GEDCOM requires.

{.ednote} Should we instead REQUIRE an encoding that accepts all code points in use?

### Octets to string   {#octet2string}

Given an octet stream and a character encoding,
the octet stream is converted into a sequence of characters as specified by that encoding.

If any subsequence of the decoded *string* matches the production `UEsc`:

    hex  ::= [0-9A-Fa-f]+
    UEsc ::= "@#U" hex "@" #x20?

that substring SHALL be replaced by the code point represented by the hexadecimal number included within the escape sequence.

{.note} While GEDCOM does not have the UEsc provision, this provision will not cause an ELF decoder to misinterpret the output of any known GEDCOM exporter.

{.ednote}  This is specified at the wrong time in the decoding process.
Escape decoding must be done after *lines* have been parsed, otherwise
it is not possible to use "`1 NOTE @#U20@`" to encode a *string*
consisting of just a single space *character*.












## References


### Normative references

[ANSEL]
:   NISO (National Information Standards Organization).
    *ANSI/NISO Z39.47-1993.
    Extended Latin Alphabet Coded Character Set for Bibliographic Use*.
    1993.  (See 
    <http://www.niso.org/apps/group_public/project/details.php?project_id=10>.)
    Standard withdrawn, 2013.

[Basic Concepts]
:   FHISO (Family History Information Standards Organisation).
    *Basic Concepts for Genealogical Standards*.  Public draft.
    (See <https://fhiso.org/TR/basic-concepts>.)

[ISO 10646]
:   ISO (International Organization for Standardization).
    *ISO/IEC 10646:2014.
    Information technology &mdash; Universal Coded Character Set (UCS).*
    2014.

[RFC 2119]
:   IETF (Internet Engineering Task Force).
    *RFC 2119:
    Key words for use in RFCs to Indicate Requirement Levels.*
    Scott Bradner, 1997.
    (See <http://tools.ietf.org/html/rfc2119>.)

[Vocabularies]
:   FHISO (Family History Information Standards Organisation)
    *Preferred nature of vocabularies.*
    See <http://tech.fhiso.org/policies/vocabularies>.

[XML]
:   W3C (World Wide Web Consortium).
    *Extensible Markup Language (XML) 1.1*, 2nd edition.
    Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, and John Cowan eds., 2006.
    W3C Recommendation.
    (See <https://www.w3.org/TR/xml11/>.)

### Other references

[ASCII]
:   ANSI (American National Standards Institute).
    *ANSI INCITS 4-1986 (R2012).  Coded Character Sets -- 7-Bit American
    National Standard Code for Information Interchange (7-Bit ASCII)*.
    2012.

[ELF Data Model]
:   FHISO (Family History Information Standards Organisation)
    *Extended Legacy Format (ELF): Data Model.*  Public draft.
    (See <https://fhiso.org/TR/elf-data-model>.)

[GEDCOM 5.5]
:   The Church of Jesus Christ of Latter-day Saints.
    *The GEDCOM Standard*, release 5.5.  2 Jan 1996, as amended by the
    errata sheet dated 10 Jan 1996.

[GEDCOM 5.5.1]
:   The Church of Jesus Christ of Latter-day Saints.
    *The GEDCOM Standard*, draft release 5.5.1.  2 Oct 1999.

[XML Names]
:   W3 (World Wide Web Consortium).
    *Namespaces in XML 1.1*, 2nd edition.
    Tim Bray, Dave Hollander, Andrew Layman and Richard Tobin, eds., 2006.
    W3C Recommendation.
    See <https://www.w3.org/TR/xml-names11/>.


