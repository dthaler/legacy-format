---
title: "Extended Legacy Format (ELF)"
subtitle: Serialisation Format
date: 8 October 2019
numbersections: true
...

# Extended Legacy Format (ELF):<br/> Serialisation Format

{.ednote ...} This is an **exploratory draft** of the serialisation
format for FHISO's proposed suite of Extended Legacy Format (ELF)
standards.  This document is not endorsed by the FHISO membership, and
may be updated, replaced or obsoleted by other documents at any time.

Comments on this draft should be directed to the
[tsc-public@fhiso.org](http://tech.fhiso.org/tsc-public) mailing list.
{/}

FHISO's **Extended Legacy Format** (or **ELF**) is a hierarchical
serialisation format and genealogical data model that is fully
compatible with GEDCOM, but with the addition of a structured
extensibility mechanism.  It also clarifies some ambiguities that were
present in GEDCOM and documents best current practice. 

The **GEDCOM** file format developed by The Church of Jesus Christ of
Latter-day Saints is the *de facto* standard for the exchange of
genealogical data between applications and data providers.  Its most
recent version is GEDCOM 5.5.1 which was produced in 1999, but despite
many technological advances since then, GEDCOM has remained unchanged.

{.note} Strictly, [GEDCOM 5.5] was the last version to be publicly
released back in 1995.  However a draft dated 2 October 1999 of a
proposed [GEDCOM 5.5.1] was made public; it is generally considered to
have the status of a standard and has been widely implemented as such.

FHISO are undertaking a program of work to produce a modernised yet
backward-compatible reformulation of GEDCOM under the name ELF, the new
name having been chosen to avoid confusion with any other updates or
extensions to GEDCOM, or any future use of the name by The Church of
Jesus Christ of Latter-day Saints.  This document is one of five that
form the initial suite of ELF standards, known collectively as ELF
1.0.0:

* **ELF: Primer**.  This is not a formal standard, but is being
  released alongside the ELF standards to provide a broad overview of
  ELF written in a less formal style.  It gives particular emphasis to
  how ELF differs from GEDCOM.

* **ELF: Serialisation Format**.  This standard defines a
  general-purpose serialisation format based on the GEDCOM data format
  which encodes a dataset as a hierarchical series of lines, and
  provides low-level facilities such as escaping.

* **ELF: Schemas**.  This standard defines flexible extensibility and
  validation mechanisms on top of the serialisation layer.  Although it
  is an *optional* component of ELF 1.0.0, future ELF extensions to ELF
  will be defined using ELF schemas.

* **ELF: Date, Age and Time Microformats**.  This standard defines
  microformats for representing dates, ages and times in arbitrary calendars,
  together with how they are applied to the Gregorian, Julian, French
  Republican and Hebrew calendars.  

* **ELF: Data Model**.  This standard defines a data model based on the
  lineage-linked GEDCOM form, reformulated to be usable with the ELF
  serialisation model and schemas.  It is not a major update to the
  GEDCOM data model, but rather a basis for future extension and
  revision.

## Conventions used

Where this standard gives a specific technical meaning to a word or
phrase, that word or phrase is formatted in bold text in its initial
definition, and in italics when used elsewhere.
The key words **must**, **must not**, **required**, **shall**, 
**shall not**, **should**, **should not**, **recommended**,
**not recommended**, **may** and **optional** in this standard are to be
interpreted as described in
&#x5B;[RFC 2119](https://tools.ietf.org/html/rfc2119)].

An application is **conformant** with this standard if and only if it
obeys all the requirements and prohibitions contained in this
document, as indicated by use of the words *must*, *must not*,
*required*, *shall* and *shall not*, and the relevant parts of its
normative references.  Standards referencing this standard *must not*
loosen any of the requirements and prohibitions made by this standard,
nor place additional requirements or prohibitions on the constructs
defined herein.  

{.note} Derived standards are not allowed to add or remove requirements
or prohibitions on the facilities defined herein so as to preserve
interoperability between applications.  Data generated by one
*conformant* application must always be acceptable to another
*conformant* application, regardless of what additional standards each
may conform to. 

This standard depends on FHISO's **Basic Concepts for Genealogical
Standards** standard.  To be *conformant* with this standard, an
application *must* also be *conformant* with the referenced parts of
[Basic Concepts].  Concepts defined in that standard are used here
without further definition.

{.note} In particular, precise meaning of *character*, *code point*,
*string*, *whitespace*, *whitespace normalisation*, *line break*, *line
break normalisation*, *language tag*, *term* and *literal* are given in
[Basic Concepts].

Certain facilities in this standard are described as **deprecated**,
which is a warning that they are likely to be removed from a future
version of this standard.  This has no bearing on whether a *conformant*
application must implement the facility: they may be *required*,
*recommended* or *optional* as described in this standard.  

Indented text in grey or coloured boxes does not form a normative part
of this standard, and is labelled as either an example or a note.  

{.ednote} Editorial notes, such as this, are used to record outstanding
issues, or points where there is not yet consensus; they will be
resolved and removed for the final standard.  Examples and notes will be
retained in the standard.

The grammar given here uses the form of EBNF notation defined in §6 of
&#x5B;[XML](https://www.w3.org/TR/xml11/)], except that no significance is
attached to the capitalisation of grammar symbols.  *Conforming*
applications *must not* generate data not conforming to the syntax given
here, but non-conforming syntax *may* be accepted and processed by a
*conforming* application in an implementation-defined manner, providing
a warning is issued to the user, except where this standard says
otherwise.

{.note} In this form of EBNF, *whitespace* is only permitted where it
is explicitly stated in the grammar.  It is not automatically permitted
between arbitrary tokens in the grammar.

The grammar productions in this standard uses the `S` and `Char`
productions defined in §2 of [Basic Concepts] to match any non-empty
sequence of *whitespace* *characters* or any valid *character*,
respectively.

## Overview                                                        {#overview}

The ELF serialisation format is a structured, line-based text format for
encoding data in a hierarchical manner that is both machine-readable and
human-readable.  

At a logical level, an ELF document is built from **structures**, the name
ELF gives to the basic hierarchical data structures used to represent
data.  ELF uses two types of *structure*: *tagged structures* and *typed
structures*.  The serialisation layer described in this standard
only deals with *tagged structures*, and the word *structure* is
frequently used in this document to refer to what is properly a *tagged
structure*.

A **tagged structure** consists of:

*  an *optional* *cross-reference identifier* used to identify the
   *structure* within the document; 
*  a *tag*, which is a *string* encoding the meaning of the *structure*;
*  an *optional* *payload*, which can be considered the value of the
   *structure*; and
*  a sequence of zero or more child *structures* known as its
   *substructures*.  These can nest arbitrarily deep in a hierarchical
   manner.

{.note}  This maps quite closely, though not perfectly, to a standard
entity–attribute–value model.  In a *structure* with one or more
*substructures*, the parent *structure* serves as the entity being
described, and its *substructures* each encode an attribute–value pair.   
In a *structure* with a *payload*, the *tag* and *payload*
function in as an attribute–value pairs, with the *tag* identifying the
particular piece of information being recorded and the *payload* being
its value.  It is normal for a *structure* to either have a *payload* or
*substructures*, but not both; however this not a requirement of ELF,
and the [ELF Data Model] contains several *structures* where this is not
true.  The `FAMC` *structure* is an example.  Such *structures* do not
neatly fit into the entity–attribute–value paradigm.

The *tag* describes how the *structure* is to be interpreted, and
*structures* are commonly referred to by their *tag* in this standard.

{.example}  A *structure* whose *tag* is the *string* "`NOTE`" will
often be called a `NOTE` *structure*.

{.note} This standard defines a small number of *tags* which are used for
recording data needed by at the serialisation layer to correctly
interpret an ELF document.  The [ELF Data Model] defines a large set of
*tags* for use in recording genealogical data in a GEDCOM-compatible
manner.   However ELF is a general-purpose data format that can be used
to represent arbitrary data; [ELF Schemas] provides a mechanism for
defining *tags* for other purposes, including to extend the [ELF Data
Model].

The *payload* is either a *literal* or a *pointer* to another
*structure*.  

{.note}  A *literal* is defined in §6.5 of [Basic Concepts] as a
*string* which is tagged with a *datatype name* and sometimes also a
*language tag*.  Making the *payload* a *literal* rather than a plain
*string* is an extension to GEDCOM.  *Datatypes* are defined in §6 of
[Basic Concepts], and are used in the *optional* extensibility mechanism
for ELF described in [ELF Schemas]; however, for the purpose of this
standard, a *datatype name* is simply an IRI that may be associated with
the *string* to help interpret it.  *Language tags* are defined in §3 of
[Basic Concepts].

{.example} A simple example *structure* might have a *tag* of "`AUTH`"
and a *payload* which is a *literal* consisting of the *string*
"`鈴木眞年`" tagged with the *language tag* `ja`.  The *datatype name*
is ignored in this example.  The `AUTH` *tag* is defined in [ELF Data
Model] as meaning "the name of the primary creator of the source", and
鈴木眞年 is the name of genealogist Suzuki Matoshi, written in his
native Japanese language, which is denoted by the *language tag* `ja`.

When the *payload* of a *structure* is a *pointer*, this represents a
link between two *structures*, with the *pointer* in one *structure*
referencing the *cross-reference identifier* in a second *structure*.

{.note}  In this version of ELF, a *pointer* *must* have the same
lexical form as a *cross-reference identifier* used in the same
document.  Both [GEDCOM 5.5.1] and this ELF standard reserve syntax so
that a future standard may use *pointers* to reference *structures* in
other documents.

{.example}  The [ELF Data Model] uses *pointers* to form links between
family records denoted by the `FAM` *tag*, and individual records
denoted by the `INDI` *tag*.  These links are how genealogical
relationships are represented in ELF.  A `FAM` *structure* may contain a
`CHIL` *substructure* whose *payload* is a *pointer*.  Elsewhere in the
document, there will be an `INDI` *structure* whose *cross-reference
identifier* is identical to the *pointer* in the *payload* of the `CHIL`
*substructure* of the `FAMC` *structure*.  This is stating that the
person represented by the `INDI` *structure* is a child of the family
represented by the `FAM` *structure*.

A top-level *structure*, meaning a *structure* which is not a
*substructure* of any other *structure*, is called a **record**.  An ELF
document or **dataset** can have arbitrarily many *records*.

{.ednote}  This is either not strictly true or at least misleading,
because `HEAD` and `TRLR` are not *records*.  Probably.

{.note} The expressiveness of ELF is similar to that of XML.  ELF's
*structures* serve the same role as elements in XML, and nest similarly.
But unlike XML, which has a single root-level element, an ELF *dataset*
typically has multiple *records*.

At a lexical level, a *structure* is encoded as sequence of **lines**,
each terminated with a *line break*.  The first *line* encodes the
*cross-reference identifier*, *tag* and *payload* of the *structure*,
while any *substructures* are encoded in order on subsequent *lines*.
Each *line* consists of the following components, in order, separated by
*whitespace*:

*  a *level*, which is a non-negative decimal *integer* that records how
   many levels of *substructures* deep the current *structure* is nested;
*  the *optional* *cross-reference identifier* of the *structure* being
   encoded by the *line*;
*  a *tag* of the *structure* being encoded; and
*  the *optional* *payload* of the *structure*.

{.example ...}
    0 HEAD
    1 GEDC
    2 VERS 5.5.1
    2 ELF 1.0.0
    2 FORM LINEAGE-LINKED
    1 CHAR UTF-8
    0 INDI
    1 NAME Charlemagne
    0 TRLR

This ELF document has three *lines* with *level* `0` which mark the
start of the three top-level *structures* or *records*.  These *records*
have, respectively, three, one and zero *substructures*, which are
denoted by the *lines* with *level* `1`.   The *structure* represented
by the *line* with a `CHAR` *tag* is a *substructure* of the `HEAD`
*record* because there is no intervening *line* with *level* one less
than `1`; the *structure* represented by the `NAME` *line*
naming Charlemagne is a *substructure* of the `INDI` *record*, as that
is the preceding *line* with a *level* `0`.   The `TRLR` *record* is an
example of a *record* with no *substructures*.

Five of the *lines* in this example document have a *payload*.  For
example, the *payload* of the `FORM` *line* is the *string*
"`LINEAGE-LINKED`", while the *payload* of the `NAME` *line* is the
*string* "`Charlemagne`".  None of the *lines* in this example have
*payload* which are *pointers*, nor do any have a *cross-reference
identifier*.
{/}

### ELF applications                                           {#applications}

A *conformant* application which parses the ELF serialisation format is
called an **ELF parser**.  A *conformant* application which outputs data
in the ELF serialisation format is called an **ELF writer**.  

{.note} Many applications will be both *ELF parsers* and *ELF writers*.

The input to an *ELF parser* and output of an *ELF writer* is an **octet
stream**, which is a sequence of 8-bit bytes or **octets** each with a
value between 0 and 255.

{.note}  An *octet stream* is typically read from or written to a disk
or the network.  This standard does not define how these should be read,
nor how the *octets* are represented in storage or in transit on a
network.

This standard defines how an *octet stream* is parsed into a *dataset*,
and how a *dataset* is serialised into an *octet stream*.  Overviews of
these processes can be found in {§parsing} and {§serialising},
respectively.
An *octet stream* which this standard requires an *ELF parser* to be
able to read is called a **conformant source**.

{.note}  An *octet stream* which an *ELF parser* *must* be able to
read successfully, but can process in an implementation-defined manner
is nonetheless a *conformant source*.

An *octet stream* which is not a *conformant source* is called a
**non-conformant source**.  If the input to an *ELF parser* is not a
*conformant source*, unless this standard says otherwise, the
application *must* either terminate processing that *octet stream* or
present a warning or error message to the user.  If it continues
processing, it does so in an implementation-defined manner.

This standard also recognises a class of application which reads data in
the ELF serialisation format, applies a small number of changes to that
data, and immediately produces output in the ELF serialisation format
which is identical to the input, octet for octet, other where the
requested changes have been made.  Such an application is called an
**ELF editor**.

{.note} *ELF editors* are intended to small programs or scripts that
apply simple modifications to *datasets*, typically with little or no
human interaction.  For example, script which replaces some particular
*deprecated* feature in the *dataset* with an equivalent would be an
*ELF editor*.  This definition of an *ELF editor* is not intended to
include large, feature-rich applications which read ELF into an internal
database, allow users to view and modify most aspects of the data, and
later export it as ELF.

*ELF editors* are not required to conform to the full requirements of an
*ELF parser* or *ELF writer*.  The only requirement this standard places
on *ELF editors* is that, when acting on a *conformant source*, they
*must* either generate output which is a *conformant source*, or present
a warning or error message to the user, or terminate.

{.note} This is a considerably weaker requirement than that placed
on *ELF parsers* and *ELF writers*.  In particular, there is no
requirement for an *ELF editor* to detect invalid input, as an *ELF
parser* is generally required to; nor do the stricter requirements on
the output allowed from *ELF writers* apply.  These relaxations allow
*ELF editors* to do in-place editing of the *octet stream*, without
fully parsing those parts of their input which are not going to be
changed.

### Parsing                                                         {#parsing}
    
The parsing process can be summarised as follows:

1. An *octet stream* is converted to a sequence of *line strings* by

    a. determining its *character encoding* by 
    
        i.  detecting a *character encoding* per {§detected-enc}, and 
        ii. using that *detected character encoding* to look for a
            *specified character encoding* in the *serialisation
            metadata* per {§specified-enc};
    
    b. converting *octets* to *characters* using that *character
       encoding*; and
    c. splitting on *line breaks* per {§line-strings}.

2. *Line strings* are parsed as *lines* per {§lines}.

3. *Lines* are assembled into *records*, each of which are hierarchies
of *tagged structures*, as described in {§tagged-structs}.

4. These *tagged structures* are then processed by:

    - converting *xrefs* to *pointers*, with a special "point to null" if this fails
    - unescaping `@` *characters*
    - preserving valid *escapes* and removing others
    - converting *unicode escapes* into their represented *characters*,
      and
    - merging `CONC` and `CONT`-split *payloads*



### Serialisation                                               {#serialising}

The semantics of serialisation are defined by the following procedural outline.

2. The *tagged structures* are ordered and additional *tagged structures* created to represent *serialisation metadata*.
    
    This step cannot happen before tagging because tagging may generate *serialisation metadata* that needs to be included in the *tagged structures*.

3. Payloads are converted to create *xref structures* by simultaneously
    
    - assigning *xref_ids* and replacing *pointer*-valued *payloads* with *string*-valued *xrefs*
    - escaping `@` *characters*
    - preserving valid *escapes*
    - escaping unrepresentable *characters*
    
    Semantically, these actions must happen concurrently because none of them should be applied to the others' results.
    
    This step cannot happen before tagging because tags are needed to determine the set of valid *escapes*.
    This step cannot happen before adding *serialisation metadata* because it is applied to the *serialisation metadata* as well.

4. The *dataset* is converted to a sequence of *lines* by

    - assigning *levels*
    - splitting *payloads*, if needed, using `CONT` and `CONC`
    - ordering *substructures* in a preorder traversal of the *tagged structures*
    
    This step cannot happen before payload conversion because valid split points are dependant on proper escaping.
    This step must happen before encoding as octets because valid split points are determined by *character*, not octet.

5. The sequence of *lines* is converted to an octet stream by

    - concatenating the *lines* with *line-break* terminators
    - converting *strings* to octets using the *character encoding*


### Glossary                                                       {#glossary}

{.ednote}  *Record* and *structure* are now defined in {§overview},
while *character encoding* is defined in {§parsing-linestrs}.  *Dataset*
and *document* are very nearly defined in {§overview} too, but we don't
currently discuss *metadata* there &mdash; this is an issue which needs
resolving.

Character encoding
:   The scheme used to map between an *octet stream*
    and a *string* of *characters*.

Dataset
:   *Metadata* and a *document*.


Document
:   An unordered set of *structures*.

Metadata
:   A collections of *structures* intended to describe information about the dataset as a whole.
    
    The relative order of *structures* with the same *structure type identifier* SHALL be preserved within this collection;
    the relative order of *structures* with distinct *structure type identifiers* is not defined by this specification.

Record
:   A *structure*, *tagged structure*, or *xref structure* whose *superstructure* is the *document*.

ELF Schema
:   Information needed to correctly parse *tagged structures* into *structures*:
    a mapping between *structure type identifiers* and *tags*
    and metadata relating to valid *escapes* and *prefixes*.

Serialisation Metadata
:   *Tagged structures* inserted during serialisation
    and removed (with all its *substructures*) during parsing.
    They are used to serialise the *character encoding* and *ELF schema*
    as well as to separate the *metadata* and the *document*.

Structure
:   - A **structure type identifier**, which is a *term*.
    - Optionally, a **payload** which is one of
        - A **pointer** to another *structure*, which *must* be a *record* within the same *dataset*.
        - A *string* or subtype thereof.
    - One **superstructure**, which is one of
        - Another *structure*; *superstructure* links MUST be acyclic.
        - The *document*.
        - The *metadata*.
    - A collection of any number of **substructures**, which are *structures*.

        The relative order of *structures* with the same *structure type identifier* SHALL be preserved within this collection;
        the relative order of *structures* with distinct *structure type identifiers* is not defined by this specification.

Superstructure type identifier
:   A *term* identifying the type of the *superstructure* of a *structure*.
    If the *superstructure* is the *document*, this is `elf:Document`.
    If the *superstructure* is the *metadata*, this is `elf:Metadata`.
    Otherwise, this is the *structure type identifier* of a *structures*'s *superstructure*.
    
{.note} *Superstructure type identifier* is not transitive, applying only to the immediate superstructure.

{.example ...} Suppose 
an `elf:INDIVIDUAL_RECORD` is the superstructure of an `elf:GRADUATION`
and the `elf:GRADUATION` is the superstructure of an `elf:AGE_AT_EVENT`.
The *superstructure type identifier* of the `elf:AGE_AT_EVENT` is `elf:GRADUATION`,
not `elf:INDIVIDUAL_RECORD`.
{/}


Tagged Structure
:   Like a *structure*, except 
    
    - it has a *tag* instead of a *structure type identifier*.
    - its *substructures* are stored in a sequence with defined order, not in a partially-ordered collection.

Xref Structure
:   Like a *tagged structure*, except
    
    - it may have an optional *xref_id*.
    - its payload, if present, is always a *string*, not a *pointer*.

## Parsing and serialising line strings                    {#parsing-linestrs}

In order to parse an ELF document, an *ELF parser* *shall* first convert
the *octet stream* into a sequence of **line strings**, which are
*strings* containing the unparsed lexical representations of *lines*.

The way in which *octets* are mapped to *characters* is called the
**character encoding** of the document.  ELF supports several different
*character encodings*.  Determining which is used is a two-stage
process, with the first stage being to determine the **detected
character encoding** of the *octet stream* per {§detected-enc}.
Frequently there will be no *detected character encoding*.  

{.note}  The purpose of this step is twofold: first, it allows
non-ASCII-compatible *character encodings* like UTF-16 to be supported;
and secondly, it removes any byte-order mark that might be present in
the *octet stream*.

Next, the initial portion of the *octet stream* is converted to
*characters* using the *detected character encoding*, failing which in
an ASCII-compatible manner.  This *character* sequence is then scanned
for a `CHAR` *line* whose *payload* identifies the **specified character
encoding**.  This process is described in {§specified-enc}.  If there is
a *specified character encoding*, it is used as the *character encoding*
for the ELF document; otherwise the *detected character encoding* is
used, failing which the default is the ANSEL *character encoding*.
Considerations for reading specific *character encodings* can be found
in {§encodings}.

Once the *character encoding* is determined, the *octet stream* can be
converted into a sequence of *characters* which are assembled into *line
strings* as described in {§line-strings}.  The process of serialising a
*line string* back into an *octet stream* is far simpler as the intended
*character encoding* is already known; this process is described in
{§serialising-line-strings}.

### Detecting a character encoding                             {#detected-enc}

{.note} For applications that choose not to support the *optional*
UTF-16 *character encoding*, the process described in this section can
be as simple as skipping over a UTF-8 byte-order mark, and determining
the *detected character encoding* to be UTF-8 if a byte-order mark was
present.

If a *character encoding* is specified via any supported external means,
such as an HTTP `Content-Type` header, this *should* be taken as to be
the *detected character encoding*.

{.example ...}  Suppose the ELF file was download using HTTP and the
response included this header:

    Content-Type: text/plain; charset=UTF-8

If an application supports taking the *detected character encoding* from
an HTTP `Content-Type` header, the *detected character encoding*
*should* be UTF-8.

Note that the use of the MIME type `text/plain` is *not recommended* for
ELF.  It is used here purely as an example. 
{/}

Otherwise, if the *octet stream* begins with a byte-order mark (U+FEFF)
encoded in UTF-8, the *detected character encoding* *shall* be UTF-8; or
if the application supports the *optional* UTF-16 encoding and the
*octet steam* begins with a byte-order mark encoded in UTF-16 of either
endianness, the *detected character encoding* *shall* be UTF-16 of the
appropriate endianness.  The byte-order mark *shall* be removed from the
*octet stream* before further processing.

Otherwise, if the application supports the *optional* UTF-16 encoding
and the *octet stream* begins with any ASCII *character* (U+0001 to
U+007F) encoded in UTF-16 of either endianness, this encoding *shall* be
the *detected character encoding*. 

{.example} ELF files typically begin with the *character* "`0`".  In
the big endian form of UTF-16, sometimes called UTF-16BE, this is
encoded with the hexadecimal *octets* `00 30`.  These two *octets* will
be detected as an ASCII *character* encoded in UTF-16, and the *detected
charcter encoding* will be determined to be UTF-16BE.

Otherwise, applications *may* try to detect other encodings by examining
the *octet stream* in an implementation-defined manner, but this is 
*not recommended*.

{.note}  One situation where it might be necessary to try to detect
another encoding is if the application needs to support (as an
extension) a *character encoding* like EBCDIC or UTF-32 which is not
compatible with ASCII.

Otherwise, there is no *detected character encoding*.

{.note ...} In this case, for the *octet stream* to be understood, it
must use a 7- or 8-bit *character encoding* that is sufficiently
compatible with ASCII that the `CHAR` *line* can be read.  The only 7 or
8-bit *character encodings* defined in this standard are ASCII, ANSEL
and UTF-8 which encode ASCII *characters* identically.  These will all
be understood correctly if there is no *detected character encoding*.

Some *character encodings* with minor differences from ASCII can also be
understood correctly.  An example is the Japanese Shift-JIS *character
encoding* which uses the *octets* 5C and 7E to encode the yen currency
sign (U+00A5) and overline *character* (U+203E) where ASCII has a
backslash (U+005C) and tilde (U+007E).  An application does not need to
understand these *characters* in order to scan for a `CHAR` *line*.
{/}

{.note ...} These cases can be summarised as follows, where `xx` denotes
any *octet* with a hexadecimal value between `01` and `7F`, inclusive:

----------------  -------------------------------------------------
Initial octets    Detected character encoding
----------------  -------------------------------------------------
`EF BB BF`        UTF-8, with byte-order mark

`FF FE`           UTF-16, little endian, with byte-order mark

`FE FF`           UTF-16, big endian, with byte-order mark

`xx 00`           UTF-16, little endian, without byte-order mark

`00 xx`           UTF-16, big endian, without byte-order mark

Otherwise         None
----------------  -------------------------------------------------
{/}

### Specified character encodings                             {#specified-enc}

To determine the *specified character encoding*, the initial portion of
the *octet stream* *shall* temporarily be converted to *characters*
using the *detected character encoding*.  

If there is no *detected character encoding*, the application *shall*
convert each *octet* to the *character* whose *code point* is the value
of *octet*.  An application *shall* issue an error and stop processing
the *octet stream* if the null *octet* `00` is encountered.  *Restricted
characters*, as defined in §2.3 of [Basic Concepts], *may* be handled in
an implementation-defined manner.

{.note}  This is equivalent to using the ISO-8859-1 *character encoding*
if there is no *detected character encoding*.  As defined in §2 of
[Basic Concepts], *code point* U+0000 is not a *character*.  In
principle, the *octet* `00` might occur in the representation of a valid
*character* in some *character encoding*, but almost all *character
encodings* avoid this and it cannot happen in the ASCII, ANSEL or UTF-8
*character encodings*.  

*Characters* from the initial portion of the *octet stream* are
parsed into *lines strings* as described in {§line-strings}, each
*line string* is *whitespace normalised* as described in §2.1 of [Basic
Concepts], and all lowercase ASCII *characters* (U+0061 to U+007A)
converted to the corresponding uppercase *characters* (U+0041 to
U+005A).

{.note} *Whitespace normalisation* and conversion to uppercase only
applies for the purpose of determining the *specified character set*.
Neither process is otherwise applied to all *line strings*.  It is done
here to simplify scanning for the *specified character set*, but without
requiring full parsing of *line strings* into a *lines*, which might
result in errors if actual *character encoding* is different to the one
being used provisionally while scanning for the *specified character
encoding*.

Once normalised in this manner, the first *line string* of the file
*must* be exactly "`0 HEAD`"; otherwise the application *must*
issue an error and cease parse the *octet stream* as ELF.  If
the application encounters a subsequent normalised *line string*
beginning with a `0` digit (U+0030) followed by a space *character*
(U+0020), the application *shall* stop scanning for a *specified
character encoding*.

{.note}  A *line string* beginning with a "`0`" encodes the start of the
next *record*, and therefore the end of the `HEAD` *record*.  The
*specified character encoding* is given in a `CHAR` *line* in the `HEAD`
*record*; a `CHAR` *line* found elsewhere in the file *must not* be used
to supply the *specified character encoding*.

If the application encounters a *line string* beginning with "`1 CHAR`"
followed by a space *character* (U+0020) while scanning for the
*specified character encoding*, then the remainder of the *line string*
*shall* be used to determine the *specified character encoding*.

If the remainder of the *line string* is exactly "`ASCII`", "`ANSEL`" or
"`UTF-8`", then the *specified character encoding* *shall* be ASCII,
ANSEL or UTF-8, respectively.

{.example ...}  It is *recommended* that all ELF documents use UTF-8 and
record this using a `CHAR` *line* as follows:

    0 HEAD
    1 CHAR UTF-8

This `CHAR` *line string* will be found while scanning for the
*specified character encoding*.  The *line string* begins with "`1
CHAR`" followed by a space *character*; the remainder of the *line
string* is "`UTF-8`" so the *specified character encoding* is recognised
as UTF-8.
{/}

Otherwise, if the remainder of the *line string* is exactly "`UNICODE`"
and the *detected character encoding* is UTF-16 in either endianness,
the *specified character encoding* *shall* be the UTF-16 in that
endianness.

{.note} [GEDCOM 5.5.1] says that the *string* "`UNICODE`" is used to
specify the UTF-16 encoding, though without naming the encoding as such,
and without specifying which endianness is meant.  If the *octet stream*
is a valid ELF document encoded in UTF-16 and the application supports
UTF-16, then the *detected character encoding* will have been determined
accordingly.

Otherwise, the application *may* determine the *specified character
encoding* from the remainder of the *line string* and the *detected
character encoding* in an implementation-defined way.  The application
*may* read one further *line string*, and if it begins with "`2 VERS`"
followed by a space *character* (U+0020), the application *may* also use
the remainder of that *line string* in determining the *specified
character encoding*.

{.example ...}  It is fairly common to find "`ANSI`" on the `CHAR`
*line*, though this has never been a legal option in any version of
GEDCOM.  It typically refers to one of several Windows code pages, most
frequently CP-1252 which was the Windows default code page for English
language installations and for several other Western European languages.
However other code pages exist, and an application localised for, say,
Hungarian might encode the file using CP-1250.  In principle a `VERS`
*line* could contain information to specify the particular code page
used, as in the following ELF fragment, but in practice this is rare.  

    0 HEAD
    1 CHAR ANSI
    2 VERS 1250
{/}

Otherwise, there is no *specified character encoding*.

If there is a *specified character encoding*, it *shall* be used as the
*character encoding* of the *octet stream*.  Otherwise, if there is a
*detected character encoding*, it *shall* be used as the *character
encoding* of the octet stream.  Otherwise, the *character encoding*
*shall* default to be ANSEL.

{.note}  ANSEL is the default *character encoding* for compatibility
with GEDCOM, despite being it being *deprecated* in ELF.

If the *character encoding* is one which the application does not
support, the application *shall* issue an error and stop reading the
file.

### Character encodings                                           {#encodings}

*ELF parsers* are *required* to support reading the ASCII, ANSEL and
UTF-8 *character encodings*.  *ELF writers* are only *required* to
support the UTF-8 *character encoding*.  Support for the UTF-16
*character encoding* is *optional*, and applications *may* support it in
either its big or little endian forms, both, or neither.  The
ASCII, ANSEL and UTF-16 *character encodings* are all *deprecated*.

{.ednote}  We considered making support for ANSEL *optional*, but after
researching  how frequently current GEDCOM files were encoded using
ANSEL (as opposed to claiming to be ANSEL but actually using the ASCII
subset of ANSEL), the TSC felt it had to be *required*.

The UTF-8 and UTF-16 *character encodings* are the Unicode encoding
forms defined in §9.2 of [ISO 10646], and the specifics of the big and
little endian forms of UTF-16 are defined in §9.3 of [ISO 10646].  

{.ednote} Work out whether we're going to cite ISO 10646 or the Unicode
standard, and get check the section numbers.  

{.note}  UTF-8 is a variable-width *character encoding* that uses
between one and four *octets* to encode a *character*.  It is backwards
compatible with ASCII, so ASCII *characters* are encoded to a single
*octet* and other *characters* require more.  For example, the Czech
given name "Miloš" is encoded using the *octet* sequence `4D 69 6C 6F C5
A1` where the last two *octets* encode the *character* "š".  Only
*characters* outside Unicode's Basic Multilingual Plane &mdash; that is
*characters* with a *code point* of U+10000 or higher &mdash; are
encoded with four *octets*.  An example is the ancient Chinese
*character* "𠀡" which is encoded using the *octets* `F0 A0 80 A1`.
Such *characters* can occasionally be found encoded using six *octets*
(e.g. `ED A1 80 ED B0 A1` for "𠀡").  This form, which is called CESU-8
and is not valid UTF-8, typically results from an incorrect
serialisation of UTF-16 data as UTF-8.  Input containing CESU-8 forms
but purporting to be UTF-8 is not a *conformant source*, however 
*ELF parsers* *may* read it providing they issue a warning to the user.
*ELF writers* *must not* generate CESU-8 when serialising data as UTF-8.

{.note}  UTF-16 is also a variable-width *character encoding* which
normally uses two *octets* to encode a *character*, but uses four
*octets* for *characters* outside the Basic Multilingual Plane.  When
only two *octets* are used, UTF-16 is identical to an earlier
fixed-width *character encoding* called UCS-2 which was unable to encode
*characters* outside the Basic Multilingual Plane.  *Conformant*
applications are *required* by §2 of [Basic Concepts] to support
*characters* outside the Basic Multilingual Plane, and therefore
applications which opt to support UTF-16 *must* ensure they do not
implement support for only UCS-2.

{.note}  As UTF-8 and UTF-16 are encodings of Unicode, they naturally
decode into a sequence of Unicode *characters* without requiring
conversion between character sets.

The *character encoding* referred to as ASCII in this standard is the US
version of ASCII which, for the purpose of this standard, is defined as
the subset of UTF-8 which uses only Unicode characters U+0001 to U+007F.

{.note} The US ASCII *character encoding* is normally defined in
[ASCII], but this standard defines it in terms of [ISO 10646].  This is
partly to avoid uncertainty over which of several incompatible
definitions of ASCII is meant, partly because the Unicode standard is
much more readily available than the ASCII one, and partly because ASCII
allows certain punctuation marks a be used as combining diacritics when
they follow the backspace *character* (U+0008).  This use of ASCII
combining diacritics is not included in [ISO 10646], and is forbidden in
both GEDCOM and ELF as the backspace *character* *must not* occur.
Unicode provides a separate set of combining diacritics which are
permitted in ELF.

ANSEL refers to the Extended Latin Alphabet Coded Character Set for
Bibliographic Use defined in [ANSEL].  If an ELF file is determined to
use the ANSEL *character encoding* it *must* be converted into a
sequence of Unicode *characters* before it can be processed further.
This is discussed in {§ansel}.

If other *character encodings* are supported, they too must be converted
into a sequence of Unicode *characters* for further processing.

{.note}  This standard makes no recommendation on how applications
should represent sequences of Unicode *characters* internally, and the
UTF-8, UTF-16 and UTF-32 *character encodings* each have advantages.

{.ednote}  This standard currently makes no distinction between a
*character set* and a *character encoding*, but arguably it would be
cleaner to make this distinction.  Then UTF-16 and UTF-8 are different
*character encodings* of the same Unicode *character set*, and ASCII may
be regarded as such too for our purpose; but ANSEL is a different
*character set* and requires conversion to Unicode.  [ISO 10646] makes
a further distinction between *encoding forms* like UTF-8 and UTF-16, and
*encoding schemes* like UTF-16BE and UTF-16LE.

#### Converting ANSEL to Unicode                                      {#ansel}

{.ednote} Add material from `ansel-to-unicode.md`.

### Line strings                                               {#line-strings}

Before *characters* from the *octet stream* can be parsed into *lines*,
they must be assembled into *line strings*.  This is done by appending
*characters* to the *line string* until a *line break* is encountered,
at which point the *character* or *characters* forming the *line break*
are discarded and a new *line string* is begun.  

{.note}  A *line break* is defined in §2.1 of [Basic Concepts] as a line
feed (U+000A), or carriage return (U+000D) followed by an *optional*
line feed (U+000A).  Unlike the equivalent production in [GEDCOM 5.5.1],
this does not match a line feed followed by a carriage return (U+000A
U+000D) which was used as a line ending on BBC and Acorn computers in
some specific contexts.  In ELF, this sequence is parsed as two *line
breaks* with an intervening blank *line string* which gets ignored.

*ELF readers* *must* be able to handle arbitrarily long *line strings*,
subject to limits of available system resources.

{.note}  This is a change from [GEDCOM 5.5.1] which says that *line
strings* together with the following *line break* *must not* exceed 255
*characters*.  It is no longer common practice to parse lines using
fixed-length buffers, and ELF effectively prohibits this.

Any leading *whitespace* *shall* be removed from the *line string*, but
trailing *whitespace* *must not* also be removed except in the case that
the *line string* is entirely *whitespace*.  If this results in a *line
string* which is an empty *string*, the empty *line string* is
discarded.

{.note ...} These operations resolve ambiguities in [GEDCOM 5.5.1], and
might therefore be a change from some current implementations'
interpretation of the GEDCOM standard.  On the one hand, §1 of [GEDCOM
5.5.1] say that leading *whitespace*, including extra line terminators,
should be allowed and ignored when reading;  on the other hand, the
relevant grammar production does not permit any such leading
*whitespace*.  For maximal compatibility with existing data, a
*conformant* ELF application *must* accept and ignore leading
*whitespace* and blank lines, but *must not* generate them.

For trailing *whitespace*, [GEDCOM 5.5.1] is even less clear.  Twice,
once in §2 and once in Appendix&nbsp;A, it states that applications
sometimes remove trailing *whitespace*, but without saying whether this
behaviour is legal; certainly it implies it is not required.  There
is little consistency in the behaviour of current applications, so any
resolution to this will result in an incompatibility some applications.
In ELF, the trailing *whitespace* *must* be preserved.

The Unicode escape mechanism defined in {§unicode-escape} provides ELF
applications with a way of serialising a value which legitimately ends
in *whitespace* without it being removed by older, non-ELF-aware
applications.
{/}

### Serialising line strings                       {#serialising-line-strings}

*Line strings* are serialised by concatenating them together to form a
single *string*, inserting a *line break* between each *line string* and
after the last one.  All the inserted *line breaks* *must* have
identical lexical forms.

{.note}  Applications can choose whether to use Windows line endings
(U+000D U+000A), traditional Mac OS line endings (U+000D), or the line
endings used on Unix, Linux and modern Mac OS (U+000A), but *must not*
to use mix these in the same file.

Finally, the resulting *string* is encoded into an *octet stream*
using the *character encoding* that was documented in the *serialisation
metadata* *tagged structure* with *tag* "`CHAR`" (see
{§encoding}).  *ELF writers* are only *required* to support the UTF-8
*character encoding*, and this *should* be the default in applications
supporting additional *character encodings*.

{.ednote} Check the above paragraph.  We probably want a later section
to define an *output encoding*.

If the *character encoding* is one which allows a byte-order mark
(U+FEFF) to be encoded, an *ELF writer* *may* prepend one the *octet
stream*.  This is *recommended* when serialising to UTF-16, but is *not
recommended* when serialising to UTF-8.

{.note} This follows the advice in §2.6 of [Unicode] that "Use
of a BOM is neither required nor recommended for UTF-8".


## Parsing and serialising structures                       {#parsing-structs}

### Parsing lines                                                     {#lines}

For a *line string* to be parsed into a *line*, it *must* match the
following `Line` production:

    Line ::= Number S (XRefID S)? Tag (S Pointer S? | S String)?

{.note ...}  The `Line` production does not allow leading *whitespace*
because this has already been removed in the process of creating *line
strings*.  The `S` production is defined in §2.1 of [Basic Concepts] and
matches any non-empty sequence of *whitespace* *characters*, though
because carriage returns and line feeds are always treated as *line
breaks* which delimit *line strings*, in practice the `S` production can
only match space or horizontal tab *characters*.  Allowing tabs or
multiple space *characters* is a departure from [GEDCOM 5.5.1], but one
that is commonly implemented in current applications.

*Whitespace* is *required* between each of the four components of the
*line*.  This is arguably a change from [GEDCOM 5.5.1] where the `delim`
grammar production says that the delimiter is an *optional* space
character.  But almost certainly that is a typo in the grammar that has
persisted through several versions of GEDCOM, and GEDCOM does not intend
the space to be *optional*.  Documents written using very early versions
of GEDCOM – long before its current grammar productions were written –
did frequently merge the *level*, *cross-reference identifier* and *tag*
together, as in "`0@I1@INDI`", but this is not permitted permitted in
ELF.
{/}

{.ednote}  It would be simple enough to modify the grammar so that
"`0@I1@INDI`" would be supported, and this could help make ELF
Serialisation backwards compatible with GEDCOM 1.0.  However the TSC
know of no uses of this in files identifying as GEDCOM 5.x files, and is
not generally supported in applications.  Almost certainly it is an
error arising from confusion over the two different uses of
`[`&hellip;`]` in GEDCOM grammar productions.  Files created using
earlier versions of GEDCOM are only very rarely encountered and their
data model is incompatible with [ELF Data Model].  There seems to be
little benefit to supporting earlier versions of GEDCOM in the
serialisation layer but not in the data model.

The `Line` production contains an ambiguity as any *string* which
matches the `Pointer` production necessarily also matches the `String`
production.  *ELF parsers* *must* treat the *payload* as a
*pointer* if it matches the `Pointer` production, and only as a *string*
if it does not.

{.ednote ...}  An earlier draft of this standard used the following
`PayloadString` production in place of the general-purpose `String`
production.  This ensures that only strings with correctly escaped "at"
signs (U+0040) are allowed in a *payload*.  This removes this ambiguity
from the grammar by ensuring *pointers* do not match the `PayloadString`
production.

    PayloadString ::= PayloadItem*
    PayloadItem   ::= [^#x40] | "@@" | Escape
    Escape        ::= "@#" [^#x40#xA#xD]* "@"

This draft does not do this because it would require all "at" signs to
be correctly escaped.   In practice, unescaped "at" signs are fairly
commonly found in GEDCOM files, particularly in the *payload* of `EMAIL`
*lines*.  It is fairly easy to specify ELF so that these can be
accommodated and this draft does so at the cost of introducing this
ambiguity into the grammar.  In practice it is not anticipated that the
ambiguity will cause implementers difficulties and many current products
appear to allow unescaped "at" signs in the manner proposed here.
{/}

The `Line` production contains a second ambiguity: when there are
multiple *characters* of *whitespace* following the *tag* on a *line*
whose *payload* is a *string*, the second and subsequent *whitespace*
*characters* can be parsed by the `S` production or the `String`
production.  Applications *must* resolve this ambiguity by matching the
`S` production to the shortest possible non-empty sequence of
*whitespace* so that any additional *whitespace* is considered to be
part of the *payload*.

{.note ...} This ambiguity is inherited from GEDCOM, and Appendix&nbsp;A
of [GEDCOM 5.5.1] warns that some applications look for the first
non-space *character* as the start of the *payload*.  There is no
explicit statement that such applications are non-compliant, and this
has left some doubt as to whether or not this behaviour permitted.  In
ELF this is explicitly not allowed.

This ambiguity is most problematic on `CONC` *lines* where it can result
in unwanted *whitespace* being inserted in the middle of a word, or 
necessary *whitespace* being lost between words; it can also cause
problems with any *payload* which has leading *whitespace* which needs
to be preserved.
To avoid this, using the `CONC` mechanism to split the *payload* next to
*whitespace* is *not recommended*, and the *Unicode escape* mechanism in
{§unicode-escape} provides a means of preventing important leading
*whitespace* from being lost.  These allow ELF applications to avoid
depending on this undefined behaviour.
{/}

The `Number`, `XRefID` and `Tag` productions encodes the *level*, the
*cross-reference identifier* and the *tag* of the *line*, respectively.
The `String` and `Pointer` productions encode the *payload* of the
*line*, depending on whether the *payload* is a *string* or a *pointer*,
respectively.  The *cross-reference identifier* and *payload* are both
*optional*.

    Number  ::= "0" | [1-9] [0-9]*
    XRefID  ::= "@" [a-zA-Z0-9_] [^@:!]* "@"
    Tag     ::= [0-9a-zA-Z_]+
    String  ::= Char+
    Pointer ::= "@" [a-zA-Z0-9_] [^@]* "@"

{.ednote} The current working draft of [Basic Concepts] has a `String`
production which is defined as `Char*`.  The `String` production here
only matches a non-empty *string*.  This is to avoid any difference
arising between a *line* with no *payload* and a *line* whose payload is
an empty *string*.  However it may be better to remove this potential
ambiguity in a different way.

{.example ...}
    0 @I1@ INDI
    1 NAME Cleopatra
    1 FAMC @F2@

This ELF fragment contains three *lines*.  The first *line* has a
*level* of `0`, a *cross-reference identifier* of `@I1@`, and a *tag* of
`INDI`; it has no *payload*.  Neither the second nor the third *line*
has a *cross-reference identifier*, and both have a *payload*: on the second
line the *payload* is the *string* "`Cleopatra`", while the *payload* of
the third *line* is a pointer, `@F2@`.
{/}

**Malformed lines** are *lines* or *line strings* which contain certain
particular types of syntactic error.  Input containing a *malformed
line* is a *non-conformant source*.  If an *ELF parser* encounters a
*malformed line*, it *shall* terminate processing the input file.

{.note} These parsing rules have been written to be very tolerant of
unusual input.  *Malformed lines* are considered sufficiently serious
errors that an *ELF parser* *must not* issue a warning to the user an
continue in an implementation-defined manner, despite this usually
being permitted when a *non-conformant source* is encountered.

Any *line string* which does not match the `Line` production is a
*malformed line*.

{.note} Empty *line strings* or *line strings* consisting only of
*whitespace* are not *malformed lines*, despite not matching the `Line`
production, because they have already been removed from the input
stream.

The **previous level** of a *line* is defined as the *level* of the
closest preceding *line*.  The first *line* in the input stream has no
*previous level*.

{.example ...}
    0 INDI
    1 NOTE The 16th President of the United States.
    2 CONT Assassinated by John Wilkes Booth.
    0 TRLR

In this example, the *previous level* of the `TRLR` *line* is `2`, which
is the *level* of the `NOTE` *line*.
{/}

Any *line* that has a *level* more than one greater than its *previous
level* is a *malformed line*.  This does not apply to the first *line*
in the input stream which is never a *malformed line*.

{.example ...}  The following ELF fragment has a missing line.

    0 @I1@ INDI
    2 PLAC Москва
    3 ROMN Moscow
    1 NAME Иван Васильевич
    0 TRLR

The second *line* of this example is a *malformed line* because 
it has a *level* of 2 and a *previous level* of 0.  
{/}

{.note} *ELF parsers* are *required* to check that the first *line
string* is exactly "`0 HEAD`" while determining the *specified character
encoding* per {§specified-enc}, which means the first *line* must always
have a *level* of 0.

### Unescaping payloads

ELF uses the "at" sign (`@`; U+0040) in the representation of
*pointers*, as well as in *escape sequences* which are used to encode
a special processing instructions in a *payload* which is a *string*.
Other uses of the "at" sign *should* be escaped by doubling it as `@@`,
and *must* be when it would result in an ambiguity.

{.note}  [GEDCOM 5.5.1] says they *must* be escaped, but many current
applications fail to do this.  This is particularly relevant to the
`EMAIL` *structure* which almost invariably has a payload containing
one "at" sign, and is often not properly escaped.  *Payloads* with a
single "at" sign are never legal in GEDCOM.  ELF requires such
*payloads* to be interpreted as if the "at" sign had been escaped.



### Assembling structures                                    {#tagged-structs}

Once *line strings* have been parsed into *lines*, the sequence of
*lines* is converted into a sequence of *records*. 

This process starts by parsing the first *line* as the first *line* of a
*structure* using the procedure given in this section.  This *structure*
will be the first *record* in the *dataset*.  If that *record* has
*substructures* then additional *lines* will be read in parsing it.  If
further *lines* remain after the first *record* has been fully parsed,
then the first of them is parsed as first *line* of another *structure*,
which will be next *record* in the *dataset*.  This process continues
until no further *lines* remain, at which point the *dataset* has the
been fully read.

{.note} The process described in this section, together with the
guarantee provided by {§specified-enc} that the first *line* is always
"`0 HEAD`", ensures that the first *line* of every *record* necessarily
has a *level* of 0.

{.note} GEDCOM includes a means for splitting a logical document into
multiple physical documents, sometimes called volumes.  This dates to an
era when documents were commonly stored and shipped on floppy disks, and
a large GEDCOM document might exceed the storage capacity of a single
disk.  This functionality is no longer necessary and is not widely
implemented in present applications.  This functionality is not included
in ELF.

The conversion of *lines* into *structures* is defined recursively.  To
read a *structure*, the parser starts by reading its first *line*, and
creates a *structure* whose *cross-reference identifier*, *tag* and
*payload* are the *cross-reference identifier*, *tag* and *payload*,
respectively, for the first *line*.  The *level* of the first *line* of
the *structure* is referred to in this section as the **current level**.  

{.note}  The *current level* can also be thought of as the recursion
depth.  Once the application has finished reading the *structure*, its
*current level* is no longer needed.

The parser then repeatedly inspects the next *line* to determine whether
it represents the start of a *substructure* of the *structure* being
read.  If the next *line* has a *level* less than or equal to the
*current level*, there are no further *substructures* and the
application has finished reading the *structure*.  

{.example ...}
    1 DEAT Y
    0 TRLR

In the above ELF fragment, the parser reads the first *line* and creates a
*structure* with a `DEAT` *tag* and a *payload* of "`Y`".  It then
inspects the following *line*, but because the following *line* has a
*level* of 0 which is less than the *level* of the first *line* of the
`DEAT` *structure*, this indicates that the `DATE` *structure* has no
*substructures*.
{/}

Otherwise, the application *shall* recursively parse the next *line* as
the first *line* of a new *structure* and append it to the list of
*substructures* being read.  Parsing continues by inspecting the
following *line* to see if it is the start of another *substructure*, as
described above.

{.example ...}
    0 @I1@ INDI
    1 NAME Elizabeth
    1 BIRT
    2 DATE 21 APR 1926
    0 TRLR

In this fragment, an application reads the first *line* and creates an
`INDI` *structure*.  The next *line* has a *level* one greater than the
*level* of the `INDI` *line*, so is parsed as the start of a
*substructure*.  The parser creates a `NAME` *structure*, and as the
*level* of the following *line* is no greater than the *level* of the
`NAME` *line*, the `NAME` *structure* has no *substructures*.  The
`NAME` *structure* is appended as a *substructure* of the `INDI`
*structure*.

The parser then repeats the process, looking for further *substructures*
of the `INDI` *structure*.  The `BIRT` *line* is also one greater than
the *level* of the `INDI` *line*, so is also parsed as the start of a
*substructure*, but this time it has a *substructure* of its own, namely
the `DATE` *structure*.  The `TRLR` *line* has a *level* of 0 which
tells the parser there are no further *substructures* of the `INDI`
*structure*.  

The result is an `INDI` *structure* with two *substructures* with *tags*
`NAME` and `BIRT`, respectively, the latter of which has a
*substructure* of its own with tag `DATE`.  
{/}

### Unescaping and continuation lines

{.ednote} `CONC` and `CONT` *lines* positioned after other *lines* are
*malformed lines*.  So are nested `CONC` or `CONT` *lines*.

Applications *must not* assign significance to where `CONC` tags are 
inserted nor to how many are present in the serialization of a payload.

### Serialising lines                                     {#serialising-lines}

{.ednote} The payload needs escaping, either here or in the next
section.

Each *line* *shall* be converted to a *line string* by concatenating
together the *level*, *cross-reference identifier*, *tag* and *payload* as
described by the `Line` *production* given in {§lines}.  The application
*must* serialise all *line strings* with a single space *character*
(U+0020) for each `S` production in the `Line` production.


### Serialising

Each *xref structure* is encoded as a sequence of one or more *lines*.

These are of three kinds, in order:

1. The **first line** of the *xref structure*
2. Zero or more **additional lines** of the *xref structure*
3. The *lines* that encode each of the *xref structure*'s *substructures* (if any)

{.note} The constraint that *additional lines* come before the *lines* of *substructures* is never mentioned by [GEDCOM 5.5.1]. ELF includes it because it appears to have been universally applied by GEDCOM implementations, and some may depend upon it.

The **level** of each line is a non-negative integer.
The *level* of a *first line* is 0 if the *xref structure* is a *record*
or the *serialisation metadata* *tagged structures* with *tag* "`HEAD`" and "`TRLR`";
otherwise it is one greater than the *level* of the *first line* of its *superstructure*.
The *level* of an *additional line* is one greater than the *level* of its *xref structure*'s *first line*.

Each *first line* has the same *xref_id* (if any) and *tag* as its corresponding *xref line*.
Each *additional line* has no *xref_id* and either "`CONT`" or "`CONC`" as its *tag*.

{.note} Because an *xref structure* MUST NOT have either "`CONC`" or "`CONT`" as its *tag*, it is unambiguous which *lines* are *additional lines* and which *first line* they correspond to.

The *payload* of the *xref structure*
is the concatenation of the *payloads* of the *first line* and all *additional lines*,
with a *line break* inserted before the *payload* of each *additional line* with *tag* "`CONT`".
Because the *payload* of a *line* MUST NOT contain a *line-break*, there MUST be exactly one "`CONT`"-*tagged* *additional line* per *line-break* in the *xref structure*'s *payload*.
The number of "`CONC`"-*tagged* *additional lines* may be picked arbitrarily, subject to the following:

- Each *line* SHOULD be no more than 255 octets after a *line break* has
  been added and the result encoded in the target *character encoding*.
  This *recommended* limit is increased to 510 octets if the target
  *character encoding* is UTF-16.

{.note} GEDCOM *required* that *lines* not exceed 255 *characters*;
this does not seem to be a real restriction in most current applications,
and hence has been reduced to *recommended* status.
We recommend bytes instead of *characters* because the implied 
purpose of this limit (enabling code to use fixed-width buffers)
would limit by bytes, not characters.


- The *payload* of a *line* preceding a "`CONC`"-*tagged* *line* SHOULD NOT have an empty *payload*.
- The *payload* of a *line* preceding a "`CONC`"-*tagged* *line* MUST
  NOT end with a *whitespace*.
- A "`CONC`"-*tagged* *line*' *payload* SHOULD NOT begin with
  *whitespace*.

{.note ...} [GEDCOM 5.5.1] is inconsistent in its discussion of leading and trailing *whitespace*.

- The first of rule in the section "Grammar Rules" in Chapter 1 REQUIRES that spaces be after, not before, a `CONC` split; they (nonsensically) require the same for `CONT`s as well.
- The grammar for `optional_line_value` in Chapter 1 allows both leading and trailing space, with no permission to remove it.
- The definition of `CONC {CONCATENATION}` in Appendix A says an implementation MAY "look for the first non-space starting after the tag to determine the beginning of the value" and hence leading spaces MUST NOT appear.
- The definition of `CONT {CONTINUED}` in Appendix A says an implementation MUST keep leading spaces in a `CONT` as an exception to the usual rules.
- The definition of `NOTE_STRUCTURE` in Chapter 2 says that "most operating systems will strip off the trailing space and the space is lost in the reconstitution of the note."

The RECOMMENDATIONS above are compatible with the most restrictive of these,
while the REQUIREMENTS with the most limiting of them.
{/}

{.example ...}
Suppose an *xref structure*
*tag* is "`NOTE`";
it's *payload* is "`This is a test\nwith one line break`";
and its *superstructure*'s *superstructure* is a *record*.
This *xref structure* requires at least two *lines*
(because it contains one *line break*) and may use more.
It could be serialised in many ways, such as

````gedcom
2 NOTE This is a test
3 CONT with one line break
````

or

````gedcom
2 NOTE This i
3 CONC s a test
3 CONT with on
3 CONC e line break
````
{/}

- Each *line*'s *payload* MUST contain an even number of U+0040 (`@`).
    However, during parsing, this constraint SHALL NOT be enforced in any way.

{.note} [GEDCOM 5.5.1] gives no guidance how to handle unmatched "`@`", but they are relatively common in gedcom files. The above policy is intended to resolve common invalid files in an intuitive way.

{.example ...} Given the following non-*conformant* data

    1 EMAI name@example.com
    2 DATE @#DGREG
    3 CONC ORIAN@ 2 JAN 2019

a *conformant* application will concatenate these *lines* normally during parsing

    1 EMAI name@example.com
    2 DATE @#DGREGORIAN@ 2 JAN 2019

creating a valid date escape in the `DATE`-*tagged* *extended line*.
The unmatched `@` in the `EMAI`-*tagged* *line* is left unchanged during parsing.

Upon re-serialisation, the unmatched @ in the "`EMAI`" will be doubled when converting to an *xref structure*,
but the date escape will not be modified

    1 EMAI name@@example.com
    2 DATE @#DGREGORIAN@ 2 JAN 2019

If the serialisation decides to split either *extended line* with `CONC`s, it MUST NOT do so
in a way that splits up the pairs of "`@`"s.
{/}


## Encoding with `@`

ELF uses the *character* U+0040 (commercial at, `@`)
to encode several special cases when encoding a *tagged structure*
as an *xref structure*.
In particular,

- *pointers* are encoded be assigning an *xref_id* to the pointed-to *tagged structure* and using it as an *xref* in the pointing *payload*
- *characters* outside the *character encoding* are encoded as *unicode escapes*
- *escapes* that are not *preserved escapes* are removed
- `@` that are not part of *escapes* are encoded as `@@`

All of these steps involve `@`s, and MUST NOT be applied to one another's `@`s;
semantically, they are applied concurrently.

During parsing, there is an inherent ambiguity when there are several contiguous `@` in the payload.
These SHALL be resolved in an earliest-match-first order.

{.example ...} The following *xref structure*'s *payloads* are split into sequences as indicated:

*payload* of *xref structure*       decomposed as
-------------------------------     ----------------------------------------------
"`name@example.com`"                "`name`", "`@`", "`example.com`"
"`name@@example.com`"               "`name`", "`@@`", "`example.com`"
"`name@@@example.com`"              "`name`", "`@@`", "`@`", "`example.com`"
"`name@@@@example.com`"             "`name`", "`@@`", "`@@`", "`example.com`"
"`some@#XYZ@ thing`"                "`some`", "`@#XYZ@ `", "`thing`"
"`some@@#XYZ@ thing`"               "`some`", "`@@`", "`#XYZ`", "`@`", "` thing`"
"`some@@@#XYZ@ thing`"              "`some`", "`@@`", "`@#XYZ@ `", "`thing`"
{/}

### Pointer conversion

If a *tagged structure* is pointed to by the *pointer*-valued *payload* of another *tagged structure*,
the pointe-to *tagged structure*'s corresponding *xref structure*
SHALL be given an **xref_id**, a *string* matching production `XrefID`.

    XrefID  ::= "@" ID "@"
    ID      ::= [0-9A-Z_a-z] [#x20-#x3F#x41-#x7E]*

It MUST NOT be the case that two different *xref structures* be given the same *xref_id*.
*Conformant* implementations MUST NOT attach semantic importance to the contents of an *xref_id*.

It is RECOMMENDED that an *xref_id* be no more than 22 characters (20 characters plus the leading and trailing U+0040)

{.note} [GEDCOM 5.5.1] REQUIRED that *xref_id* be no more than 22 characters. ELF weakens this to a RECOMMENDATION.

Each *record* SHOULD be given an *xref_id*;
each non-*record* *structure* SHOULD NOT;
and each *serialisation metadata* *tagged structure* MUST NOT be given an *xref_id*.

{.ednote} Since a pointed-to structure SHALL have an *xref_id* and a non-*record* MUST NOT,
implicitly a *structure* SHOULD NOT point to a non-*record*.
We should probably either make that explicit
or remove it---the latter may make more sense
as what is pointed to seems to be more a data model decision than a serialisation decision.
However, GEDCOM is fairly clear that pointers to non-*records*
might in the future be enabled with a non-standard *xref_id* syntax.

The *xref structure* that corresponds to a *tagged structure* with a *pointer*-valued *payload*
has, as its *payload*, an **xref**:
a *string* identical to the *xref_id* of the *xref structure* corresponding to
the pointed-to *tagged structure*.

When parsing, if *xref* *payloads* are encountered
that do not correspond to exactly one *xref structure*'s *xref_id*,
that *payload* SHALL be converted to to a *pointer* to a *record* with *tag* "`UNDEF`",
which SHALL NOT have a *payload* nor *substructures*.
It is *recommended* that one such "`UNDEF`" *tagged structure* be inserted
for each distinct *xref*.

{.note} The undefined pointer rule is designed to minimize the information loss
in the event of a bad serialised input.

{.note} This rule does not handle pointer-to-wrong-type; information needed to determine that is not known be serialisation and thus must be handled by the data model instead.

{.ednote} We could also allow pointer-to-nothing or pointer-to-multiple-things to be dropped from the dataset,
and/or provide disambiguation heuristics for pointer-to-multiple-things situations. This draft does not do so as it is not obvious that the benefit is worth the complexity.

### Escape preservation and removal

An **escape** is a substring of a *string*-valued *payload* of either a *tagged structure* or *xref structure*
which matched production `Escape`.
Its **escape type** is the portion of the *escape* that was matched by `EscType`.

    Escape   ::= "@#" EscType EscText "@ "
    EscType  ::= [A-Z]
    EscText  ::= [^#xA#xD#x40]*

If the **escape type** is `U` (U+0055), the *escape* is a *unicode escape* and its handling is discussed in {§unicode-escape};
otherwise, it is handled according to this section.

#### Serialisation

If an *escape* is in the *payload* of an *tagged structure* whose *tag* is an *escape preserving tag*,
and if the escape*'s *escape type* is in the *tag*'s set of *preserved escape types*,
then the *escape* SHALL be preserved unmodified in the corresponding *xref structure*'s *payload*.

{.example} If a "`DATE`" *tagged structure* has *payload* "`ABT @#DJULIAN@ 1540`",
its corresponding *xref structure*'s *payload* is also "`ABT @#DJULIAN@ 1540`".

Otherwise, a modification of the *escape* SHALL be placed in the *xref structure*'s *payload*
which is identical to the original *escape* except that each of the two `@`
SHALL each be replaced with a pair of consecutive U+0040 `@`.

{.example} If a "`NOTE`" *tagged structure* has *payload* "`ABT @#DJULIAN@ 1540`",
its corresponding *xref structure*'s *payload* is "`ABT @@#DJULIAN@@ 1540`".

#### Parsing

If an *escape* is in the *payload* of an *xref structure* whose *tag* is an *escape preserving tag*,
and the escape*'s *escape type* is in the *tag*'s set of *preserved escape types*,
the *escape* SHALL be preserved unmodified in the corresponding *tagged structure*'s *payload*.

{.example} If a "`DATE`" *xref structure* has *payload* "`ABT @#DJULIAN@ 1540`",
its corresponding *tagged structure*'s *payload* is also "`ABT @#DJULIAN@ 1540`".

Otherwise, the *escape* SHALL be omitted from the corresponding *tagged structure*'s *payload*.

{.example} If a "`NOTE`" *xref structure* has *payload* "`ABT @#DJULIAN@ 1540`",
its corresponding *tagged structure*'s *payload* is "`ABT 1540`".

{.note} The decision to remove most *escapes* is motivated in part
because [GEDCOM 5.5.1] does not provide any meaning for an *escape* other than a *date escape*.
This caused some ambiguity in how such escapes were handled, which ELF seeks to remove.
Lacking a semantics to assign these *escapes*, ELF chooses to simply remove them.
Implementations that had assigned semantics to them
were actually imposing non-standard semantics to those payloads
which are more accurately handled by using an alternative *ELF schema* to map those *tags*
to different *structure type identifiers* with those semantics documented.

### Unicode escapes                                          {#unicode-escape}

{.note} [GEDCOM 5.5.1] neither has a notion of *unicode escape*
nor any other feature for achieving the same end.
*Unicode escapes* are designed to provide a means for encoding any *character*
in any *character encoding*
in a way that is maximally backwards-compatible from [GEDCOM 5.5.1].

Any *character* MAY be represented with a **unicode escape** consisting of:

1.  The three characters U+0040, U+0023, and U+0055 (i.e., "`@#U`")
2.  A hexadecimal encoding of the *character*'s *code point*
3.  The two characters U+0040 and U+0020 (i.e., "`@ `")

{.ednote} Can we make the final space *optional*?

A *unicode escape* MUST be used for each *character* that cannot be encoded
in the target *character encoding*;
and SHOULD NOT be used otherwise.

{.ednote} Earlier drafts of this specification suggested using `@#U20@` in place of U+0020
when a *line*'s *payload* begins or ends with a space.
Given the inherent ambiguity in the handling of *whitespace* at the ends of a *line*'s *payloads*,
it is not clear if that idea was better than simply clarifying that ambiguity.

{.example} If a *tagged structure*'s *payload* is "`João`" and the *character encoding* is `ASCII`,
the *xref structure*'s *payload* is "`Jo@#UE3@ o`" (or "`Joa@U#303@ o`" if the original used a combining diacritic).

{.ednote} Unicode escapes use GEDCOM's general escape sequence syntax,
in which the character after the `@#` prefix denotes the type of
escape.  In GEDCOM 5.5, the only escape type is `D`, used for calendars,
though other escapes have been used in older versions of GEDCOM.  In
particular, `A` was used auxiliary file references, `C` was used to
switch character set, `F` was used for file inclusion, and `L` was used
to specify the length of a block of non-GEDCOM data included immediately
after the escape.  FHISO are unlikely to reuse these escapes, unless for
a compatible purpose.


### Encoding `@`s

{.ednote ...} It might be worthwhile to restrict this entire section to non-*escape preserving tags*;
without that we have a (somewhat obscure) problem with the current system:

Consider the *escape-preserving tag* `DATE`.
A serialisation/parsing sequence applied to the *string* "`@@#Dx@@ yz`" yields

1. encoded "`@@#Dx@@ yz`"
2. decoded "`@#Dx@ yz`"
3. encoded "`@#Dx@ yz`" -- not with `@@` because it matches a date escape
{/}

During serialisation, each U+0040 (`@`) that is not part of an *escape*
SHALL be encoded as two consecutive U+0040 (`@@`).

{.example} The *tagged structure* *payload* "`name@example.com`"
is serialised as the *xref structure* *payload* "`name@@example.com`"

During parsing, each consecutive pair of U+0040 (`@@`) SHALL be parsed as a single U+0040 (`@`).

{.example} The *xref structure* *payload* "`name@@example.com`"
is parsed as the *tagged structure* *payload* "`name@example.com`"

During parsing, a lone U+0040 is left unmodified.

{.example} If an *xref structure*'s *payload* is "`name@example.com`",
it is parsed as the *tagged structure* *payload* "`name@example.com`";
that in turn will be re-serialised as "`name@@example.com`".

## Serialisation metadata

The *tagged structures* representing the *dataset* are ordered as follows:

1. A *serialisation metadata* *tagged structure* with *tag* "`HEAD`" and the following *substructures*:
    
    - A *serialisation metadata* *tagged structure* with *tag* "`CHAR`" and *payload* identifying the *character encoding* used; see {§encoding} for details.
    
    - A *serialisation metadata* *tagged structure* with *tag* "`SCHMA`"
      and no *payload*, with *substructures* encoding the *ELF Schema*.
    
    - Each *tagged structure* with the *superstructure type identifier* `elf:Metadata`,
        in an order consistent with the partial order of *structures* present in the *metadata*.

2. Each *tagged structure* with the *superstructure type identifier* `elf:Document`, in arbitrary order.

3. A *serialisation metadata* *tagged structure* with *tag* "`TRLR`" and no *payload* or *substructures*.
    
### Charcter encoding names                                        {#encoding}

The *character encoding* SHALL be serialised in the "`CHAR`" *tagged
structure*'s *payload* encoding name in the following table:

------    --------------------------------------------------------------------------
Encoding  Description
------    --------------------------------------------------------------------------
`ASCII`   The US version of ASCII defined in [ASCII].

`ANSEL`   The extended Latin character set for bibliographic use defined
          in [ANSEL].

`UNICODE` Either the UTF-16LE or the UTF-16BE encodings of Unicode
          defined in [ISO 10646].

`UTF-8`   The UTF-8 encodings of Unicode defined in [ISO 10646].
------    --------------------------------------------------------------------------

{.note}  This value is read as the *specified character encoding* per
{§specified-enc}.

It is REQUIRED that the encoding used should be able to represent all
*code points* within the *string*;
*unicode escapes* (see {§unicode-escape}) allow this to be achieved for any supported encoding.
It is RECOMMENDED that `UTF-8` be used for all datasets.



## Tags

### Definitions                                                        {#tags}

A **tag** is a *string* that matches production `Tag`

    Tag ::= [0-9a-zA-Z_]+

A *tag* SHOULD be no more than 15 characters in length.

{.note} [GEDCOM 5.5.1] required tags to be unique within the first 15 characters and no more than 31 characters in length. As memory constraints that motivated those requirements are no longer common, ELF has changed that recommended status instead.

A *tag* SHOULD begin with an underscore (`_`, U+005F) unless it is defined in a FHISO standard.

{.note} [GEDCOM 5.5.1] required all tags other than those it defined to begin with an underscore. ELF's use of *structure type identifiers* largely obviates that need, but it remains *recommended* in ELF 1.0.0 to support legacy systems that have special-case handling for underscore-prefixed *tags*. FHISO is considering removing that recommendation in a subsequent version of ELF.

{.example} "`HEAD`" is a valid *tag*; so is "`_UUID`".
"`23`" and "`UUID`" are also valid, but SHOULD NOT be used as they are not defined in a FHISO standard and do not begin with an underscore.
"`_UNCLE_OF_THE_BRIDE`" is valid, but SHOULD NOT be used as it is 19 *characters* long, more than the 15-*character* recommended maximum length.

*Structure type identifiers* are serialised as *tags*
by utilizing *tag definitions* and *supertypes*, as outlined below.

## References

### Normative references

[ANSEL]
:   NISO (National Information Standards Organization).
    *ANSI/NISO Z39.47-1993.
    Extended Latin Alphabet Coded Character Set for Bibliographic Use*.
    1993.  (See 
    <http://www.niso.org/apps/group_public/project/details.php?project_id=10>.)
    Standard withdrawn, 2013.

[Basic Concepts]
:   FHISO (Family History Information Standards Organisation).
    *Basic Concepts for Genealogical Standards*.  Public draft.
    (See <https://fhiso.org/TR/basic-concepts>.)

[ASCII]
:   ANSI (American National Standards Institute).
    *ANSI X3.4-1986.
    Coded Character Sets -- 7-Bit American National Standard Code for Information Interchange (7-Bit ASCII)*.
    1986.

[ISO 10646]
:   ISO (International Organization for Standardization).
    *ISO/IEC 10646:2014.
    Information technology &mdash; Universal Coded Character Set (UCS).*
    2014.

[RFC 2119]
:   IETF (Internet Engineering Task Force).
    *RFC 2119:
    Key words for use in RFCs to Indicate Requirement Levels.*
    Scott Bradner, 1997.
    (See <http://tools.ietf.org/html/rfc2119>.)

[XML]
:   W3C (World Wide Web Consortium).
    *Extensible Markup Language (XML) 1.1*, 2nd edition.
    Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, and John Cowan eds., 2006.
    W3C Recommendation.
    (See <https://www.w3.org/TR/xml11/>.)

### Other references

[GEDCOM 5.5.1]
:   The Church of Jesus Christ of Latter-day Saints.
    *The GEDCOM Standard*, draft release 5.5.1.  2 Oct 1999.

[GEDCOM 5.5]
:   The Church of Jesus Christ of Latter-day Saints.
    *The GEDCOM Standard*, release 5.5.  1996.

[XML Names]
:   W3 (World Wide Web Consortium).
    *Namespaces in XML 1.1*, 2nd edition.
    Tim Bray, Dave Hollander, Andrew Layman and Richard Tobin, eds., 2006.
    W3C Recommendation.
    See <https://www.w3.org/TR/xml-names11/>.

[ELF Data Model]
:   FHISO (Family History Information Standards Organisation)
    *Extended Legacy Format (ELF): Data Model.*

[Unicode]
:    The Unicode Consortium.
     *The Unicode Standard – Core Specification*, version 12.1.0.
     See <https://www.unicode.org/versions/Unicode12.1.0/>.

\vfill

----
Copyright © 2017–19, [Family History Information Standards Organisation,
Inc](https://fhiso.org/).
The text of this standard is available under the
[Creative Commons Attribution 4.0 International
License](https://creativecommons.org/licenses/by/4.0/).

