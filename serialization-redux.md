---
title: "Extended Legacy Format (ELF)"
subtitle: Serialization Format
date: 14 June 2017
numbersections: true
...
# ELF Serialization Format

This is an early exploratory draft of a proposed FHISO standard that is fully compatible with GEDCOM 5.5.1.

The GEDCOM specification described a document model, a set of tags, and a serialization format.
This document describes the serialization format portion of that specification.

The working title of this draft proposed standard is the FHISO Extended Legacy Format Serialization Format,
also known as the ELF serialization format
or ELF-file.

This draft is intended to provide enough context for meaningful discussion of the value and desirable content of a potential future standard.
It will likely change significantly prior to being released.

----



## General

Where this standard gives a specific technical meaning to a word or phrase, that word or phrase is formatted in bold text in its initial definition, and in italics when used elsewhere.
The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY and OPTIONAL in this standard are to be interpreted as described in [[RFC 2119](//tools.ietf.org/html/rfc2119)].

An application is **conformant** with this standard if and only if it obeys all the requirements and prohibitions contained in this document,
as indicated by use of the words MUST, MUST NOT, REQUIRED, SHALL, and SHALL NOT, and the relevant parts of its normative references.
Standards referencing this standard MUST NOT loosen any of the requirements and prohibitions made by this standard,
nor place additional requirements or prohibitions on the constructs defined herein.  

{.note} Derived standards are not allowed to add or remove requirements or prohibitions on the facilities defined herein so as to preserve interoperability between applications.
Data generated by one *conformant* application must always be acceptable to another *conformant* application, regardless of what additional standards each may conform to. 

Indented text in grey or coloured boxes, such as preceding paragraph, does not form a normative part of this standard, and is labelled as either an example or a note.

{.ednote} Editorial notes, such as this, are used to record outstanding issues, or points where there is not yet consensus;
they will be resolved and removed for the final standard.
Examples and notes will be retained in the standard.

The grammar given here uses the form of EBNF notation defined in §6 of [[XML](https://www.w3.org/TR/xml11/)],
except that no significance is attached to the capitalisation of grammar symbols.
*Conforming* applications MUST NOT generate data not conforming to the syntax given here,
but non-conforming syntax MAY be accepted and processed by a *conforming* application in an implementation-defined manner.


### Characters and strings

**Characters** are specified by reference to their *code point* number in [ISO 10646], without regard to any particular character encoding.
In this standard, *characters* may be identified in this standard by their hexadecimal code point prefixed with "U+".

*Characters* MUST match the `Char` production from [[XML](https://www.w3.org/TR/xml11/)].

    Char  ::=  [#1-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

{.note} This includes all valid unicode *code points* except
the null character,
surrogates (which are reserved for encodings such as UTF-16 and not characters in their own right),
and the invalid characters U+FFFE and U+FFFF.

A **string** is a sequence of zero or more *characters*.

    String  ::= Char*

Applications MAY convert any *string* into Unicode Normalization Form C,
as defined in any version of Unicode Standard Annex #15 [[UAX 15](//unicode.org/reports/tr15/)].

*Characters* matching the `RestrictedChar` production from [[XML](//www.w3.org/TR/xml11/)]

    RestrictedChar  ::=  [#x1-#x8] | [#xB-#xC] | [#xE-#x1F]
                           | [#x7F-#x84] | [#x86-#x9F]

SHOULD NOT appear in *strings*,
and applications MAY process such characters in an implementation-defined manner or reject *strings* containing them.

{.note} This includes all C0 and C1 control characters except tab (U+0009), line feed (U+000A), carriage return (U+000D) and next line (U+0085).

**Whitespace** is defined as a sequence of one or more space *characters*,
carriage returns, line feeds, or tabs.
It matches the production `S` from [[XML](//www.w3.org/TR/xml11/)]:

    S  ::=  (#x20 | #x9 | #xD | #xA)+

A **delimiter** is defined as zero or more adjacent space *characters* or tabs.
It matches the production `Delim`:

    Delim  ::=  (#x20 | #x9)+

A **linebreak** is defined as either an adjacent carriage return and line feed (in either order), or a single carriage return or line feed.
It matches the production `LB`:

    LB  ::=  #xD #xA? | #xA #xD?

A **padded linebreak** is defined as a *linebreak* preceded and followed by zero or more space *characters* or tabs.
It matches the production `PLB`:

    PLB  ::=  (#x20 | #x9)* LB (#x20 | #x9)*

In the event of a difference between the definitions of the `Char`, `RestrictedChar` and `S` productions given here and those in [[XML](//www.w3.org/TR/xml11/)], the definitions in the latest edition of XML 1.1 specification are definitive.

### IRIs  {#IRIs}

The **structure type identifier**s used in this specification are *strings*
that SHALL take the form of an IRI matching the `IRI` production
in §2.2 of [[RFC 3987](//tools.ietf.org/html/rfc3987)].

An IRI MUST NOT be used as a *structure type identifier*
unless it can be converted to a URI using the algorithm
specified in §3.1 of [[RFC 3987](//tools.ietf.org/html/rfc3987)],
and back to a IRI again using the algorithm
specified in §3.2 of [[RFC 3987](//tools.ietf.org/html/rfc3987)],
to yield the original IRI.





## Structures and pseudo-structures

A dataset consists of structures; as part of encoding as a string, these are augmented by a set of pseudo-structures, structure-like constructs that are not part of the data model.

Every dataset contains exactly one `[HEAD]` structure, which contains substructures;
the dataset may also contain any number of other structures.


### Structures   {#Structure}

Every structures consists of the following components:

Structure Type Identifier
:   Every structure has a *structure type identifier*, which is always an IRI.

Identifier
:   A string uniquely identifying this structure within this ELF dataset.
    If present, the identifier MUST match the production ID:
        
        ID  ::= [0-9A-Z_a-z] [#x20-#x3F#x41-#x7E]*

Payload
:   If present, a payload is either a pointer to a structure or a string.
    Each pointed-to structure MUST have a unique identifier within the dataset.

Substructures
:   Structures may contain zero or more other Structures, which are called the structure's **substructures**.

    The order of substructures that have distinct *structure type identifiers* is not significant,
    but the order of substructures with the same *structure type identifier* must be preserved.


### Pseudo-structures

A pseudo-structure consists of the following components:

Tag
:   Every pseudo-structure has a *tag*, specified in this document.

Payload
:   If present, a string.

Substructures
:   Pseudo-structures may contain zero or more  Structures,
    which are called the pseudo-structure's **substructures**.

This specification documents five specific pseudo-structures:

-   `[CONT]` and `[CONC]` are used to encode multi-line (`[CONT]`) or long (`[CONC]`) payload strings.
    As such, they may appear as pseudo-substructures of any structure with a string payload.
    The order of `[CONT]` and `[CONC]` pseudo-structures MUST be preserved.
    Any `[CONT]` and `[CONC]` pseudo-substructures MUST appear 
    before any other substructures or pseudo-substructures
    within any serialization.

-   `[PRFX]` and `[DEFN]` are used to encode the [IRI Dictionary].
    They appear only as pseudo-substructures of the `[HEAD]` structure.

-   `[TRLR]` is always the last element of a serialized dataset.




## Encoding/Decoding a dataset

### Encoding a dataset

To encode a *dataset*,

1.  Determine a character encoding.
    The character encoding MUST be taken from the following options:

    ------    --------------------------------------------------------------------------
    Encoding  Description
    ------    --------------------------------------------------------------------------
    `ASCII`   The US version of ASCII defined in [ASCII].

    `ANSEL`   The extended Latin character set for bibliographic use defined
              in [ANSEL].

    `UNICODE` Either the UTF-16LE or the UTF-16BE encodings of Unicode
              defined in [ISO 10646].

    `UTF-8`   The UTF-8 encodings of Unicode defined in [ISO 10646].
    ------    --------------------------------------------------------------------------

    The character encoding selected
    MUST be able to encode all code points in all payloads in every structure within the dataset.
    It is RECOMMENDED that UTF-8 be used for all datasets.
    
    Add a `[CHAR]` pseudo-structure to the `[HEAD]` with the encoding as its payload.

1.  Create an *IRI dictionary* that can map all *structure type identifiers* in the data into *tag*s.

1.  Add `[PRFX]` and `[DEFN]` pseudo-structures to the `[HEAD]` to [encode the *IRI dictionary*](#IRI)

1.  Create a string by

    1.  Converting the `[HEAD]` into string.
    1.  Appending to that string the string created by converting each other [Structure] that is not the substructure of any other [Structure] into a string.
    1.  Appending the string representation of a trailer pseudo-structure (level 0, tag `TRLR`, no payload).

    If the encoding is either `UNICODE` or `UTF-8`,
    it is RECOMMENDED that the byte-order mark U+FEFF be prepended to the string.

1.  Convert the string into a sequence of octets.

### Decoding a dataset

To decode a *dataset*,

1.  Convert the sequence of octets into a string.

1.  Inspect the portion of the string that encodes the `[HEAD]`,
    ignoring all lines other than those encoding `[PRFX]` and `[DEFN]` pseudo-structures.
    Use those `[PRFX]` and `[DEFN]` pseudo-structures to populate an *IRI dictionary*.

1.  Convert each line into a structure or pseudo-structure.
    Do not include pseudo-structures or their substructures in the resulting dataset.



## Structure to/from String

Each *structure* is mapped to a *string* through the intermediate form of a *line*.

### Lines     {#Line}

A *line* is a string consisting of the following components, in order.
When creating a *line*, each *delimiter* MUST be a single space character U+0020;
when parsing a *line*, and *delimiter* SHALL be accepted.

1.  The **level**: a base-ten integer matching the production `Number`:
    
        Number  ::= "0" | [1-9] [0-9]*

    A *delimiter* MUST follow the *level*, delimiting it from the next element.

2.  Optionally, a **xref_id**: an identifier surrounded by at-signs, matching the production `Xref`:
    
        Xref  ::= "@" [a-zA-Z0-9_] [^@]* "@"

    If the *xref_id* is present, a *delimiter* MUST follow it, delimiting it from the next element.

3.  A **tag**: a string (generally [mapping to a IRI](#IRIs-and-Tags)) matching the production `Tag`:
    
        Tag  ::= [0-9a-zA-Z_]+

4.  Optionally, a **payload line**: a string matching the production `Pline`:
    
        Pline  ::= ([^@] | "@@" | "@#" [^@x#Ax#D]* "@")*

    If the *payload line* is present, a *delimiter* MUST precede it, delimiting it from the previous element.
    A *payload line* MUST NOT begin or end with *whitespace*.

5.  A **terminator**, matching production `PLB`.


### Structure to/from line(s)

Each [Structure] or pseudo-structure is encoded as one or more lines as follows:

1.  The *level* of a structure that is not the substructure of any other structure `0`.
    The *level* of a substructure is 1 greater than the *level* of its superstructure.
    
    For example, the level of a the `ADDR` structure in the context .`HEAD`.`SOUR`.`CORP`.`ADDR` is `3`.

2.  If the structure has an *identifier*, that identifier surrounded by U+0040 (`@`) is the *xref_id*; otherwise, there is no *xref_id*.
    
    For example, the *xref_id* of a structure with *identifier* "S23" is `@S23@`.

3.  The *tag* is the a sting which will map to the structures IRI using the [IRI dictionary](#tag2iri).
    Tags are case-sensitive.

    For example, the *tag* of an `http://terms.fhiso.org/elf/ADDR` structure is `ADDR`.

4.  The *payload line* has several possibilities:
    
    -   If the *payload* of the structure is None, there is no *payload line*.
    
    -   If the *payload* of the structure is a pointer, the *payload line* is the *identifier* of the pointed-to structure surrounded by U+0040 (`@`).
        
        For example, if the payload of a .`INDI`.`ALIA` points to an `INDI` with identifier "I45", the *payload line* is `@I45@`.
    
    -   If the *payload* of the structure is a string, the *payload line* is a prefix of the payload string, determined and encoded as described in [Payload String Encoding].


The [line(s)](#Line) encoding a structure is followed immediately by lines encoding each of its substructures and pseudo-substructures.
The order of substructures of different *structure type identifier*s is arbitrary, but the order of substructures with the same *structure type identifier* MUST be preserved.
It is RECOMMENDED that all substructures with the same *structure type identifier* be placed adjacent to one another.

{.example ...}
The following are all equivalent:

````gedcom
0 @jane@ SUBM
1 NAME Jane Doe
1 LANG Gujarati
1 LANG English
````

````gedcom
0 @jane@ SUBM
1 LANG Gujarati
1 NAME Jane Doe
1 LANG English
````

````gedcom
0 @jane@ SUBM
1 LANG Gujarati
1 LANG English
1 NAME Jane Doe
````

... though the second ordering places a `NAME` between two `LANG`s and is thus not recommended.
The following is *not* equivalent to any of the above:

````gedcom
0 @jane@ SUBM
1 NAME Jane Doe
1 LANG English
1 LANG Gujarati
````
{/}

{.example ...} It is the *structure type identifier* that determines if order must be preserved;
thus, the order of the two notes in the following must be preserved
even though one has a pointer as its payload and the other has a string:

````gedcom
1 NAME Jno. /Banks/
2 NOTE @N34@
2 NOTE This is probably an abbreviation for John
````
{/}


### Payload String Encoding

A string-valued *payload* is encoded into a *payload line* as follows:

1.  The *payload* is split on all *padded linebreak*s,
    and may also be split between any two non-*whitespace* characters
    that are not part of a substring matching the `Escape` production.

        Escape  ::= "@#" [^@#xA#xD]* "@"
    
    The portion before the first split point
    (or the entire *payload* if there are no splits)
    is encoded as the *payload line* of the structure's line;
    the remaining portions are encoded in order
    as the *payload line*s of pseudo-substructures of the structure:
    a `[CONT]` pseudo-structure if the split point was a *padded linebreak*
    and a `[CONC]` pseudo-structure otherwise.

1.  Each U+0040 *payload* which is not part of a substring that matches production `Escape`
    is replaced by two adjacent U+0040s.

{.example ...} If the payload of a .`HEAD`.`NOTE` would be represented in a C-like language as `"Example:\nmulti-line notes  \n supported."`, the `NOTE` could be encoded as

````gedcom
1 NOTE Example:
2 CONT multi-line notes
2 CONT supported.
````

or as

````gedcom
1 NOTE Example:
2 CONT mult
2 CONC i-lin
2 CONC e notes
2 CONT supported.
````

but *not* as

````gedcom
1 NOTE Example:
2 CONT multi-line
2 CONC notes
2 CONT supported.
````
{/}


### Payload String Decoding

A the *payload line*s
of a structure's line
and all its `[CONT]` and `[CONC]` pseudo-substructure lines
are combined to create the structure's *payload* as follows:

1.  Each adjacent pair of U+0040 in each *payload line* is replaced by a single U+0040.

1.  *Whitespace* at the beginning or end of each *payload line* is removed

1.  The *payload* is created by concatenating all *payload line*s in order;
    if a *payload line* is of a `[CONT]` pseudo-structure,
    it is preceded a single *linebreak* prior to concatenation.

{.ednote} There is a problem with the above,
where "`@@#x@@`", "`@@#x@`", "`@#x@@`", and "`@#x@`" will all decode as the same *payload*.
The only solution to this that I have come up with yet involves moving the escapes and doubled-at-sign to the data model.






## IRI to/from Tag

Each *structure type identifier*s in a dataset
if represented by a **tag** in the serialization format.
The mapping between *tag*s and *structure type identifier*s is handled by an **IRI dictionary**.
The *IRI dictionary* may also define a set of alternate IRIs for a tag.

{.note} The intent of the set of alternate IRIs
is to aid implementations in handling unknown extensions
without the overhead of a full discovery mechanism.

{.example ...} Suppose that `http://terms.fhiso.org/sources/authorName` is a subtype of `http://terms.fhiso.org/elf/AUTH` that provides additional structural information within the payload.  An implementation might create the mapping 

| Tag  | IRIs                                        |
|------|---------------------------------------------|
|`AUTH`|`http://terms.fhiso.org/sources/authorName` <br> `http://terms.fhiso.org/elf/AUTH`|

to inform implementations that lines tagged `AUTH`
are `authorName`s, 
but can be treated like `AUTH`s
if full `authorName` semantics are not understood.
{/}


### IRI dictionary format  {#IRI-dictionary}

The IRI dictionary contains any mix of

-   zero or one *default namespace definition*,
-   zero or more *namespace definitions*, and
-   zero or more *individual tag mappings*.

The *default namespace definition* specifies an absolute IRI.

Each *namespace definition* maps a key matching the production `Prefix` to an absolute IRI.
No two *namespace definition* keys within a single dataset may share a tag.
It is RECOMMENDED that each key appear as a prefix substring of the *tag* of at least one line in the dataset.

    Prefix  ::= [0-9A-Za-z]* "_"

Each *individual tag mapping* maps a key matching the production `Tag` to an ordered sequence of absolute IRIs.
No two *individual tag mapping* keys within a single dataset may share a key.
It is RECOMMENDED that each key appear as the *tag* of at least one line in the dataset.


### Tag to IRI {#tag2iri}

To convert a *tag* to an IRI, the following checks are performed in order; the first one that matches is used.

1.  If that tag is a key of an *individual tag mapping*, the IRI associated with that tag is the first IRI in the IRI sequence of that mapping.
    Additional IRIs in that sequence provide *hints* to implementations that structures with this IRI MAY be treated like structures with other IRIs in the sequence, with a *preference* for the first usable IRI.

1.  Otherwise, if the tag contains one or more underscores, let *p* be the substring of the tag up to and including the first underscore and *s* be the substring after the first underscore.  If *p* is a key in the prefix dictionary, the structure's IRI is the value associated with *p* concatenated with *s*.

1.  Otherwise, if there is a *default namespace definition*, the structure's IRI is the IRI of the *default namespace definition* concatenated with the tag

1.  Otherwise, the structure's IRI is `http://terms.fhiso.org/elf/` concatenated with the tag.

{.example ...} Given the following namespace mappings dictionary entries:

Key     Value
------  ---------------------------------------------------------------
`X_`    `http://example.com/extensions/`
`_`     `http://example.com/old_extensions.html#`

and the following individual tag mapping:

Key     Value
------  -------------------------------------------
`_UID`  `http://example.com/UUID`
        `http://purl.org/dc/terms/identifier`

the following tags represent to the following IRIs:

Tag         IRI
----------  ------------------------------------------------
`HEAD`      `http://terms.fhiso.org/elf/HEAD`
`X_LAT`     `http://example.com/extensions/LAT`
`_LOC`      `http://example.com/old_extensions.html#LOC`
`_UID`      `http://example.com/UUID`

Note that `http://purl.org/dc/terms/identifier` is *not* the IRI of `_UID`:
even if an implementation does not understand `http://example.com/UUID`,
the first element in the IRI sequence is always the IRI of a tag,
the others being instead *hints* about how to treat that type.
{/}


### IRI to Tag {#iri2tag}

Every structure type IRI MUST be replaced by a tag as part of serialization,
and every such replacement MUST be reversible via the IRI dictionary.
The simplest technique to accomplish this is to create an *individual tag mapping* for every IRI with a unique key for each.
However, it is RECOMMENDED that more compact *namespace definition*s be used;
in particular, implementations SHOULD

-   use the default prefix for all structure types documented in the [Elf-DM].
-   use one *namespace definition* for each [namespace](//tech.fhiso.org/policies/vocabularies), with a key of two or more characters.
-   use full-tag keys or just-underscore keys only for compatibility communication with implementations that expect particular tag names.
-   provide additional IRIs for extensions that extend structure types documented in the [Elf-DM].


### IRI dictionary encoding {#IRI}

The IRI dictionary is encoded as a set pseudo-substructures of the `[HEAD]`.

Each *namespace definition* is encoded as a pseudo-structure with *tag* `[PRFX]`
and payload consisting of
the key of the *namespace definition*, a *delimiter*, and the absolute IRI of the *namespace definition*.

Each *default namespace definition* is encoded as a pseudo-structure with *tag* `[PRFX]`
and payload consisting of
the absolute IRI of the *default namespace definition*.

Each *individual tag mapping* is encoded as a pseudo-structure with *tag* `[DEFN]`
and a payload consisting of
the key of the *individual tag mapping*, a *delimiter*, and the sequence of absolute IRIs of the *individual tag mapping* separated by *whitespace*.

{.note} The permission of *whitespace* separation allows either all IRIs to be encoded in a single line or some to be encoded in `[CONT]` lines.

{.example ...} Given the following namespace mappings dictionary entries:

Key     Value
------  ---------------------------------------------------------------
`X_`    `http://example.com/extensions/`
`_`     `http://example.com/old_extensions.html#`

and the following individual tag mapping:

Key     Value
------  ---------------------------------------------------------------
`_UID`  `http://example.com/UUID` <br> `http://purl.org/dc/terms/identifier`

the serialization could begin

````
0 HEAD
1 CHAR UTF-8
1 PRFX X_ http://example.com/xtensions/
1 PRFX \_ http://example.com/old_extensions.html#
1 DEFN \_UID http://example.com/UUID
2 CONT http://purl.org/dc/terms/identifier
````
{/}
















## String to/from octets

### String to octets

Given a string and character encoding, the string is converted into a sequence of octets as specified by that encoding.
It is RECOMMENDED that only encodings that are able to represent all code points within the string be used,
but if this is not done then this specification does not define what should be done with those code points.

{.ednote ...} The following has been proposed:

> Any code points that cannot be directly represented as octets within the character encoding SHALL be encoded as follows:
>
> 1.  Replace the codepoint with the string made of
>     1.  The three characters U+0040, U+0023, and U+0055 (i.e., "`@#U`")
>     1.  A hexadecimal encoding of the code point
>     1.  The two characters U+0040 and U+0020 (i.e., "`@ `")
> 1.  Encode the string with the character encoding

While GEDCOM has no similar provision, the "escape" construct in GEDCOM chapter 1 suggests these should be ignored by existing GEDCOM parses.
However, it may be simpler to simply require a unicode-compatible character encoding.
{/}

### Octets to string

In order to parse an ELF document, an application must determine how to map the raw stream of octets read from the network or disk into characters.
This is mapping is called the **character encoding** of the document.
Determining it is a two-stage process.

#### Detected character encoding

If a character encoding is specified via any supported external means, such as an HTTP header,
this *shall* be the **detected character encoding**.  

Otherwise, if the document begins with a byte-order mark (U+FEFF) encoded in UTF-8 or UTF-16 (of either endianness),
this determines the *detected character encoding*.
The byte-order mark is removed from the data stream before further processing.

Otherwise, if the first octets of the data stream are 30 00 or 00 30,
the *detected character encoding* is UTF-16, in little-endian or big-endian form, respectively.

Otherwise, there is no *detected character encoding* defined by this specification.
Extensions MAY implement detection of other character encodings, but are NOT RECOMMENDED to do so.

#### Character encoding

A prefix of octet stream shall be decoded using the *detected character encoding*,
or an unspecified ASCII-compatible encoding if there is no *detected character encoding*.
This prefix is parsed into *lines*, stopping at the second instance of a *line* with *level* 0.   If a *line* with *level* 1 and *tag* `CHAR` was found, its *payload* is the **specified character encoding** of the document.

If there is a *specified character encoding*, it SHALL be used as the *character encoding* of the octet stream.
Otherwise, if there is a *detected character encoding*, it SHALL be used as the *character encoding* of the octet stream.
Otherwise, the *character encoding* SHALL be determined to be ANSEL.

#### Decoding

Given an octet stream and a character encoding,
the octet stream is converted into a sequence of characters as specified by that encoding.

{.ednote ...} The following has been proposed:

> If any subsequence of the decoded string matches the production `UEsc`:
>
>     hex  ::= [0-9A-Fa-f]+
>     UEsc ::= "@#U" hex "@" #x20
> 
> that substring SHALL be replaced by the code point represented by the hexadecimal number included within the escape sequence.

While GEDCOM has no similar provision,
this provision will not break any known GEDCOM exporter.
{/}














## References


### Normative references

[ANSEL]
:   NISO (National Information Standards Organization).
    *ANSI/NISO Z39.47-1993.
    Extended Latin Alphabet Coded Character Set for Bibliographic Use*.
    1993.

[ASCII]
:   ANSI (American National Standards Institute).
    *ANSI X3.4-1986.
    Coded Character Sets -- 7-Bit American National Standard Code for Information Interchange (7-Bit ASCII)*.
    1986.

[ISO 10646]
:   ISO (International Organization for Standardization).
    *ISO/IEC 10646:2014.
    Information technology &mdash; Universal Coded Character Set (UCS).*
    2014.

[RFC 2119]
:   IETF (Internet Engineering Task Force).
    *RFC 2119:
    Key words for use in RFCs to Indicate Requirement Levels.*
    Scott Bradner, 1997.
    (See <http://tools.ietf.org/html/rfc2119>.)

[RFC 3987]
:   IETF (Internet Engineering Task Force).
    *RFC 3987:
    Internationalized Resource Identifiers (IRIs).*
    Martin Duerst and Michel Suignard, 2005.
    (See <http://tools.ietf.org/html/rfc3987>.)

[UAX 15]
:   The Unicode Consortium.
    "Unicode Standard Annex 15: Unicode Normalization Forms"
    in *The Unicode Standard, Version 8.0.0.*
    Mark Davis and Ken Whistler, eds., 2015.
    (See <http://unicode.org/reports/tr15/>.)

[XML]
:   W3C (World Wide Web Consortium).
    *Extensible Markup Language (XML) 1.1*, 2nd edition.
    Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, and John Cowan eds., 2006.
    W3C Recommendation.
    (See <https://www.w3.org/TR/xml11/>.)

### Other references

[XML Names]
:   W3 (World Wide Web Consortium).
    *Namespaces in XML 1.1*, 2nd edition.
    Tim Bray, Dave Hollander, Andrew Layman and Richard Tobin, eds., 2006.
    W3C Recommendation.
    See <https://www.w3.org/TR/xml-names11/>.

[ELF-File]
:   FHISO (Family History Information Standards Organisation)
    *Extended Legacy Format (ELF): Serialization Format.*
