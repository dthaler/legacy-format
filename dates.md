---
title: "Extended Legacy Format (ELF)"
subtitle: Date, Age and Time Microformats
date: 11 December 2018
numbersections: true
...

# Extended Legacy Format (ELF):<br/> Date and Age Microformats

{.ednote ...} This is an **exploratory draft** of the microformats used
for dates, ages and times in FHISO's proposed suite of Extended Legacy Format
(ELF) standards.  This document is not endorsed by the FHISO membership,
and may be updated, replaced or obsoleted by other documents at any
time.

Comments on this draft should be directed to the
[tsc-public@fhiso.org](http://tech.fhiso.org/tsc-public) mailing list.
{/}


FHISO's **Extended Legacy Format** (or **ELF**) is a hierarchical
serialisation format and genealogical data model that is fully
compatible with GEDCOM, but with the addition of a structured
extensibility mechanism.  It also clarifies some ambiguities that were
present in GEDCOM and documents best current practice. 

The **GEDCOM** file format developed by The Church of Jesus Christ of
Latter-day Saints is the *de facto* standard for the exchange of
genealogical data between applications and data providers.  Its most
recent version is GEDCOM 5.5.1 which was produced in 1999, but despite
many technological advances since then, GEDCOM has remained unchanged.

{.note} Strictly, [GEDCOM 5.5] was the last version to be publicly
released back in 1996.  However a draft dated 2 October 1999 of a
proposed [GEDCOM 5.5.1] was made public; it is generally considered to
have the status of a standard and has been widely implemented as such.

FHISO are undertaking a program of work to produce a modernised yet
backward-compatible reformulation of GEDCOM under the name ELF, the new
name having been chosen to avoid confusion with any other updates or
extensions to GEDCOM, or any future use of the term by The Church of
Jesus Christ of Latter-day Saints.  This document is one of three that
form the initial suite of ELF standards, known collectively as ELF 1.0.0:

* **ELF: Serialisation Format**.  This standard defines a
  general-purpose serialisation format based on the GEDCOM data format
  which encodes a *dataset* as a hierarchical series of *lines*, and
  provides low-level facilities such as escaping and extensibility
  mechanisms.

* **ELF: Date, Age and Time Microformats**.  This standard defines
  microformats for representing dates, ages and times in arbitrary calendars,
  together with how they are applied to the Gregorian, Julian, French
  Republican and Hebrew calendars.  These formats are largely identical
  to those used in GEDCOM, but the framework should serve as a basis for
  future work on calendars.

* **ELF: Data Model**.  This standard defines a data model based on the
  lineage-linked GEDCOM form, reformulated in terms of the
  serialisation model described in this document.  It is not a major
  update to the GEDCOM data model, but rather a basis for future
  extension.

## General

### Conventions used

Where this standard gives a specific technical meaning to a word or
phrase, that word or phrase is formatted in bold text in its initial
definition, and in italics when used elsewhere.
The key words **must**, **must not**, **required**, **shall**, 
**shall not**, **should**, **should not**, **recommended**,
**not recommended**, **may** and **optional** in this standard are to be
interpreted as described in
&#x5B;[RFC 2119](https://tools.ietf.org/html/rfc2119)].

An application is **conformant** with this standard if and only if it
obeys all the requirements and prohibitions contained in this
document, as indicated by use of the words *must*, *must not*,
*required*, *shall* and *shall not*, and the relevant parts of its
normative references.  Standards referencing this standard *must not*
loosen any of the requirements and prohibitions made by this standard,
nor place additional requirements or prohibitions on the constructs
defined herein.  

{.note} Derived standards are not allowed to add or remove requirements
or prohibitions on the facilities defined herein so as to preserve
interoperability between applications.  Data generated by one
*conformant* application must always be acceptable to another
*conformant* application, regardless of what additional standards each
may conform to. 

If a *conformant* application encounters data that does not conform to
this standard, it *may* issue a warning or error message, and *may*
terminate processing of the document or data fragment.

This standard depends on FHISO's **Basic Concepts for Genealogical
Standards** standard.  To be *conformant* with this standard, an
application *must* also be *conformant* with [Basic Concepts].  Concepts
defined in that standard are used here without further definition.

{.note} In particular, precise meaning of *character*, *string*,
*whitespace*, *whitespace normalisation*, *term*, *prefix notation*,
*prefix*, *datatype* and *subtype* are given in [Basic Concepts].

Indented text in grey or coloured boxes does not form a normative part
of this standard, and is labelled as either an example or a note.  

{.ednote} Editorial notes, such as this, are used to record outstanding
issues, or points where there is not yet consensus; they will be
resolved and removed for the final standard.  Examples and notes will be
retained in the standard.

The grammar given here uses the form of EBNF notation defined in §6 of
&#x5B;[XML](https://www.w3.org/TR/xml11/)], except that no significance is
attached to the capitalisation of grammar symbols.  *Conforming*
applications *must not* generate data not conforming to the syntax given
here, but non-conforming syntax *may* be accepted and processed by a
*conforming* application in an implementation-defined manner.

This standard uses *prefix notation* when discussing specific *terms*.
The following *prefix* binding is assumed in this standard:

------           -----------------------------------------------
`elf`            `https://terms.fhiso.org/elf/`
------           -----------------------------------------------

{.note}  The particular *prefix* assigned above have no relevance
outside this standard document as *prefix notation* is not used in the
formal data model defined by this standard.  This notation is simply a
notational convenience to make the standard easier to read.


### Basic definitions

{.ednote}  It is likely that these concepts will be moved to [Basic
Concepts] in a future draft of these documents.

An **instant** is defined as an infinitesimally brief point in time.  
A **time interval** is defined as the section of time spanning
between two specific *instants*.

{.example}  The interval lasting from midday on 1 Feb 2018 until midday
on 14 Feb 2018 is a *time interval*. 

{.example}  The lifetime of a particular individual is another example
of a *time interval*, beginning at the *instant* of their birth and
ending with the *instant* of their death.

A **duration** is a measure of the length of time elapsing between two
*instants*, but without reference to any specific pair of start and end
*instants*.

{.example} "3 days", and "34 years, 2 months" are two examples of
*durations* expressed in natural language.

{.note} *Durations* differ from *time intervals* in that *time
intervals* are *durations* with specific start and end *instants*.  A
*time inteval* has a *duration* associated with it, quantifying how long
it lasts.

Fundamental to ELF's handling of dates are a set of *time intervals*
called **calendar days**, each of which spans from one midnight until
the next.

{.note} A *calendar day* lasts for 24 hours, except when leap seconds is
inserted or deleted, or when the local time zone changes, as in the
transition to or from daylight saving time. 
In practical terms, it is a period during which the sun rises and sets
exactly once, except in the polar regions.

{.note}  Because midnight does not occur simultaneously around the
world, the set of *calendar days* in one region may be offset compared
to those in another region.  The details vary depending on local
legislation and custom.  Currently, there can be three different
*calendar days* happening simultaneously in various parts of the world:
when a *calendar day* is just beginning in the Line Islands of Kiribati,
it is still the previous *calendar day* in most of world's landmasses,
and the *calendar day* before that in American Samoa.  This means it is
possible for a person to participate in an event on one *calendar day*,
travel to another region, and subsequently participate in an event on
the previous *calendar day*.  If the second event is the person's death,
this could theoretically result in a living person participating in an
event the *calendar day* after their death.

A **date** is a way of identifying a particular *calendar day*.

{.note}  ELF *dates* do not include an indication of either the time zone
or the locale which leaves some ambiguity into the exact points in time
that are meant.  The [ISO 8601] concept of a *date* has the same
ambiguity.

{.note}  The definitions of an *instant*, a *time interval*, a
*duration*, a *calendar day* and a *date* given here are intended to be
fully compatible with the definitions of these concepts in [ISO 8601].
Any incompatibility between the definitions here and those in [ISO 8601]
is unintentional.

{.ednote}  These concepts have been defined here rather than by
normative reference to [ISO 8601] because of the cost involved in
obtaining a legal copy of [ISO 8601], and the likelihood that
implementers will not do so.

Many different systems for reckoning *dates* have been used throughout
history and in different parts of the world. Such systems are called
**calenders**.

{.example}  The simplest form of *calendar* is to count the number
of *calendar days* which have elapsed since a particular day zero.  The
most popular such *calendar* is called the Julian Day (which is 
unconnected to the similar-sounding Julian Calendar).  Its day zero
is 24 November 4714 BC in the proleptic Gregorian Calendar, a day
chosen to be before all recorded history.  Written as a Julian Day, 1
January 2000 can be represented by the integer 2451545.  Such
*calendars* are not commonly used for writing historical *dates* as they
are cumbersome and error-prone.

{.ednote} Nevertheless, FHISO might consider standardising the Julian
day as a lightweight *calendar* for use as a common intermediate
*calendar* during the conversion of *dates* from one *calendar* to
another.

Many *calendars* make use of units of time which are longer than a
*calendar day*, and the general framework for dates in ELF allows for
two such units of time, a **calendar month** and a **calendar year**,
whose definitions will be dependent on the particular *calendar*.

{.note}  It is intended that a *calendar year* will typically be unit of
time roughly equal to the time it takes the Earth to orbit the Sun, and
a *calendar month* will be a unit of time intermediate in duration between
a *calendar day* and a *calendar year*, and which is often loosely based
on the time it takes the Moon to orbit the Earth.

An **epoch** is an *instant* which serves as a reference point for a
given *calendar* from which *calendar years* are numbered consecutively,
running either forwards of backwards in time.

{.example}  The *epoch* used in many forms of the Islamic Calendar is an
*instant* during the Gregorian year AD&nbsp;622, the year of the Hijrah
when Muhammad moved from Mecca to Medina.  The first *calendar year* of
the Islamic *calendar*, called Anno Hegiræ 1 began at this *epoch*, and
subsequent Islamic *calendar years* have been numbered sequentially,
AH&nbsp;2, AH&nbsp;3, etc.  The previous *calendar years* is commonly
labelled 1&nbsp;BH (standing for Before the Hijrah), and earlier
*calendar years* are numbered backwards from the *epoch*.

{.note} This general definition of an *epoch* does not limit a *calendar*
to only having a single *epoch*, nor does it say whether the numbering
of *calendar years* begins at 0, 1 or some other number.

A *calendar* defines how the number of *calendar days* in each *calendar
month* and the number of *calendar months* in each *calendar year* are
determined.  Stylistic and linguistic variations in the presentation of
a *date* do not constitute separate *calendars*.

{.example}  "31st August, 2018", "31 авг. 2018", "8/31/2018" and 
"2018年8月31日" are various ways in which the *date* which is
represented in [ISO 8601] as "`2018-08-31`" might be presented.  The
differences between these presentations are merely stylistic or
linguistic ones, and therefore these difference are not separate
*calendars*:  they are all written using the Gregorian *calendar*.

{.ednote}  In due course, FHISO will need to clarify and perhaps revise
this definition of what constitutes a distinct *calendar*.  Does Roman
day reckoning (e.g. "Prid. Kal. Sept" for 31 Aug) count as a separate
*calendar* or is just a stylistic variation?  What about regnal years
(e.g. "31 Aug 67 Eliz II")?  What about years beginning on the Feast of
the Annunciation (25 March, sometimes called Lady Day)?  These are not
strictly separate *calendars*, but it could be convenient to consider
them as such in ELF if it is considered desirable for ELF to preserve
the fact that the dates were recorded in these forms.

A **time** is a way of identifying an instant within a *calendar day*,
done by dividing an ordinary *calendar day* into 24 **hours**, each of
which is subdivded into 60 **minutes**, each of which is further divided
into 60 **seconds**.

{.note}  A *calendar days* may exceptionally be divided differently if a
leap second is inserted or deleted, or when the local time zone changes.

The **precision** of a value, such as a *date* or *duration*, is a
measure of how exactly the value has been specified: the more exactly,
the greater the *precision*.  The **accuracy** of a value is a measure
of how close the specified value is to the true value: the further away,
the less *accurate* the value.

{.note}  The *precision* of a value is unrelated to its *accuracy*.
An estimate of the *precision* of a value can often be obtained from
how the value has been written, while knowledge of the accuracy can
only be obtained by finding other evidence, or by understanding the
likely accuracy of the source containing the value.

### Datatypes

{.ednote}  This whole section may vanish in a future draft, as it is
mainly a place to put the various editorial notes found here.

In ELF, *dates* are represented using the `elf:Date` *datatype* defined
in {§date-datatype} of this standard.  *Subtypes* of `elf:Date` are
provided for each *calendar*, for example `elf:GregorianDate`.  It is
anticipated that future standards, by FHISO and by third parties, will
define *subtypes* of `elf:Date` for further *calendars*.

{.ednote ...}  It is the current intention that the `@#D`&hellip;`@`
escape syntax will generalised and become they way of tagging arbitrary
ELF *payloads* with a *datatype*.  The identifier in the escape sequence
is looked up in the ELF schema to become an IRI which will be *datatype
name*.  In the following ELF line

    2 DATE @#JULIAN@ 18 JUN 1483

the *payload* becomes "`18 JUN 1483`", tagged with the *datatype*,
`elf:JulianDate`, assuming a suitable schema, such as this:

    1 SCHMA
    2 PRFX elf https://terms.fhiso.org/elf/
    2 IRI elf:JulianDate
    3 DTYPE JULIAN

(This syntax is still just provisional.)

Exactly how modifiers such as `ABT`, `BEF` or `INT` fit into the
`elf:Date` *datatype* has yet to be determined.  Possibly they will be
part of the *lexical space* of the `elf:Date` *datatypes*, and possibly
they will somehow be separated from the *date*.

Because of the need to support date ranges and periods where the two
end-points are expressed using different *calendars*, we will need to
split the *payload* of such ranges and periods into two separate values,
each tagged with a different *calendar*.  This will need doing in the
ELF serialisation layer.  The means by which this happens has yet to be
decided.  

One option under consideration is to give special treatment to lines
using the `DATE` tag, and have it split

    2 DATE BET @#JULIAN@ 1700 AND @#GREGORIAN@ 1800

into two `DATE` lines, one with the *payload* "`1700`" tagged with
`elf:JulianDate`, the other with the *payload* "`1800`" tagged with
`elf:GregorianDate`.

Another option under consideration is to introduce a general facility
for parsing a *payload* into a sequence of *strings* and some specified
*datatype*, here `elf:Date`.  In such a scheme, the example *payload*
above would be split into four components: the *string* "`BET`", the
`elf:JulianDate` "`1700`", the *string* "`AND`", and the
`elf:GregorianDate` "`1800`".

Both these possibilities need further consideration in the light of date
phrases, which need to retain the in-scope *language tag*.

For compatibility with GEDCOM, if no *calendar* is explicitly specified,
it must default to the Gregorian *calendar*.  This means the *datatype*
must default to `elf:GregorianDate`.  This forcing us towards adding 
*datatype correction* along the lines of the mechanism defined in §3.4 of 
[CEV Concepts].  In CEV this is a *optional* mechanism and in most cases
it can hopefully be *optional* in ELF too.

*Datatype correction* would require every ELF *structure* to specify the
**payload range**, that is the *datatype* or *union of datatypes*
permitted in its *payload*, and optionally its **default payload datatype**,
which *must* be a *subtype* of the *payload range* (perhaps being the
*payload range* itself, perhaps being a *constituent datatype* of the
*union of datatypes*, perhaps being a more normal *subtype*).  If the
*datatype* of the *payload* is `rdf:langString` or `xsd:string`, and if
the *structure* defines a *default payload datatype* with a *pattern*,
and if the *payload* matches that *pattern*, then the application
replaces the original *datatype* of the *payload* with the *default
payload datatype*.

For most *date*-valued *structures*, the *payload range* would likely be
a *union* of `elf:Date` and `rdf:langString`, the latter being to allow
date phrases, and the *default payload datatype* would be
`elf:GregorianDate`.
{/}

ELF does not provide a general-purpose *duration* *datatype*, but the
`elf:Age` *datatype* defined in {§age} is a *datatype* customised for
representing the *duration* of a individual's life.

{.ednote ...}  This could be reviewed.  At the moment the `elf:Age`
*datatype* contains both a general-purpose *duration* microformat and
also a small set of qualitative *age* keywords (like `CHILD`) which do
not belong in a general-purpose *duration* type, and prevent `elf:Age`
from being that.  In principle, a more general *duration* type could be
made a *subtype* of `elf:Age`, but this would introduce an awkward
dependency on the more special-purpose `elf:Age` *datatype*.  

Another option is to remove the `elf:Age` *datatype* and replace it with
two separate *datatypes*: a general-purpose `elf:Duration` *datatype*
and a special `elf:AgeWord` *datatype* for qualitative *age* keywords.
The various ELF structures having an `elf:Age` *payload* would then be
changed to have *payloads* which were a *union of datatypes*.  This
introduces several technical complications, including the need make
*datatype correction* work with multiple *default datatypes*.  In
principle this works fine when the *default datatypes* have disjoint
*lexical spaces*, as they would here, but it would need careful
specification.
{/}

The use of these *datatypes* other than with ELF is *not recommended*.

{.ednote ...} In due course we need to decide FHISO's preferred way of
handling *dates* and *durations* in other serialisation formats.  GEDCOM
X, for example, uses a format more closely based on [ISO 8601], and in
early discussion on *dates* and in the call for paper submissions, we
were erring in that direction too.  

If we end up with one *date* format for ELF, another for GEDCOM X, and
possibly even a third one for a future format of our own, we will want
to make sure we don't end up with *dates* formatted for GEDCOM X
appearing in ELF, or vice versa, otherwise an ELF application will need
to know about every *date* format.  At some level, this requires
converting *dates* between formats when data containing *dates* moves
between systems.  For data in the [ELF Data Model] or in the GEDCOM X
data model, this is no problem as a data conversion stage will be
required when converting between data models, and it can convert the
*date* formats too.

The problem arises with data in the data model of one of FHISO's
component standards, like [CEV Concepts], which is intended to be usable
in ELF, GEDCOM X and other data models.  An ELF application will not
necessarily know about CEV, so there needs to some way of indicating
that the ELF *structure* it is reading contains a *date*.  The could be
done by requiring an ELF schema to be present, though that might be too
onerous a requirement, or by requiring a specific tag like `DATE` to be
used.  The same issue may exist for *ages* too, but it is not general to
all *datatypes* &mdash; just those which have to be formatted
differently in different serialisations, which will hopefully be a
minority of *datatypes*.

On a technical level, we need to decide how to model the fact that
*dates* are formatted differently in (at least) ELF and GEDCOM X in the
system of *datatypes* developed in [Basic Concepts].  One option is to
have a separate set of *datatypes* for ELF, for GEDCOM X, and so on.
That's technically straightforward and is the approach taken here, but
because each *calendar* has its own *datatype*, this may require many
additional *datatypes* to duplicate each *calendar* in each
serialisation format. 


{/}


## The `elf:Age` datatype {#age}

The **age** of a living individual is defined as the *duration* which
has elapsed since the *instant* of their birth.  

{.note}  It is normal to stop counting *age* at the *instant* of an
individual's death, therefore an *age* given for a posthumous event such
as a burial is likely to be the *age* of the person when they died, i.e.
the *duration* of the *time interval* from birth to death, rather than
from birth to burial.

The `elf:Age` *datatype* is used to represent *ages* in ELF, which it
does by recording number of *calendar years*, *calendar months* and
*calendar days* to have elapsed during the *duration*.

The *lexical space* of this *datatype* is the set of *strings*
which match the following `Age` production:

    Age      ::= ( [<>] S? )? ( Duration | BareYear ) | AgeWord
    Duration ::= [0-9]+ | [0-9]+ "y" ( S? [0-9]+ "m" )? ( S? [0-9]+ "d")?
                 | [0-9]+ "m" ( S? [0-9]+ "d" )? | [0-9]+ "d"
    BareYear ::= [0-9]+
    AgeWord  ::= "CHILD" | "INFANT" | "STILLBORN"

{.note}  These productions are case-sensitive, so the *string* "`17y`"
matches the `Duration` production, while "`17Y`" does not.

The `S` production is the *whitespace* production defined in §2 of
[Basic Concepts] and matches any non-empty sequence of *whitespace*
*characters*.  

{.note}  Because the `elf:Age` *datatype* is currently only used in ELF
in contexts where *whitespace normalisation* has been carried out, the
`S` production will only ever match exactly one space *character*.

A *conformant* application serialising an *age* using this *datatype*
*should* use a single space *character* (U+0020) wherever *whitespace* is
permitted in the `Age` production.

{.note}  [GEDCOM 5.5.1] under-specifies how *whitespace* is permitted in
*ages*.  The `Age` production is permissive in its treatment of
*whitespace*, including allowing it to be omitted entirely.  The
preceding recommendation ensures that *conformant* ELF applications will
be maximally compliant with current GEDCOM application which typically
use a single space *character*.

An *age* which uses the `elf:Age` *datatype* *shall* either consist of a
quantitative *duration* conforming to the `Duration` or `BareYear`
productions, or an qualitative *age* keyword conforming to the `AgeWord`
production.

When an *age* is a quantitative *duration* matching the `Duration`
production, it *shall* contain of one, two or three integers, each
followed by a "`y`", "`m`" or "`d`" suffix to denote a number of
*calendar years*, *calendar months* or *calendar days*, respectively,
the sum of which is the *age*.

{.example} The *age* "`15y 2m`" represents a *duration* of 15 years and
2 months.  

If there is only a number of *calendar years* present, the `BareYear`
production allows the "`y`" suffix to be omitted, though this is 
*not recommended*.

{.example} The *age* "`42y`" only specifies a number of *calendar years*
and so can be written "`42`" without the "`y`" suffix.  The *age* "`15y
2m`" *must not* be written "`15 2m`" as this *duration* includes both a
number of *calendar years* and *calendar months*.

{.note ...} Allowing the "`y`" suffix to be omitted as shown in the
`Duration` production is a change from [GEDCOM 5.5.1] where it was
*required*.  This has been relaxed because GEDCOM files fairly commonly
contain lines like the following, despite them being illegal:

    2 AGE 58
{/}

An *age* which is written including a (possibly zero) number of
*calendar days* *may* be assumed to have a *precision* of a few
*calendar days*; an *age* which includes a (possibly zero) number of
*calendar months*, but no explicit number of *calendar days*, *may* be
assumed to have a *precision* of a few *calendar months*; an *age*
containing only a number of *calendar years* *may* be assumed to have a
*precision* of a few *calendar years*.

{.example ...}  The *age* "`40y`" *may* be assumed to have a *precision*
of a few years.  The actual *precision* will depend on context.  In many
situations the *precision* will be exactly one year, and so assuming the
*age* has been given correctly, the individual was born at least 40
years ago but not as long as 41 years ago.  

At other times, a lower *precision* may apply.  For example, on the 1841
census of Britain, adults were asked to round their *age* down to the
previous multiple of five years.  In such a context, an *age* of "`40y`"
means the individual was born at least 40 years ago but not as long
as 45 years ago.  As ELF does not provide a means of stating a range of
years in an *age*, nor of explicitly stating the *precision*, an *age*
recorded as "40" on the 1841 census *should* be encoded in ELF as
"`40y`".
{/}

The precise meaning of an *age* which is quantitative *duration* is
dependent on context, cultural considerations and the *calendar* in use.

{.example}  The previous example gave an example of how the
interpretation of "`40y`" depended on context, due to different
*precisions*.

{.example}  An elderly person reckoning their age using the Islamic 
calendar could consider their age in years to be several years greater 
than if they were reckoning their age using the Gregorian calendar
because the Islamic *calendar year* is around 11 *calendar days* shorter
than the Gregorian *calendar year*.  ELF does not provide a means of
specifying which *calendar* was when recording an *age*.

*Ages* *should* generally be rounded down when expressed using just a
number of *calendar years*, or using a number *calendar years* and
*calendar months*, but an application *should not* assume this is
necessarily the case without additional information.

*Ages* which are quantitative *durations* *may* be prefixed with with a
"`<`" or a "`>`".  These are interpreted as meaning the individual is
at most the specified *age*, or is at least the specified *age*,
respectively.

{.note ...} This means the "`<`" and "`>`" token are actually interpretted
as ≤ and ≥ operators.  In common usage, a person may be said to over 21
as soon as they've had their 21st birthday, at which point they would
normally round their age down to 21.  ELF allows for this usage, and "`>
21y`" may be used to refer to someone whose *age* is exactly 21.  This
may seem to be a deviation from [GEDCOM 5.5.1] which defines them as
meaning less than or greater than the specified *age*, respectively, but
because of the uncertainty in the intended *precision* of an *age*,
there is little practical difference.  

The case for interpreting "`<`" as less than or equal to is weaker,
but there seem to current examples where "`<`" has been used on *ages*
inferred from an *age* given a few months later.
{/}  

{.example} If a source gives an individual's *age* as 52 in
March, their *age* might be inferred to be "`< 52y`" the preceeding
January.  In practice they might be 51 or 52, asuming the source is
*accurate*.  However, it is normally best not to infer *ages* and only
to record *ages* when they are given in sources.

Instead of a quantitative *duration*, an *age* *may* be expressed
qualitatively using an **age word** which matches the `AgeWord`
production.  This standard defines three *age words*: `CHILD`, `INFANT`
and `STILLBORN`.  These *should* be used when a source describes an
individual as a child, an infant, or stillborn, respectively, or
in using other words which are largely equivalent.  They *should not* be
used when a source describes an individual using a quantitative *age*.  

{.note}  The meanings of words "child", "infant" and "stillborn" are to
some extent culturally dependent.  A modern source might describe a
15-year-old as a child, while in mediæval times they a person of this
age was unlikely to be described in that way.  This standard does not
therefore put firm limits on the *ages* meant by these terms.  This is a
deviation from [GEDCOM 5.5.1] which states that a child is less than 8
years old, an infant is less than 1 year old, and a stillborn invididual
is approximately 0 days old.  Nevertheless, these ages may be useful in
deciding whether a foreign word or phrase can reasonably be translated
as one of these word.

{.note}  The word "stillborn" is more than just an *age*: it also
conveys the fact that the baby died just prior to, at, or immediately
after the time of birth.  The `STILLBORN` *age word* *must not* be used
to refer to infants on or around the day of their birth unless they
died around the time of birth.

A *conformant* application *may* remove any leading zeros preceding a
non-zero digit, change how *whitespace* is used in an *age*, or append
any omitted "`y`" suffix, but *must not* otherwise alter the *age*.
In particular, applications *must not* insert or remove zero components,
nor convert between days, months and years.  

{.example} "`2y 0m`", "`2y`" and "`24m`" are all distinct *ages* and
applications *must not* rewrite one to another, however an *conformant*
application *may* convert "`2`" to "`2y`", and *may* also convert
"`2y0m`" to "`2y 0m`".

Formally, the `elf:Age` *datatype* is a *structured non-language-tagged
datatype* which has the following *properties*:

: Datatype definition

------           -----------------------------------------------
Name             `https://terms.fhiso.org/elf/Age`
Type             `http://www.w3.org/2000/01/rdf-schema#Datatype`
Pattern          `([<>][ \t\r\n]*)?([0-9]+|[0-9]+y([ \t\r\n]*[0-9]+m)?`
                 `([ \t\r\n]*[0-9]+d)?|[0-9]+m([ \t\r\n]*[0-9]+d)?|[0-9]+d)`
                 `|CHILD|INFANT|STILLBORN`
Supertype        *No non-trivial supertypes*
Abstract         `false`
------           -----------------------------------------------

{.note} The *pattern* in the table above has been split on to three
lines for convenience of presentation; it is, however, really one
*pattern* and contains no *whitespace* or line breaks.
Any functional difference between the `Age` production and the *pattern*
specified above is unintentional.

## Date formats 

ELF has three different *datatypes* to represent *dates*, depending on
the context.

* `elf:DateValue` is used for historical dates.
* `elf:DateExact` is used in change dates, etc.
* `elf:DatePeriod` is used to record the range of dates in a source.

{.ednote}  We may want to add separate *datatype* for historical dates
which *may* be periods and those which *must not* be.

### Generic date syntax

    CalEsc ::= "@#D" [^@]+ "@"
    Day    ::= [0-9]+
    Month  ::= [A-Z][A-Z][A-Z]+
    Year   ::= [0-9]+ ( "/" [0-9]+ )?
    Epoch  ::= [A-Z.]+

    Date   ::= (CalEsc S?)? ((Day S)? Month S)? Year (S Epoch)?

### The `elf:Date` datatype  {#date-datatype}

In ELF, *dates* are represented using the `elf:Date` *datatype*, which
allows 

Dates are represented using a somewhat involved syntax with three entry points, documented below.

{.ednote ...} The following is the EBNF for date payloads, but it lacks semantics

    Date    ::= greg | juln | hebr | fren | future

    Exact   ::= [1-9] [0-9]? month year_g

    Value   ::= Date | Period | range | approx
                | ( "INT" Date )? "(" String ")"

    Period  ::= "FROM" Date ( "TO" Date )? | "TO" Date

    approx  ::= ( "ABT" | "CAL" | "EST" ) Date
    range   ::= ( "BEF" | "AFT" ) Date | "BET" Date "AND" Date
    
    greg    ::= ("@#DGREGORIAN@" #x20)? d_greg
    juln    ::= "@#DJULIAN@" #x20 d_juln
    hebr    ::= "@#DHEBREW@" #x20 d_hebr
    fren    ::= "@#DFRENCH R@" #x20 d_fren
    future  ::= "@#D" ( "ROMAN" | "UNKNOWN" ) "@" #x20 String
    
    d_fren  ::= ( ( [1-9] [0-9]? )? month_f )? year
    d_greg  ::= ( ( [1-9] [0-9]? )? month )? year_g
    d_hebr  ::= ( ( [1-9] [0-9]? )? month_h )? year
    d_juln  ::= ( ( [1-9] [0-9]? )? month )? year
    
    year_g  ::= [1-9] [0-9]* ( "/" [0-9] [0-9] )? "(B.C.)"?
    year    ::= [1-9] [0-9]* "(B.C.)"?
    
    month   ::= "JAN" | "FEB" | "MAR" | "APR" | "M‌AY" | "JUN"
                | "JUL" | "AUG" | "SEP" | "OCT" | "NOV" | "DEC"

    month_f ::= "VEND" | "BRUM" | "FRIM" | "NIVO" | "PLUV" | "VENT" | "GERM"
                | "FLOR" | "PRAI" | "MESS" | "THER" | "FRUC" | "COMP"

    month_h ::= "TSH" | "CSH" | "KSL" | "TVT" | "SHV" | "ADR" | "ADS"
                | "NSN" | "IYR" | "SVN" | "TMZ" | "AAV" | "ELL"
    
{/}

### Date {#date-format}

At the core of the date syntax is a calendared date.
This consists of an optional *calendar escape* followed by the content of the date.

The *calendar escape* is a substring beginning `@#D` and ending `@`, between which is a calendar identifier; known calendar identifiers are `GREGORIAN`, `FRENCH R`, `HEBREW`, `JULIAN`, `ROMAN`, and `UNKNOWN`.
If no calendar escape is given, `GREGORIAN` is assumed.

{.ednote} Should we move the escape syntax to [ELF-Serialization] and change the above to describe an abstract notion of "an escape"?

{.note} Some dates (in particular the [Period](#date-period) and [Value](#date-value) productions) may have multiple [Date](#date-format) values; it is not known if current implementations can handle situations where the dates are from different calendars, nor if they assume an uncalendared date paired with a calendared date is `GREGORIAN` or the same as the other date provided.  It is RECOMMENDED that the same calendar be used for both Dates in such payloads.

The `ROMAN` and `UNKNOWN` calendars's date formats are not defined in this specification.

`GREGORIAN`, `FRENCH R`, `HEBREW`, and `JULIAN` dates all have the format "day month year", separated by spaces; the day may be omitted; if the day is omitted, the month may be omitted as well.
The three pieces are formatted as follows:
    
day
:   A decimal number of one or two digits.
    This SHOULD NOT be zero or greater than the number of days in the appropriate month.
    This specification does not specify whether single-digit days should begin with a zero or not.

{.ednote} Should we specify leading 0s are preferred?

month
:   Each calendar has a set of strings that may be used.
    
    `GREGORIAN` or `JULIAN`
    :   One of the following three-character strings:
        `JAN`, `FEB`, `MAR`, `APR`, `M‌AY`, `JUN`, `JUL`, `AUG`, `SEP`, `OCT`, `NOV`, or `DEC`
    
    `FRENCH R`
    :   One of the following four-character strings:
        `VEND`, `BRUM`, `FRIM`, `NIVO`, `PLUV`, `VENT`, `GERM`, `FLOR`, `PRAI`, `MESS`, `THER`, `FRUC`, `COMP`
    
    `HEBREW`
    :   One of the following three-character strings:
        `TSH`, `CSH`, `KSL`, `TVT`, `SHV`, `ADR`, `ADS`, `NSN`, `IYR`, `SVN`, `TMZ`, `AAV`, `ELL`

year
:   A decimal number.
    
    For `GREGORIAN` (only), the number may be optionally followed by either or both of the following year suffixes:
    
    Alternate Year
    :   Represented as a `/` and two additional decimal digits, with no spaces.
        Shows the possible date alternatives brought about when the beginning of the year changed from `MAR` to `JAN`: for example, `15 APR 1699/00`.
        
        The `/` MUST NOT have a space on either side.
    
    BCE
    :   Represented as `(B.C.)`, which SHOULD be preceded by a space.
        Indicates a date before the birth of Christ.
    
    If both suffixes are present, `(B.C.)` comes last.

### Exact Date {#exact-date}

An *exact date* is a `GREGORIAN` [Date](#date-format)s with the following additional constraints:

-   They MUST NOT include a *calendar escape*
-   They MUST include the day and month
-   They MUST NOT have either year suffix

### Date Period {#date-period}

A *date period* is one of the following three forms:

-   `FROM` [Date](#date-format)
-   `TO` [Date](#date-format)
-   `FROM` [Date](#date-format) `TO` [Date](#date-format)

### Date Value {#date-value}

A *date value* may have any of a variety of formats:

| Format               | Meaning                                                           |
|----------------------|-------------------------------------------------------------------|
| [Date](#date-format) | |
| [Date Period](#date-period) | |
| `BEF` [Date](#date-format) | before the given date |
| `AFT` [Date](#date-format) | after the given date |
| `BET` [Date](#date-format) `AND` [Date](#date-format) | between the given dates; the first date SHOULD be earlier than the second date |
| `ABT` [Date](#date-format) | about; the given date is not exact |
| `CAL` [Date](#date-format) | calculated mathematically, for example, from an event date and age |
| `EST` [Date](#date-format) | estimated based on some other event date |
| `INT` [Date](#date-format) `(`arbitrary text`)` | interpreted from knowledge about the associated date phrase included in parentheses |
| `(`arbitrary text`)` | information about when an event occurred that is not recognizable to a date parser |

{.ednote} Is the above table or the below list more understandable? We definitely don't need both...

-   [Date](#date-format)
-   [Date Period](#date-period)
-   `BEF` [Date](#date-format)
    
    Meaning: before the given date.
-   `AFT` [Date](#date-format)
    
    Meaning: after the given date.
-   `BET` [Date](#date-format) `AND` [Date](#date-format) 
    
    Meaning: between the given dates.

    The first date SHOULD be earlier than the second date.
-   `ABT` [Date](#date-format)
    
    Meaning: about; the given date is not exact.
-   `CAL` [Date](#date-format)
    
    Meaning: calculated mathematically, for example, from an event date and age.
-   `EST` [Date](#date-format)

    Meaning: estimated based on some other event date.
-   `INT` [Date](#date-format) `(`arbitrary text`)`

    Meaning: interpreted from knowledge about the associated date phrase included in parentheses.
-   `(`arbitrary text`)`
    
    The text gives information about when an event occurred but is not recognizable to a date parser.


### XXX

It is *recommended* that, where possible, dates should be entered in ELF
datasets using the calendar in which they were written in the source.

{.example}  A contemporary record of an event occurring in seventeenth
century Massachusetts would almost certainly be recoded using the Julian
calendar, as Massachusetts, like all the British colonies, did not adopt
the Gregorian calendar until 1752.  The date of the event *should*
therefore be recorded in ELF using the Julian calendar and not converted
to the Gregorian calendar.

## The `elf:Time` datatype {#time}

ELF uses the `elf:Time` *datatype* to represent *times* using the 24-hour
clock in *hours*, *minutes* and *seconds*, with these components
separated by a colon (U+003A).  The *hours* and *minutes* components are
*required*, and the *seconds* component *should* be provided.  A
fractional *seconds* component *may* be provided.  

{.example}  The value "`15:30:00`" is a valid *time*, represented using
the `elf:Time` *datatype*.  It represents half past three in the
afternoon.

The `elf:Time` *datatype* is typically used in conjunction with a value
of type `elf:DateExact` called its **associated date**.

{.example ...}  In [ELF Data Model], *times* are found as `TIME`
subelements of a `DATE` element which has a payload of *datatype*
`elf:DateExact`.

    2 DATE 10 DEC 2018
    3 TIME 13:52:00

In this example, "`10 DEC 2018`" is the *associated date* for the time
"`13:52:00`".
{/}

{.note}  As specified here, the *associated date* will always be
expressed in the Gregorian calendar.

*Strings* in the *lexical space* of the `elf:Time` *datatype* *shall*
match the following `Time` production, as well as the other constraints
given here on the numerical value of each component.  *Whitespace* is
not permitted anywhere in an `elf:Time` value.

    HH       ::= [0-9] [0-9]
    MM       ::= [0-9] [0-9]
    SS       ::= [0-9] [0-9] ("." [0-9]+)?
    TZD      ::= "Z" | ("+" | "-") HH ":" MM
    Time     ::=  HH ":" MM (":" SS)? TZD?  

The `HH` production encodes the *hours* component of the *time*,
zero-padded to two digits.  It *shall* be a decimal integer between `00`
and `24`, inclusive.  Values outside this range are outside the *lexical
space* of `elf:Time`.  The *hours* component *shall* only be `24` if the
*minutes* and *seconds* components are both zero or absent; any other
uses of `24` as an *hours* component is outside the *lexical space* of
the *datatype*.

{.example}  The *strings* "`30:00`" and "`24:30`" are both outside the
*lexical space* of this *datatype*.  The former is invalid because the
*hours* component of `30` is not between `00` to `24`; the latter is
invalid because it has an *hours* component of `24` and a non-zero
*minutes* component.

The *string* "`24:00:00`" is the **end-of-day instant** and denote the
final *instant* of a *calendar day*.  It is the same *instant* as the
first *instant* of the following *calendar day* (which is denoted
`00:00:00`).  *Conformant* applications *must* accept *end-of-day
instants* as valid input but *must not* create new instances of them.
A *conformant* application *may* convert an *end-of-day instant* to
`00:00:00`, but only if it has an *associated date* and that is
simultaneously incremented by one day.

{.example} A *time* of "`24:00:00`" with an *associated date* of "`30
NOV 2018`" *may* be converted to a *time* of "`00:00:00`" with an
*associated date* of "`1 DEC 2018`".

{.note} [GEDCOM 5.5.1] does not specify whether or not the *end-of-day
instant* is legal, and existing applications are unlikely to produce it.
It is supported by `elf:Time` for compatibility with [ISO 8601] and the
`xsd:time` *datatype* defined in [XSD Pt2].

The `MM` production encodes the *minutes* component of the *time*,
zero-padded to two digits.  It *shall* be a decimal integer between `00`
and `59`, inclusive.  Values outside this range are outside the *lexical
space* of `elf:Time`. 

The `SS` production encodes the *seconds* component of the *time*,
zero-padded to two digits and followed by an *optional* fractional
component.  It *shall* be a decimal greater than or equal to `00` and
strictly less than `61`.  Values outside this range are outside the
*lexical space* of `elf:Time`.

Applications *must* preserve at least the first three decimal digits of
a fractional *seconds* component, but *may* truncate or round the
fractional part of the *seconds* component beyond that.  Applications
*may* add or remove trailing zeros on the frational part of the
*seconds* component, and *should* add a *seconds* component of `:00` if
none was given.

{.note}  These provisions allows applications to process *times* using
the standard data structures and facilities provided in many program
languages, without preserving the original lexical form of the *time*.

{.note}  A future version of this standard is likely to make the
*seconds* component *required* to make this *datatype* fully compatible
with the `xsd:time` *datatype* defined in [XSD Pt2].  

A *seconds* component greater than or equal to `60`, and strictly less
than `61` is a **leap second** component.  Any use of a *leap second*
component is part of the *lexical space* of `elf:Time`, but *leap
second* components *shall* only be used to represent a leap seconds
inserted by the International Earth Rotation Service or its successor.

*Conformant* applications encountering a *leap seconds* component *may*
convert it to an ordinary *seconds* component by subtracting one from
its value.  This *should not* be done if the application supports
leap seconds and knows the specified *time* was a leap second.

{.example}  The *string* "`12:56:60.800`" is in the *lexical space* of
this *datatype* and has a *leap second* component of `60.800`.  As leap
seconds are always been inserted at midnight UTC and there is no
timezone in which this *time* is midnight UTC, this *time* could not
arise in practice and therefore *conformant* applications *must not*
generate such a *time*.  *Conformant* applications *must* accept such
*times* but *may* subtract one second to convert it to "`12:56:59.800`".

{.note}  [GEDCOM 5.5.1] makes no mention of leap seconds, but existing
applications are likely to generate such *times* if they happen to save
a file during the inserted leap second.  Leap seconds are also supported
in [ISO 8601], but not in the `xsd:time` *datatype* defined in [XSD Pt2].
These rules allow compatibility with these standards and with possible
existing use, while also allowing applications to ignore the leap
second.

The *lexical space* of the `elf:Time` *datatype* allows the inclusion of
a **time zone designator** matching the `TZD` production.  *Conformant*
applications *must* accept *time zone designators* on *dates* in input,
but *should* ignore them and *may* remove them.  *Conformant*
applications *must not* include *time zone designators* on newly
generated *times*.

{.note}  Syntactic support for *time zone designators* is an extention to
[GEDCOM 5.5.1], and is included in ELF for forwards compatibility. This
standard does not specify the meaning conveyed by a *time zone
designator*, but the syntax used is compatible with [ISO 8601] and the
`xsd:time` *datatype* defined in [XSD Pt2], and a future version of this
standard is likely to define by reference to the latter standard.

Formally, the `elf:Time` *datatype* is a *structured non-language-tagged
datatype* which has the following *properties*:

: Datatype definition

------           -----------------------------------------------
Name             `https://terms.fhiso.org/elf/Time`
Type             `http://www.w3.org/2000/01/rdf-schema#Datatype`
Pattern          `(([01][0-9]|2[0-3]):[0-5][0-9](:([0-5][0-9]|60)(\.[0-9]+)?)?`
                 `|24:00:00(\.0+)?)(Z|(\+|-)([01][0-9]|2[0-3]):[0-5][0-9])?`
Supertype        *No non-trivial supertypes*
Abstract         `false`
------           -----------------------------------------------

{.note} The *pattern* in the table above has been split on to two
lines for convenience of presentation; it is, however, really one
*pattern* and contains no *whitespace* or line breaks.
really one single line.  Any functional difference between the `Time`
production and the *pattern* specified above is unintentional.

## References

### Normative references

[Basic Concepts]
:   FHISO (Family History Information Standards Organisation).
    *Basic Concepts for Genealogical Standards*.  First public draft.
    (See <https://fhiso.org/TR/basic-concepts>.)

[ELF Data Model]
:   FHISO (Family History Information Standards Organisation).
    *Extended Legacy Format (ELF): Data Model*.  Exploratory draft.
    (See <https://fhiso.org/TR/elf-data-model>.)

[ISO 8601]
:   ISO (International Organization for Standardization).  *ISO
    8601:2004.  Data elements and interchange formats — Information
    interchange — Representation of dates and times*.  2004.

[RFC 2119]
:   IETF (Internet Engineering Task Force).
    *RFC 2119:
    Key words for use in RFCs to Indicate Requirement Levels.*
    Scott Bradner, 1997.
    (See <http://tools.ietf.org/html/rfc2119>.)

[XML]
:   W3C (World Wide Web Consortium).
    *Extensible Markup Language (XML) 1.1*, 2nd edition.
    Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, 
    and John Cowan eds., 2006.  W3C Recommendation.
    (See <https://www.w3.org/TR/xml11/>.)

### Other references

[GEDCOM 5.5]
:   The Church of Jesus Christ of Latter-day Saints.
    *The GEDCOM Standard*, release 5.5.  2 Jan 1996, as amended by the
    errata sheet dated 10 Jan 1996.

[GEDCOM 5.5.1]
:   The Church of Jesus Christ of Latter-day Saints.
    *The GEDCOM Standard*, draft release 5.5.1.  2 Oct 1999.

[XSD Pt2]
:   W3C (World Wide Web Consortium). *W3C XML Schema Definition Language 
    (XSD) 1.1 Part 2: Datatypes*.  David Peterson, Shudi Gao (高殊镝),
    Ashok Malhotra, C. M. Sperberg-McQueen and Henry S. Thompson, ed., 2012.
    W3C Recommendation.  (See <https://www.w3.org/TR/xmlschema11-2/>.)

