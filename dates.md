---
title: "Extended Legacy Format (ELF)"
subtitle: Date, Age and Time Microformats
date: 13 December 2018
numbersections: true
...

# Extended Legacy Format (ELF):<br/> Date, Age and Time Microformats

{.ednote ...} This is an **exploratory draft** of the microformats used
for dates, ages and times in FHISO's proposed suite of Extended Legacy Format
(ELF) standards.  This document is not endorsed by the FHISO membership,
and may be updated, replaced or obsoleted by other documents at any
time.

Comments on this draft should be directed to the
[tsc-public@fhiso.org](http://tech.fhiso.org/tsc-public) mailing list.
{/}


FHISO's **Extended Legacy Format** (or **ELF**) is a hierarchical
serialisation format and genealogical data model that is fully
compatible with GEDCOM, but with the addition of a structured
extensibility mechanism.  It also clarifies some ambiguities that were
present in GEDCOM and documents best current practice. 

The **GEDCOM** file format developed by The Church of Jesus Christ of
Latter-day Saints is the *de facto* standard for the exchange of
genealogical data between applications and data providers.  Its most
recent version is GEDCOM 5.5.1 which was produced in 1999, but despite
many technological advances since then, GEDCOM has remained unchanged.

{.note} Strictly, [GEDCOM 5.5] was the last version to be publicly
released back in 1996.  However a draft dated 2 October 1999 of a
proposed [GEDCOM 5.5.1] was made public; it is generally considered to
have the status of a standard and has been widely implemented as such.

FHISO are undertaking a program of work to produce a modernised yet
backward-compatible reformulation of GEDCOM under the name ELF, the new
name having been chosen to avoid confusion with any other updates or
extensions to GEDCOM, or any future use of the term by The Church of
Jesus Christ of Latter-day Saints.  This document is one of three that
form the initial suite of ELF standards, known collectively as ELF 1.0.0:

* **ELF: Serialisation Format**.  This standard defines a
  general-purpose serialisation format based on the GEDCOM data format
  which encodes a *dataset* as a hierarchical series of *lines*, and
  provides low-level facilities such as escaping and extensibility
  mechanisms.

* **ELF: Date, Age and Time Microformats**.  This standard defines
  microformats for representing dates, ages and times in arbitrary calendars,
  together with how they are applied to the Gregorian, Julian, French
  Republican and Hebrew calendars.  These formats are largely identical
  to those used in GEDCOM, but the framework should serve as a basis for
  future work on calendars.

* **ELF: Data Model**.  This standard defines a data model based on the
  lineage-linked GEDCOM form, reformulated in terms of the
  serialisation model described in this document.  It is not a major
  update to the GEDCOM data model, but rather a basis for future
  extension.

## General

### Conventions used

Where this standard gives a specific technical meaning to a word or
phrase, that word or phrase is formatted in bold text in its initial
definition, and in italics when used elsewhere.
The key words **must**, **must not**, **required**, **shall**, 
**shall not**, **should**, **should not**, **recommended**,
**not recommended**, **may** and **optional** in this standard are to be
interpreted as described in
&#x5B;[RFC 2119](https://tools.ietf.org/html/rfc2119)].

An application is **conformant** with this standard if and only if it
obeys all the requirements and prohibitions contained in this
document, as indicated by use of the words *must*, *must not*,
*required*, *shall* and *shall not*, and the relevant parts of its
normative references.  Standards referencing this standard *must not*
loosen any of the requirements and prohibitions made by this standard,
nor place additional requirements or prohibitions on the constructs
defined herein.  

{.note} Derived standards are not allowed to add or remove requirements
or prohibitions on the facilities defined herein so as to preserve
interoperability between applications.  Data generated by one
*conformant* application must always be acceptable to another
*conformant* application, regardless of what additional standards each
may conform to. 

If a *conformant* application encounters data that does not conform to
this standard, it *may* issue a warning or error message, and *may*
terminate processing of the document or data fragment.

This standard depends on FHISO's **Basic Concepts for Genealogical
Standards** standard.  To be *conformant* with this standard, an
application *must* also be *conformant* with [Basic Concepts].  Concepts
defined in that standard are used here without further definition.

{.note} In particular, precise meaning of *character*, *string*,
*whitespace*, *whitespace normalisation*, *term*, *prefix notation*,
*prefix*, *datatype* and *subtype* are given in [Basic Concepts].

Indented text in grey or coloured boxes does not form a normative part
of this standard, and is labelled as either an example or a note.  

{.ednote} Editorial notes, such as this, are used to record outstanding
issues, or points where there is not yet consensus; they will be
resolved and removed for the final standard.  Examples and notes will be
retained in the standard.

The grammar given here uses the form of EBNF notation defined in §6 of
&#x5B;[XML](https://www.w3.org/TR/xml11/)], except that no significance is
attached to the capitalisation of grammar symbols.  *Conforming*
applications *must not* generate data not conforming to the syntax given
here, but non-conforming syntax *may* be accepted and processed by a
*conforming* application in an implementation-defined manner.

This standard uses *prefix notation* when discussing specific *terms*.
The following *prefix* binding is assumed in this standard:

------           -----------------------------------------------
`elf`            `https://terms.fhiso.org/elf/`
`xsd`            `http://www.w3.org/2001/XMLSchema#`
------           -----------------------------------------------

{.note}  The particular *prefix* assigned above have no relevance
outside this standard document as *prefix notation* is not used in the
formal data model defined by this standard.  This notation is simply a
notational convenience to make the standard easier to read.

### Basic time concepts

{.ednote}  It is anticipated that this section will be moved to [Basic
Concepts] in a future draft of these documents.

An **instant** is defined as an infinitesimally brief point in time.  
A **time interval** is defined as the section of time spanning
between two specific *instants*.

{.example}  The interval lasting from midday on 1 Feb 2018 until midday
on 14 Feb 2018 is a *time interval*. 

{.example}  The lifetime of a particular individual is another example
of a *time interval*, beginning at the *instant* of their birth and
ending with the *instant* of their death.

A **duration** is a measure of the length of time elapsing between two
*instants*, but without reference to any specific pair of start and end
*instants*.

{.example} "3 days", and "34 years, 2 months" are two examples of
*durations* expressed in natural language.

{.note} *Durations* differ from *time intervals* in that *time
intervals* are *durations* with specific start and end *instants*.  A
*time inteval* has a *duration* associated with it, quantifying how long
it lasts.

Fundamental to ELF's handling of dates are a set of *time intervals*
called **calendar days**, each of which spans from one midnight until
the next.

{.note} A *calendar day* lasts for 24 hours, except when leap seconds is
inserted or deleted, or when the local time zone changes, as in the
transition to or from daylight saving time. 
In practical terms, it is a period during which the sun rises and sets
exactly once, except in the polar regions.

{.note}  Because midnight does not occur simultaneously around the
world, the set of *calendar days* in one region may be offset compared
to those in another region.  The details vary depending on local
legislation and custom.  Currently, there can be three different
*calendar days* happening simultaneously in various parts of the world:
when a *calendar day* is just beginning in the Line Islands of Kiribati,
it is still the previous *calendar day* in most of world's landmasses,
and the *calendar day* before that in American Samoa.  This means it is
possible for a person to participate in an event on one *calendar day*,
travel to another region, and subsequently participate in an event on
the previous *calendar day*.  If the second event is the person's death,
this could theoretically result in a living person participating in an
event the *calendar day* after their death.

A **date** is a way of identifying a particular *calendar day*.

{.note}  ELF *dates* do not include an indication of either the time zone
or the locale which leaves some ambiguity into the exact points in time
that are meant.  The [ISO 8601] concept of a *date* has the same
ambiguity.

{.note}  The definitions of an *instant*, a *time interval*, a
*duration*, a *calendar day* and a *date* given here are intended to be
fully compatible with the definitions of these concepts in [ISO 8601].
Any incompatibility between the definitions here and those in [ISO 8601]
is unintentional.

{.ednote}  These concepts have been defined here rather than by
normative reference to [ISO 8601] because of the cost involved in
obtaining a legal copy of [ISO 8601], and the likelihood that
implementers will not do so.

Many different systems for reckoning *dates* have been used throughout
history and in different parts of the world. Such systems are called
**calenders**, and ELF allows historical *dates* to be reckoned using
many different *calendars*.

{.example}  The simplest form of *calendar* is to count the number
of *calendar days* which have elapsed since a particular day zero.  The
most popular such *calendar* is called the Julian Day (which is 
unconnected to the similar-sounding Julian Calendar).  Its day zero
is 24 November 4714 BC in the proleptic Gregorian Calendar, a day
chosen to be before all recorded history.  Written as a Julian Day, 1
January 2000 can be represented by the integer 2451545.  Such
*calendars* are not commonly used for writing historical *dates* as they
are cumbersome and error-prone.

{.ednote} Nevertheless, FHISO might consider standardising the Julian
day as a lightweight *calendar* for use as a common intermediate
*calendar* during the conversion of *dates* from one *calendar* to
another.

Many *calendars* make use of units of time which are longer than a
*calendar day*, and the general framework for dates in ELF allows for
two such units of time, a **calendar month** and a **calendar year**,
whose definitions will be dependent on the particular *calendar*.

{.note}  It is intended that a *calendar year* will typically be unit of
time roughly equal to the time it takes the Earth to orbit the Sun, and
a *calendar month* will be a unit of time intermediate in duration between
a *calendar day* and a *calendar year*, and which is often loosely based
on the time it takes the Moon to orbit the Earth.  However these are not
requirements, nor is there a requirement that all *calendar years* or
all *calendar months* be of approximately equal length.

An **epoch** is an *instant* which serves as a reference point for a
given *calendar* from which *calendar years* are numbered consecutively,
running either forwards of backwards in time.

{.example}  The *epoch* used in many forms of the Islamic Calendar is an
*instant* during the Gregorian year AD&nbsp;622, the year of the Hijrah
when Muhammad moved from Mecca to Medina.  The first *calendar year* of
the Islamic *calendar*, called Anno Hegiræ 1 began at this *epoch*, and
subsequent Islamic *calendar years* have been numbered sequentially,
AH&nbsp;2, AH&nbsp;3, etc.  The previous *calendar years* is commonly
labelled 1&nbsp;BH (standing for Before the Hijrah), and earlier
*calendar years* are numbered backwards from the *epoch*.

{.note} This general definition of an *epoch* does not limit a *calendar*
to only having a single *epoch*.

A *calendar* defines how the number of *calendar days* in each *calendar
month* and the number of *calendar months* in each *calendar year* are
determined.  Stylistic and linguistic variations in the presentation of
a *date* do not constitute separate *calendars*.

{.example}  "31st August, 2018", "31 авг. 2018", "8/31/2018" and 
"2018年8月31日" are various ways in which the *date* which is
represented in [ISO 8601] as "`2018-08-31`" might be presented.  The
differences between these presentations are merely stylistic or
linguistic ones, and therefore these difference are not separate
*calendars*:  they are all written using the Gregorian *calendar*.

{.ednote}  In due course, FHISO will need to clarify and perhaps revise
this definition of what constitutes a distinct *calendar*.  Does Roman
day reckoning (e.g. "Prid. Kal. Sept" for 31 Aug) count as a separate
*calendar* or is just a stylistic variation?  What about regnal years
(e.g. "31 Aug 67 Eliz II")?  What about years beginning on the Feast of
the Annunciation (25 March, sometimes called Lady Day)?  These are not
strictly separate *calendars*, but it could be convenient to consider
them as such in ELF if it is considered desirable for ELF to preserve
the fact that the dates were recorded in these forms.

A **time** is a way of identifying an instant within a *calendar day*,
done by dividing an ordinary *calendar day* into 24 **hours**, each of
which is subdivded into 60 **minutes**, each of which is further divided
into 60 **seconds**.

{.note}  A *calendar days* may exceptionally be divided differently if a
leap second is inserted or deleted, or when the local time zone changes.

### Uncertainty

{.ednote}  It is anticipated that this section will be moved to [Basic
Concepts] in a future draft of these documents.

The **precision** of a stated value, such as a *date*, is a measure of
how specificity with which the value has been specified: the more
specifically, the greater the *precision*.  Values with relatively high
or low *precision* may be described as relatively **precise** or
**imprecise**, respectively.

{.example ...}  It is more *precise* to say that the Battle of Agincourt
was on St Crispin's Day, 1415, than it is to say that the battle occured
during Henry V's reign.  Both statements are true, but the former has
greater *precision* because it identifies the specific day of the
battle, while the latter identifies it only as falling within that
nine-year reign.  

Saying the battle was in the autumn of 1415 has an intermediate level of
*precision*.  This year might described as *precise* in comparision to
the whole of Henry V's reign, or as *imprecise* when compared to the
specific day.
{/}

{.note} Values are stated *imprecisely* for many reasons, including when
a more *precise* value is not known and when greater *precision* is
considered irrelevant.  Another reason is when the value being stated is
inherently ambiguous.

When the value being stated is *instant* at which some entity changes
state, it is common for to this *instant* not to be defined with
arbitrary *precision* because there is a *time interval* during the
transition when it is not well-defined what the state is.  The
*duration* of this *time interval* is known as the **inherent
ambiguity** of the *instant* of the change.

{.example}  Depending on the jurisdiction, the *precise* *instant*
during a wedding when the couple become married may be ill-defined as
there are several obvious possibiliies.  It could be argued to occur
when the couple complete their vows, or when the priest declares the
couple husband and wife; or it might be when the last signature is put
on marriage certificate has been completed, or when the ceremony ends.
If there is no single accepted definition, then there is likely several
minutes of *inherent ambiguity* between the first and the last
possibilities.  This would be true even if the wedding had been videoed
and carefully timed, as it is not due to lack of information on what
happened and when.

A stated value is either **exactly stated** or **approximately stated**.
An *exactly stated* value is one where it is well-defined exactly what
values are considered to be consistent with the stated value.

{.example ...}  The *date* of the Battle of Agincourt was stated in
three different ways in the earlier example.  In order of decreasing
*precision* these were "St Crispin's Day, 1415", "the autumn of 1415",
and "during Henry V's reign".  The meaning of St Cripin's Day is
well-defined: it is 25 October.  Had the Battle of Agincourt in fact
occurred on 24 October 1415, for example, this would not be consistent
with the statement that it happened on St Crispin's Day.  "St Crispin's
Day, 1415" is therefore an *exactly stated* value.  "During Henry V's
reign" is similarly *exactly stated*.

"The autumn of 1415" is very likely not well-defined.  Some people
define it as stretching from the autumnal equinox (in late September) to
the winter solstice (in late December), but this definition is by no
means universal.  Often it is used a more vague manner to refer to the
later part of the year in the northern hemisphere.  Unless context makes
it clear that a specific, well-defined meaning of word "autumn" was
intended, this is not an *exactly stated* value: it is therefore an
*approximately stated* value.

The battle might also be described as happening in about 1415.  This
statement is true as the battle did in fact occur in 1415, but it is an
*approximately stated* value.  Had the battle actually been in 1414,
would this be consistent with the description "about 1415"?  Probably.
But what about 1411?  Or 1401?  There is no general answer, and as a
result "about 1415" is an *approximately stated* value.
{/}

{.example}  These concepts do not only apply to quantitative values.  It
is more *precise* to say that a person was born in the commune of
Coutances, than to say say that person was born in metropolitan France.
"The commune of Coutances" and "metropolitan France" are both *exactly
stated* values.  The person might also be described as born in northern
France, which would normally be interpreted as an *approximately stated*
value.

The **precision range** of an exactly stated value is defined as the set
of values which would be considered consistent with the stated value.  
One specific measure of *precision* is the **precision range width**,
which is defined as the difference between the two most widely separated
values in the *precision range*.  When the value being specified is an
*instant*, its *precision range* is a *time interval*, and its
*precision range width* is a *duration*.

{.example}  If a person is said to have died in 1967, this is consistent
with the *instant* of their death being at any time between midnight at
the start of 1 January 1967 and midnight at the end of 31 December 1967.
The *time interval* between these two *instants* is the *precision
range* and is a *calendar year*.  In this example, the stated value is
1967 and its *precison range* is the *duration* 1 year.

{.example}  If a person is said to have married in the 1910s, it is
fairly clear this refers to a decade and therefore the *precision range*
is 10 years.  However if the person was said to have married in the
1900s, this might mean the decade or the century.  Without further
context, the intended *precision range* is unclear.

The **accuracy** of a value is a measure of how close a stated value is
to the true value.  A *exactly stated* value is said to **accurate** if
the true value lies within the *precision range* of the stated value,
and **inaccurate** otherwise.  For an *approximately stated* value,
the *accuracy* is relative: the further the stated value is from the
true value, the less *accurate* or more *inaccurate* the stated value. 

{.note}  The *precision* of a value is unrelated to its *accuracy*.  A
value may be *precise* or *imprecise* independently of whether it is
*accurate* or *inaccurate*.  

{.example ...}  The following table gives example *instants* of birth
for Queen Victoria which are variously *precise* or *imprecise*, and
*accurate* or *inaccurate*. 

-----------  -----------   -----------------------
Precise      Accurate      24 May 1819 at 4am
Precise      Inaccurate    19 Jun 1833 at 9pm
Imprecise    Accurate      During the 1810s
Imprecise    Inaccurate    During the 1790s
-----------  -----------   -----------------------

It is generally accepted that Queen Victoria was in fact born at 4.15am
on 24 May 1819.
{/}

{.note}  In principle, the *accuracy* of any stated value is unknowable,
though in practice some facts are so well established they can be
regarded as proven for all practical purposes as the alternative would
require there to have been a vast conspiracy.  Much of the time the
situation is not so clear.

The likelihood that a stated value is *accurate* is referred to as its
**reliability**.

{.note}  Although this is in theory a probability, *reliabilities* are
usually described comparatively or quantitatively.  A researcher may
gauge the *reliability* of a stated value by considering the reliability
of the sources in which it is stated, and the corroborating or
contradicting evidence.  Different researchers might reasonably reach
different conclusions on the *reliability* of a stated value.

{.note} A stated value can be considered *unreliable* by virtue of being
stated with excessive *precision*.  

{.example ...}  Suppose a man was last seen on 1 January and his corpse
found on 31 January.  The coroner determined the man had been dead for
one to two weeks when found, but that no more *precise* date of death
could be established.  A newspaper obituary simply said he died in
January, but a gravestone was erected giving his date of death as 21
January.  A researcher might conclude the obituary is *reliable* as the
less *precise* "in January" is almost certainly *accurate* as it it
consistent with the other evidence.  The gravestone might be *accurate*
and it is not contradicted by the other evidence, but if the researcher
believes the *date* "21 January" was made up in order to be able to put
something on the grave, it might be judged *unreliable*.

This is not an example of *inherent ambiguity*.  Depending on the
circumstances of the death, there may have been a few minutes of
*inherent ambiguity* as the man's life slowly ebbed away, but the bulk
of the uncertainty is from lack of knowledge of what happened and when.
{/}

### Datatypes

{.ednote}  This whole section may vanish in a future draft, as it is
mainly a place to put the various editorial notes found here.

ELF does not provide a general-purpose *duration* *datatype*, but the
`elf:Age` *datatype* defined in {§age} is a *datatype* customised for
representing the *duration* of a individual's life.

{.ednote ...}  This could be reviewed.  At the moment the `elf:Age`
*datatype* contains both a general-purpose *duration* microformat and
also a small set of qualitative *age* keywords (like `CHILD`) which do
not belong in a general-purpose *duration* type, and prevent `elf:Age`
from being that.  In principle, a more general *duration* type could be
made a *subtype* of `elf:Age`, but this would introduce an awkward
dependency on the more special-purpose `elf:Age` *datatype*.  

Another option is to remove the `elf:Age` *datatype* and replace it with
two separate *datatypes*: a general-purpose `elf:Duration` *datatype*
and a special `elf:AgeWord` *datatype* for qualitative *age* keywords.
The various ELF structures having an `elf:Age` *payload* would then be
changed to have *payloads* which were a *union of datatypes*.  This
introduces several technical complications, including the need make
*datatype correction* work with multiple *default datatypes*.  In
principle this works fine when the *default datatypes* have disjoint
*lexical spaces*, as they would here, but it would need careful
specification.
{/}

The use of these *datatypes* other than with ELF is *not recommended*.

{.ednote ...} In due course we need to decide FHISO's preferred way of
handling *dates* and *durations* in other serialisation formats.  GEDCOM
X, for example, uses a format more closely based on [ISO 8601], and in
early discussion on *dates* and in the call for paper submissions, we
were erring in that direction too.  

If we end up with one *date* format for ELF, another for GEDCOM X, and
possibly even a third one for a future format of our own, we will want
to make sure we don't end up with *dates* formatted for GEDCOM X
appearing in ELF, or vice versa, otherwise an ELF application will need
to know about every *date* format.  At some level, this requires
converting *dates* between formats when data containing *dates* moves
between systems.  For data in the [ELF Data Model] or in the GEDCOM X
data model, this is no problem as a data conversion stage will be
required when converting between data models, and it can convert the
*date* formats too.

The problem arises with data in the data model of one of FHISO's
component standards, like [CEV Concepts], which is intended to be usable
in ELF, GEDCOM X and other data models.  An ELF application will not
necessarily know about CEV, so there needs to some way of indicating
that the ELF *structure* it is reading contains a *date*.  The could be
done by requiring an ELF schema to be present, though that might be too
onerous a requirement, or by requiring a specific tag like `DATE` to be
used.  The same issue may exist for *ages* too, but it is not general to
all *datatypes* &mdash; just those which have to be formatted
differently in different serialisations, which will hopefully be a
minority of *datatypes*.

On a technical level, we need to decide how to model the fact that
*dates* are formatted differently in (at least) ELF and GEDCOM X in the
system of *datatypes* developed in [Basic Concepts].  One option is to
have a separate set of *datatypes* for ELF, for GEDCOM X, and so on.
That's technically straightforward and is the approach taken here, but
because each *calendar* has its own *datatype*, this may require many
additional *datatypes* to duplicate each *calendar* in each
serialisation format. 
{/}


## The `elf:Age` datatype {#age}

The **age** of a living individual is defined as the *duration* which
has elapsed since the *instant* of their birth.  

{.note}  It is normal to stop counting *age* at the *instant* of an
individual's death, therefore an *age* given for a posthumous event such
as a burial is likely to be the *age* of the person when they died, i.e.
the *duration* of the *time interval* from birth to death, rather than
from birth to burial.

The `elf:Age` *datatype* is used to represent *ages* in ELF, which it
does by recording number of *calendar years*, *calendar months* and
*calendar days* to have elapsed during the *duration*.

The *lexical space* of this *datatype* is the set of *strings*
which match the following `Age` production:

    Age      ::= ( [<>] S? )? ( Duration | BareYear ) | AgeWord

    Duration ::= [0-9]+ | [0-9]+ "y" ( S? [0-9]+ "m" )? ( S? [0-9]+ "d")?
                 | [0-9]+ "m" ( S? [0-9]+ "d" )? | [0-9]+ "d"
    BareYear ::= [0-9]+
    AgeWord  ::= "CHILD" | "INFANT" | "STILLBORN"

{.note}  These productions are case-sensitive, so the *string* "`17y`"
matches the `Duration` production, while "`17Y`" does not.

The `S` production is the *whitespace* production defined in §2 of
[Basic Concepts] and matches any non-empty sequence of *whitespace*
*characters*.  

{.note}  Because the `elf:Age` *datatype* is currently only used in ELF
in contexts where *whitespace normalisation* has been carried out, the
`S` production will only ever match exactly one space *character*.

A *conformant* application serialising an *age* using this *datatype*
*should* use a single space *character* (U+0020) wherever *whitespace* is
permitted in the `Age` production.

{.note}  [GEDCOM 5.5.1] under-specifies how *whitespace* is allowed in
*ages*.  The `Age` production is permissive in its treatment of
*whitespace*, including allowing it to be omitted entirely.  The
preceding recommendation ensures that *conformant* ELF applications will
be maximally compliant with current GEDCOM application which typically
use a single space *character*.

An *age* which uses the `elf:Age` *datatype* *shall* either consist of a
quantitative *duration* conforming to the `Duration` or `BareYear`
productions, or an qualitative *age* keyword conforming to the `AgeWord`
production.

When an *age* is a quantitative *duration* matching the `Duration`
production, it *shall* contain of one, two or three integers, each
followed by a "`y`", "`m`" or "`d`" suffix to denote a number of
*calendar years*, *calendar months* or *calendar days*, respectively,
the sum of which is the *age*.

{.example} The *age* "`15y 2m`" represents a *duration* of 15 years and
2 months.  

If there is only a number of *calendar years* present, the `BareYear`
production allows the "`y`" suffix to be omitted, though this is 
*not recommended*.

{.example} The *age* "`42y`" only specifies a number of *calendar years*
and so can be written "`42`" without the "`y`" suffix.  The *age* "`15y
2m`" *must not* be written "`15 2m`" as this *duration* includes both a
number of *calendar years* and *calendar months*.

{.note ...} Allowing the "`y`" suffix to be omitted as shown in the
`Duration` production is a change from [GEDCOM 5.5.1] where it was
*required*.  This has been relaxed because GEDCOM files fairly commonly
contain lines like the following, despite them being illegal:

    2 AGE 58
{/}

An *age* which is written including a (possibly zero) number of
*calendar days* *may* be assumed to have a *precision* of a few
*calendar days*; an *age* which includes a (possibly zero) number of
*calendar months*, but no explicit number of *calendar days*, *may* be
assumed to have a *precision* of a few *calendar months*; an *age*
containing only a number of *calendar years* *may* be assumed to have a
*precision* of a few *calendar years*.

{.example ...}  The *age* "`40y`" *may* be assumed to have a *precision*
of a few years.  The actual *precision* will depend on context.  In many
situations the *precision* will be exactly one year, and so assuming the
*age* has been given correctly, the individual was born at least 40
years ago but not as long as 41 years ago.  

At other times, a lower *precision* may apply.  For example, on the 1841
census of Britain, adults were asked to round their *age* down to the
previous multiple of five years.  In such a context, an *age* of "`40y`"
means the individual was born at least 40 years ago but not as long
as 45 years ago.  As ELF does not provide a means of stating a range of
years in an *age*, nor of explicitly stating the *precision*, an *age*
recorded as "40" on the 1841 census *should* be encoded in ELF as
"`40y`".
{/}

The precise meaning of an *age* which is quantitative *duration* is
dependent on context, cultural considerations and the *calendar* in use.

{.example}  The previous example gave an example of how the
interpretation of "`40y`" depended on context, due to different
*precisions*.

{.example}  An elderly person reckoning their age using the Islamic 
calendar could consider their age in years to be several years greater 
than if they were reckoning their age using the Gregorian calendar
because the Islamic *calendar year* is around 11 *calendar days* shorter
than the Gregorian *calendar year*.  ELF does not provide a means of
specifying which *calendar* was when recording an *age*.

*Ages* *should* generally be rounded down when expressed using just a
number of *calendar years*, or using a number *calendar years* and
*calendar months*, but an application *should not* assume this is
necessarily the case without additional information.

*Ages* which are quantitative *durations* *may* be prefixed with with a
"`<`" or a "`>`".  These are interpreted as meaning the individual is
at most the specified *age*, or is at least the specified *age*,
respectively.

{.note ...} This means the "`<`" and "`>`" token are actually interpretted
as ≤ and ≥ operators.  In common usage, a person may be said to over 21
as soon as they've had their 21st birthday, at which point they would
normally round their age down to 21.  ELF allows for this usage, and "`>
21y`" may be used to refer to someone whose *age* is exactly 21.  This
may seem to be a deviation from [GEDCOM 5.5.1] which defines them as
meaning less than or greater than the specified *age*, respectively, but
because of the uncertainty in the intended *precision* of an *age*,
there is little practical difference.  

The case for interpreting "`<`" as less than or equal to is weaker,
but there seem to current examples where "`<`" has been used on *ages*
inferred from an *age* given a few months later.
{/}  

{.example} If a source gives an individual's *age* as 52 in
March, their *age* might be inferred to be "`< 52y`" the preceeding
January.  In practice they might be 51 or 52, asuming the source is
*accurate*.  However, it is normally best not to infer *ages* and only
to record *ages* when they are given in sources.

Instead of a quantitative *duration*, an *age* *may* be expressed
qualitatively using an **age word** which matches the `AgeWord`
production.  This standard defines three *age words*: `CHILD`, `INFANT`
and `STILLBORN`.  These *should* be used when a source describes an
individual as a child, an infant, or stillborn, respectively, or
in using other words which are largely equivalent.  They *should not* be
used when a source describes an individual using a quantitative *age*.  

{.note}  The meanings of words "child", "infant" and "stillborn" are to
some extent culturally dependent.  A modern source might describe a
15-year-old as a child, while in mediæval times they a person of this
age was unlikely to be described in that way.  This standard does not
therefore put firm limits on the *ages* meant by these terms.  This is a
deviation from [GEDCOM 5.5.1] which states that a child is less than 8
years old, an infant is less than 1 year old, and a stillborn invididual
is approximately 0 days old.  Nevertheless, these ages may be useful in
deciding whether a foreign word or phrase can reasonably be translated
as one of these word.

The *age word* `STILLBORN` is not only a statement of *age* but also
conveys the fact that the individual died just prior to, at, or
immediately after the time of birth.  This *age word* *must not* be used
to refer to infants whose *age* is about 0 days unless they died around
the time of birth.

A *conformant* application *may* remove any leading zeros preceding a
non-zero digit, change how *whitespace* is used in an *age*, or append
any omitted "`y`" suffix, but *must not* otherwise alter the *age*.
In particular, applications *must not* insert or remove zero components,
nor convert between days, months and years.  

{.example} "`2y 0m`", "`2y`" and "`24m`" are all distinct *ages* and
applications *must not* rewrite one to another, however an *conformant*
application *may* convert "`2`" to "`2y`", and *may* also convert
"`2y0m`" to "`2y 0m`".

Formally, the `elf:Age` *datatype* is a *structured non-language-tagged
datatype* which has the following *properties*:

: Datatype definition

------           -----------------------------------------------
Name             `https://terms.fhiso.org/elf/Age`
Type             `http://www.w3.org/2000/01/rdf-schema#Datatype`
Pattern          `([<>][ \t\r\n]*)?([0-9]+|[0-9]+y([ \t\r\n]*[0-9]+m)?`
                 `([ \t\r\n]*[0-9]+d)?|[0-9]+m([ \t\r\n]*[0-9]+d)?|[0-9]+d)`
                 `|CHILD|INFANT|STILLBORN`
Supertype        *No non-trivial supertypes*
Abstract         `false`
------           -----------------------------------------------

{.note} The *pattern* in the table above has been split on to three
lines for convenience of presentation; it is, however, really one
*pattern* and contains no *whitespace* or line breaks.
Any functional difference between the `Age` production and the *pattern*
specified above is unintentional.

## Date formats 

ELF uses three different *datatypes* to represent *dates*, depending on
the context.

* `elf:DateValue` is used for historical *dates*.
* `elf:DatePeriod` is used to record the range of *dates* in a source.
* `elf:DateExact` is used to record the creation or modification *date* 
  of various objects in the data model.

{.ednote}  We may want to split `elf:DateValue` into two separate
*datatypes*: one for historical dates which *may* be periods and those
which *must not* be.

As the first two of these *datatypes* are used to record historical
*dates*, and ELF allows historical *dates* to be expresssed using many
different *calendars*, these two *datatypes* each allow *dates* in
arbitrary *calendars*.  This is achieved by providing a generic *date*
syntax which all *dates* *must* match, regardless of *calendar*, and
which begins with a *calendar escape* indicating the specific *calendar*
in use.  

{.ednote ...} An exarlier draft of this standard used a separate
*datatype* for each *calendar*, and used `@#D`&hellip;`@` escapes as a
serialisation layer means of tagging the *datatype*.  This approach was
eventually abandoned because it could not cope with *date ranges* and
*date periods* where the two end points are expressed using different
*calendars*.  [GEDCOM 5.5.1] permits this, and although many
applications do not support it, we considered there to be important use

    0 INDI
    1 NAME George II
    1 TITL King of Great Britain
    2 DATE FROM @#DJULIAN@ 11 JUN 1727 TO @#DGREGORIAN@ 25 OCT 1760

What should the *datatype* of the `DATE` element's payload be?  It's
neither wholly Julian nor wholly Gregorian.  Because of the difficulties
with such constructs, we dropped the idea of making each *calendar* a
separate *datatype*.

One option for solving this which the TSC seriously considered is to
introduce **compound calendars**, along the lines of the proposal in
[CFPS 38](https://tech.fhiso.org/cfps/files/cfps38.pdf), but this adds
complexity due to the need to add a mechanism for defining *compound
calendars*.

A separate complication comes from the fact that there `elf:DateValue`
and `elf:DatePeriod` are separate *datatypes*, and *calendar*-specific
*subtypes* of each would likely be required.  This could be solved by
removing periods from the data model entirely, perhaps by having the
serialisation layer split up `DATE` tags containing a period.  This may
make sense at a date model level too, if we model periods as two
implicit events: one intiating and one concluding the period being
discussed.  There is less of a case for doing the same wtih ranges, so a
solution to the problem of ranges with multiple calendars would still be
required.

The TSC believe an approach along these lines could be made to work, but
it would be too big a change to include in ELF 1.0.  We also feel we
should investigate alternative approaches before committing to a
specific solution.  Deferring this functionality until a future version
of ELF will give us time to do give suitable consideration to the
options available.
{/}

### Generic date syntax

A *date* is represented in the generic *date* syntax as a sequence of five
components: a *calendar escape*, followed by encodings of the *calendar
day*, *calendar month*, *calendar year* and *epoch*.  Only the *calendar
year* is *required*; the other components are *optional*, except that
the *calendar day* cannot be omitted unless the *calendar month* is
also omitted.  It matches the `Date` production.

    Date   ::= (CalEsc S)? ((Day S)? Month S)? Year (S? Epoch)?

    CalEsc ::= "@#D" [A-Z] [A-Z ]* "@"
    Day    ::= [0-9] [A-Z0-9]*
    Month  ::= [A-Z] [A-Z0-9] [A-Z0-9]+
    Year   ::= [0-9]+ ( "/" [0-9]+ )?
    Epoch  ::= [A-Z] ( [A-Z] | [A-Z0-9._]* [._] [A-Z0-9._]* )

{.example ...}  The following are examples of *dates* which match the
`Date` production:

    63 B.C.
    21 JAN 1793
    @#DJULIAN@ 29 MAY 1453

The first of these includes only a *calendar year* and *epoch*.  The
following two both have a *calendar day*, *calendar month* and *calendar
year*, and neither specifies an *epoch*; only the third date includes a
*calendar escape*.
{/}

A *conformant* application serialising a *date* using this syntax
*should* use a single space *character* (U+0020) wherever *whitespace*
is permitted in the `Date` production, and *should not* omit the
*whitespace* before the *epoch* component.

{.note}  [GEDCOM 5.5.1] under-specifies how *whitespace* is allowed in
*dates*.  The `Date` production is somewhat permissive in its treatment of
*whitespace*, though does not allow it to be omitted entirely.  The
preceding recommendation ensures that *conformant* ELF applications will
be maximally compliant with current GEDCOM application which typically
use a single space *character*.

#### Calendar escapes

The `CaleEsc` production encodes the **calendar escape**, which
identifies the particular *calendar* being used in the *date*.

{.note}  Syntactically, the *calendar escape* is an ELF escape, as
defined §XX of [ELF Serialisation].  When such escapes occur in the
payload of a `DATE` line, they are passed through to the data model
unaltered.

{.ednote}  Check the above is true once [ELF Serialisation] has been
updated.  Note that this means historical dates *must* appear on `DATE`
lines.

The following *calendar escapes* are defined in {§calendars} of this
standard.

----------------    -------------------------------------------------
`@#DGREGORIAN@`     The Gregorian *calendar* defined in {§gregorian}
`@#DJULIAN@`        The Julian *calendar* defined in {§julian}
`@#DHEBREW@`        The Hebrew *calendar* defined in {§hebrew}
`@#DFRENCH R@`      The French Republican *calendar* defined in {§french}
----------------    -------------------------------------------------

{.note}  [GEDCOM 5.5.1] includes one further *calendar escape*,
`@#ROMAN@`, which it reserved for future use, presumably for use with
Roman Republican *calendar*.  This standard does not reserve this
*calendar escape*.

The `@#DUNKNOWN@` *calendar escape* is permanently reserved.  Third
parties *must not* define calendars with this name and applications
*should not* generate *dates* using this *calendar escape*.

Third parties *may* define their own *calendar escapes* in order to
support additional *calendars*.  Parties doing this *should* provide a
publicly accessible definition of the *calendar* represented by the
*calendar escape*.

{.note}  This version of ELF provides no means of avoiding conflict
between separate third-party *calendar escapes*.  This is particularly
problematic when there a several variants of a calendar, and if
different vendors choose to implement a different variant using the same
*calendar escape*.  FHISO intend to introduce a mechanism to avoid such
conflicts in a future version of ELF.  This is likely to work by
assigning a *term* to each *calendar*, and a syntax for binding
*calendar escapes* to *term name* IRIs.

{.ednote ...}  This functionality was dropped from ELF 1.0 because the
specification proved more complicated than expected.  The intention is
to add *calendar* bindings to the ELF schema, such as this:

    1 SCHMA
    2 PRFX elf https://terms.fhiso.org/elf/
    2 IRI elf:JulianCalendar
    3 DTYPE JULIAN

Because *dates* are likely to copied around, once in the data model the
*date* needs to reference the *calendar* *term name* rather than the
*calendar escape*.  This means the serialisation layer needs to convert
*calendar escapes* to *term names*, and vice versa.  Finding a clean
way of doing this proved problematic.

The TSC had been considering making *calendars* a specific sort of
*datatype*, and then have the serialisation layer treat the *calendar
escape* as way of tagging the *datatype* of the `DATE` tag's payload.
However, as noted in an earlier editorial note, this caused problems
with periods and ranges which used multiple *calendars*, and has been
deferred to a later version of ELF.  
{/}

This generic *date* syntax defines only some basic syntactic constraints
on the representation of the *calendar day*, *calendar month*, *calendar
year* and *epoch* components.  The party defining each *calendar*
*should* define further constraints on these components to define what
constitutes a **well-formed** *date* in that *calendar*.  Where possible,
the set of *well-formed* *dates* *should* be the same as the set of *dates*
that actually existed.

{.example}  The *date* "`12 AUGUST 2000`" is not a *well-formed* *date* in
the Gregorian calendar, as defined in {§gregorian}, because the
specified month, "`AUGUST`", is not one of the twelve allowed months
names: it shoud have been written "`12 AUG 2000`".

{.example}  The *date* "`29 FEB 1973`" is not a *well-formed* *date* in
the Gregorian calendar, because February 1973 only had 28 days.

{.note} This standard does not prohibit *calendars* from defining *dates*
which never occurred to be *well-formed*, though this is generally *not
recommended*.  It is allowed to accommodate *calendars* where the exact
sequence of *dates* is either unknown or cannot be determined
algorithmically.  

{.example}  Certain versions of the Islamic *calendar* define the start
of each *calendar month* by when the new moon is actually observed.
This results in unpredictable month lengths.  If such a *calendar* were
defined for use in ELF, it would likely regard days beyond the expected
end of the month as *well-formed* *dates* to accommodate the possibility
that bad weather had prevented the new moon from being observed.

All *dates* written using a *calendar escape* with which the application
is not familiar are assumed to be *well-formed*.  This includes all
*dates* using the `@#DUNKNOWN@` *calendar escape*.

*Conformant* applications *must not* generate *dates* which are not
*well-formed*, and which are not assumed to be *well-formed* by virtue
of using a unknown *calendar escape*.  Applications encountering *dates*
which are not *well-formed* *may* delete the *date* or signal an error
to the user.

The *calendar escape* is *optional* in the generic *date* syntax.  If the
*calendar escape* is omitted and if the *date* if *well-formed* in the
Gregorian *calendar*, then the *date* is treated as if it used the
`@#DGREGORIAN@` *calendar escape*.  If the *calendar escape* is
otherwise omitted, the *date* is treated as if it used the `@#DUNKNOWN@`
*calendar escape*.

{.note}  [GEDCOM 5.5.1] simply says that *dates* written without a
*calendar escape* default to the Gregorian calendar.  ELF's approach is
more nuanced.  If a *date* explicitly uses the Gregorian
*calendar escape* then an invalid *date* *may* be deleted; if it is
written without a *calendar escape* then it *must not* be, assuming it
conforms to the generic *date* syntax.  ELF deviates from [GEDCOM 5.5.1]
in this regard because many current applications fail to include a
*calendar escape* when the Julian *calendar* is used.  As a result,
*dates* like "`29 FEB 1700`" can be found written without a *calendar
escape*.  This date did not exist in the Gregorian calendar and
is not a *well-formed date* in that *calendar*, however this rule
prevents applications from deleting it as invalid.

It is *recommended* that, where possible, dates should be entered in ELF
datasets using the calendar in which they were written in the source.

{.example}  A contemporary record of an event occurring in seventeenth
century Massachusetts would almost certainly be recoded using the Julian
calendar, as Massachusetts, like all the British colonies, did not adopt
the Gregorian calendar until 1752.  The date of the event *should*
therefore be recorded in ELF using the Julian calendar and not converted
to the Gregorian calendar.

#### Days

The `Day` production encodes the *calendar day* component of the *date*.
Although only the first *character* is *required* to be a decimal digit,
*calendars* *should* normally make this component an integer, counting
how many *calendar days* into the *calendar month* the specified
*calendar day* is, with the first *calendar day* being "`1`".
*Calendars* *should* normally permit leading zeros and attach no
signifince to them.

{.ednote}  It is unclear whether the flexibility to have a non-integer
*calendar day* component will be needed.  If we're comfortable it will
not be needed, we should make it simply an integer.  The motivation for
allowing non-integer *calendar day* components came from consideration
of Roman day reckoning.  In this system, days are reckoned backwards
from the kalends, nones and ides of each month.  For example, the day
described as "ante diem quintum kalendas Septembres" or "a.d. V Kal.
Sept", meaning five days before the kalends of September (1 Sept),
counting inclusively, is 28 August.  If this were considered a separate
*calendar*, it could be represented as "`5K SEP`".

#### Months

The `Month` production encodes the *calendar month* component of the
*date*.  The set of permitted *calendar month* components in a given
*calendar* is called the set of **month names** for the *calendar*. 
*Month names* *should* normally be abbreviated forms of their common
names, and *must* be at least three *characters* long.

{.example}  The French Republican *calendar* has twelve months named
Vendémiaire, Brumaire, Frimaire, Nivôse, Pluviôse, Ventôse, Germinal,
Floréal, Prairial, Messidor, Thermidor and Fructidor.  If ELF, as
described in {§french}, these are abbreviated `VEND`, `BRUM`, `FRIM`,
`NIVO`, `PLUV`, `VENT`, `GERM`, `FLOR`, `PRAI`, `MESS`, `THER` and
`FRUC`.  In addition, each year had five or six consecutive intercalary
days, or jours complémentaires, which were not part of any month.  For
the purposes of representing this calendar in ELF, the intercalary days
are considered a thirteenth month, `COMP`.

{.note} *Month names* are always upper-case, a constraint guaranteed by
the `Month` production.  Lower-case, mixed-case, or non-ASCII *month
names* *must not* be used.

{.note}  *Month names* are *required* to be at least three *characters*
long to avoid conflicting with *epoch* names.

The following words are reserved and *must not* be used as *month
names* in any calendar: `ABT`, `AFT`, `AND`, `BEF`, `BET`, `CAL`, `EST`,
`EVERY`, `FOR`, `FROM`, `INT`, `POS`, `REP`, `TIME`, `UNCERT`, `UNK` and
`ZONE`.

{.note}  Many of these words have specific meanings in the ELF *date*
*datatypes*.  The words `EVERY`, `FOR`, `POS`, `REP`, `TIME`, `UNCERT`,
`UNK` and `ZONE` are reserved for possible future use because they
describe concepts in [GEDCOM X Dates] or [ISO 8601-2] which are
not currently in ELF.  This does not necessarily mean FHISO will add
such functionality to a future version of ELF.

#### Years

The `Year` production encodes the *calendar year* component of the
*date*.  The *string* matching this production *shall* be a non-negative
integer, which *may* be followed by a solidus (U+002F) and another
non-negative integer.  A *calendar year* component with two integers is
called a **dual year**, and is used when the historical reckoning of
years does not completely match the modern reckoning of years.  The year
number according to the historical reckoning is called the **historical
year**, while the year number according to the modern reckoning is called
the **logical year**.  The first integer in a *dual year* is the
*historical year*; the second integer is the *logical year* which *may*
be given in abbreviated form.  When the *calendar year* component is not
a *dual year*, the *historical year* and *logical year* are both equal
to the one integer given.

{.example}  The principal use of *dual years* is to encode *dates* which
were recorded using years beginning on 25 March (the Feast of the
Annunciation, also known as Lady Day), as was the practice in many
parts of the world before the adoption of the Gregorian calendar.
Contemporary sources record the execution Charles I as happening on 30
January 1648.  This was the month following December 1648 and would now
be reckoned in 1649, as a result of which modern accounts usually
describe it as happening on 30 January 1649.  (This is not a result a
change of the Julian calendar to the Gregorian one: in the Gregorian
calendar this *date* would be 9 February 1649.)  To avoid ambiguity, the
year can be written 1648/1649.  ELF supports this and allows the *date*
to be recorded as “`30 JAN 1648/1649`”.

The *dual year* syntax is only used when there are genuine differences
in the conventional reckoning of years.  It *must not* be used simply to
record an error in the year in a source.

{.example}  If a parish register includes a baptism entry dated 12 Jan
1842, but the context and other circumstantial evidence makes it clear
that the year was incorrectly written in the register and was in fact
1845, this *must not* be recorded in ELF as "`12 JAN 1842/1845`".

The *logical year* *may* be abbreviated to just the last two digits
if the difference between the *historical year* and the *logical year*
is less than 10 years, or *may* be abbreviated to just the last one
digit if the difference between the *historical year* and the *logical
year* is no more than 1 year.  Where possible, the *logical year*
*should* be abbreviated to two digits.

{.example}  The *date* in the previous example *may* be written in
abbreviated form as "`30 JAN 1648/49`" or as "`30 JAN 1648/9`".

{.note}  An application reading an abbreviated *dual year* should round
the *historical date* to the nearest 10 or 100 years, depending on
whether the *logical year* has been abbreviated to one or two digits,
respectively, and then prepend the leading digits from the rounded
*historical date* to the abbreviated *logical date* to produce the
unabbreviated *logical date*.

When abbreviated form is not used, the *historical year* and the
*logical year* *must* be written using the same number of digits, even
if this means padding one integer with leading zeros.

{.note}  This restriction exists to prevent any uncertainty determining
whether a *dual year* has been abbreviated.

A specific *calendar* *should* normally place further restrictions on
how *dual years* can be used.

{.note} This is necessary if applications are to have understanding of
what the *historical date* means.  A *date* of "`@#DJULIAN@ 1740/1620`"
is perfectly well-defined insofar that it represents the Julian year
A.D.&nbps;1620 and which for some reason was conventionally recorded as
1740 at the time, but without understanding of why this was done, it is
difficult for an application to know what to do with this information.
In fact, the Julian calendar defined in {§julian} only allows *dual
years* when the *historical date* and *logical date* differ by exactly
one year.

The *calendar* *may* define further restrictions on the range of
integers permitted as *logical years* or *historical years*.

{.note ...}  [GEDCOM 5.5.1] includes support for *dual dates*, though
only with *dates* in the Gregorian *calendar*, which is unfortunate as
its principal use is with *dates* in the Julian *calendar* and the
example it gives is seemingy in the Julian *calendar*.  Nevertheless,
many applications do implement *dual date* support.  In [GEDCOM 5.5.1],
*dual dates* *must* be written in abbreviated form with the *logical
year* shortened to two years.  ELF relaxes this restriction as *dual
dates* are commonly found unabbreviated or with a single-digit *logical
date*.

*Dual dates* in [GEDCOM 5.5.1] were probably only intended for years
beginning on Lady Day, though the standard does not explicitly say so;
however the same facility readily accommodates years beginning on
arbitrary days, and some applications implement this.  ELF generalises
this further by allowing the *historical year* and *logical year* to
differ arbitrarily.
{/}

#### Epochs

The `Epoch` production encodes the *epoch* component of the *date*,
which specifies both the particular *epoch* from which *calendar years*
and the direction of the numbering.  The set of permitted *epoch*
components in a given *calendar* is called the set of **epoch names**
for the *calendar*.

{.example}  The Julian *calendar* defined in {§julian} includes the
*epoch names* "`B.C.`" and "`A.D.`", standing for Before Christ and Anno
Domini, respectively.  Both *epoch names* state that *calendar years*
are counted from an *epoch* on the Julian date 1 January A.D.&nbsp;1,
nominally the date for the birth of Jesus Christ, but for "`B.C.`"
*calendar years* are counted backwards from that *epoch*, while for
"`A.D." *calendar years* are counted forwards.

An *epoch name* from which *calendar years* are counted forwards is
called a **forwards epoch name**, while an *epoch name* from which
*calendar years* are counted backwards is called a **reverse epoch
name**.  *Calendar years* are numbered consecutively from the *epoch*
represented by the *epoch name*.  For a *forwards epoch name*, the
*epoch* *shall* be first *instant* of the *calendar year* identified by
the *logical year* number 1.  For a *reverse epoch name*, the *epoch*
*shall* be the last *instant* of the *calendar year* identified by the
*logical year* number 1.

The `Epoch` production requires *epoch names* either to be exactly two
*characters* long, or to include at least one full stop (U+002E) or
underscore (U+005F).  

{.note}  This ensure that no *month name* is syntactically allowed as an
*epoch name*, or vice versa.  This ensures that a *string* containing
just a *day* and *month*, such as "`1 JAN`", cannot match the `Date`
production.  A future version of ELF may allow the year to be omitted
in *dates* when it is unknown, in which case this rule ensures there
will be no ambiguity.

They *should* normally be an acronym or initialism with full stops
between letters.  The two-letter form of *epoch names* is deprecated.

{.note} Two-letter *epoch names* without full stops are allowed by the
`Epoch` production because "`BC`" is found in some current GEDCOM files,
even though [GEDCOM 5.5.1] requires it to be spelled "`B.C.`".

The words "`TO`" and "`AT`" are reserved and *must not* be used as
*epoch names* in any *calendar*.

{.note}  The word "`AT`" is included here for future compatibility.

If a *calendar* defines multiple *epoch names* for the same *epoch*, and
which are either all *forwards epoch names* or all *reverse epoch
names*, applications *should* treat those *epoch names* as interchangeable.

{.example}  The Julian calendar defined in {§julian} defines the
"`B.C.`" and "`BC`" *epoch names* identically.  The former is the
preferred form and is the only form allowed in [GEDCOM 5.5.1], however
the latter is also found in current use, and ELF supports it.

A *calendar* *may* require an *epoch name* to be present, *may* allow it
to be omitted, and *may* define no *epoch names* thereby requiring it to
be omitted.  In calendars where the *epoch name* is *optional*, the
*calendar* *should* define an explicit *epoch name* that is equivalent
to an omitted *epoch name*.  This *epoch name* is called the **default
epoch name** for the calendar.

{.example}  The Julian calendar defined in {§julian} provides the
"`A.D.`" *epoch name* to serve as its *default epoch name*.

{.ednote}  This specification of *epoch names* is designed to be usable
to implement regnal years.  In such a scheme, the *instant* of
accession of each monarch would be an *epoch*, and a *forwards epoch
name* would be used to reference it, for example "`25 OCT 3 HENRY_V`".
To accommodate monarachs without a regnal number, we might want to allow
an additional *character* which could serve as a sigil for epoch names,
and then allow arbitrary characters, e.g. "`$昭和`" for the Shōwa
period in Japan.

### The `elf:Date` datatype  {#date-datatype}

In ELF, *dates* are represented using the `elf:Date` *datatype*, which
allows 

Dates are represented using a somewhat involved syntax with three entry points, documented below.

{.ednote ...} The following is the EBNF for date payloads, but it lacks semantics

    Date    ::= greg | juln | hebr | fren | future

    Exact   ::= [1-9] [0-9]? month year_g

    Value   ::= Date | Period | range | approx
                | ( "INT" Date )? "(" String ")"

    Period  ::= "FROM" Date ( "TO" Date )? | "TO" Date

    approx  ::= ( "ABT" | "CAL" | "EST" ) Date
    range   ::= ( "BEF" | "AFT" ) Date | "BET" Date "AND" Date
    
    greg    ::= ("@#DGREGORIAN@" #x20)? d_greg
    juln    ::= "@#DJULIAN@" #x20 d_juln
    hebr    ::= "@#DHEBREW@" #x20 d_hebr
    fren    ::= "@#DFRENCH R@" #x20 d_fren
    future  ::= "@#D" ( "ROMAN" | "UNKNOWN" ) "@" #x20 String
    
    d_fren  ::= ( ( [1-9] [0-9]? )? month_f )? year
    d_greg  ::= ( ( [1-9] [0-9]? )? month )? year_g
    d_hebr  ::= ( ( [1-9] [0-9]? )? month_h )? year
    d_juln  ::= ( ( [1-9] [0-9]? )? month )? year
    
    year_g  ::= [1-9] [0-9]* ( "/" [0-9] [0-9] )? "(B.C.)"?
    year    ::= [1-9] [0-9]* "(B.C.)"?
    
    month   ::= "JAN" | "FEB" | "MAR" | "APR" | "M‌AY" | "JUN"
                | "JUL" | "AUG" | "SEP" | "OCT" | "NOV" | "DEC"

    month_f ::= "VEND" | "BRUM" | "FRIM" | "NIVO" | "PLUV" | "VENT" | "GERM"
                | "FLOR" | "PRAI" | "MESS" | "THER" | "FRUC" | "COMP"

    month_h ::= "TSH" | "CSH" | "KSL" | "TVT" | "SHV" | "ADR" | "ADS"
                | "NSN" | "IYR" | "SVN" | "TMZ" | "AAV" | "ELL"
    
{/}

### Date {#date-format}

At the core of the date syntax is a calendared date.
This consists of an optional *calendar escape* followed by the content of the date.

The *calendar escape* is a substring beginning `@#D` and ending `@`, between which is a calendar identifier; known calendar identifiers are `GREGORIAN`, `FRENCH R`, `HEBREW`, `JULIAN`, `ROMAN`, and `UNKNOWN`.
If no calendar escape is given, `GREGORIAN` is assumed.

{.ednote} Should we move the escape syntax to [ELF-Serialization] and change the above to describe an abstract notion of "an escape"?

{.note} Some dates (in particular the [Period](#date-period) and [Value](#date-value) productions) may have multiple [Date](#date-format) values; it is not known if current implementations can handle situations where the dates are from different calendars, nor if they assume an uncalendared date paired with a calendared date is `GREGORIAN` or the same as the other date provided.  It is RECOMMENDED that the same calendar be used for both Dates in such payloads.

The `ROMAN` and `UNKNOWN` calendars's date formats are not defined in this specification.

`GREGORIAN`, `FRENCH R`, `HEBREW`, and `JULIAN` dates all have the format "day month year", separated by spaces; the day may be omitted; if the day is omitted, the month may be omitted as well.
The three pieces are formatted as follows:
    
day
:   A decimal number of one or two digits.
    This SHOULD NOT be zero or greater than the number of days in the appropriate month.
    This specification does not specify whether single-digit days should begin with a zero or not.

{.ednote} Should we specify leading 0s are preferred?

month
:   Each calendar has a set of strings that may be used.
    
    `GREGORIAN` or `JULIAN`
    :   One of the following three-character strings:
        `JAN`, `FEB`, `MAR`, `APR`, `M‌AY`, `JUN`, `JUL`, `AUG`, `SEP`, `OCT`, `NOV`, or `DEC`
    
    `FRENCH R`
    :   One of the following four-character strings:
        `VEND`, `BRUM`, `FRIM`, `NIVO`, `PLUV`, `VENT`, `GERM`, `FLOR`, `PRAI`, `MESS`, `THER`, `FRUC`, `COMP`
    
    `HEBREW`
    :   One of the following three-character strings:
        `TSH`, `CSH`, `KSL`, `TVT`, `SHV`, `ADR`, `ADS`, `NSN`, `IYR`, `SVN`, `TMZ`, `AAV`, `ELL`

year
:   A decimal number.
    
    For `GREGORIAN` (only), the number may be optionally followed by either or both of the following year suffixes:
    
    Alternate Year
    :   Represented as a `/` and two additional decimal digits, with no spaces.
        Shows the possible date alternatives brought about when the beginning of the year changed from `MAR` to `JAN`: for example, `15 APR 1699/00`.
        
        The `/` MUST NOT have a space on either side.
    
    BCE
    :   Represented as `(B.C.)`, which SHOULD be preceded by a space.
        Indicates a date before the birth of Christ.
    
    If both suffixes are present, `(B.C.)` comes last.

### Exact Date {#exact-date}

An *exact date* is a `GREGORIAN` [Date](#date-format)s with the following additional constraints:

-   They MUST NOT include a *calendar escape*
-   They MUST include the day and month
-   They MUST NOT have either year suffix

### Date Period {#date-period}

A *date period* is one of the following three forms:

-   `FROM` [Date](#date-format)
-   `TO` [Date](#date-format)
-   `FROM` [Date](#date-format) `TO` [Date](#date-format)

### Date Value {#date-value}

A *date value* may have any of a variety of formats:

| Format               | Meaning                                                           |
|----------------------|-------------------------------------------------------------------|
| [Date](#date-format) | |
| [Date Period](#date-period) | |
| `BEF` [Date](#date-format) | before the given date |
| `AFT` [Date](#date-format) | after the given date |
| `BET` [Date](#date-format) `AND` [Date](#date-format) | between the given dates; the first date SHOULD be earlier than the second date |
| `ABT` [Date](#date-format) | about; the given date is not exact |
| `CAL` [Date](#date-format) | calculated mathematically, for example, from an event date and age |
| `EST` [Date](#date-format) | estimated based on some other event date |
| `INT` [Date](#date-format) `(`arbitrary text`)` | interpreted from knowledge about the associated date phrase included in parentheses |
| `(`arbitrary text`)` | information about when an event occurred that is not recognizable to a date parser |

{.ednote} Is the above table or the below list more understandable? We definitely don't need both...

-   [Date](#date-format)
-   [Date Period](#date-period)
-   `BEF` [Date](#date-format)
    
    Meaning: before the given date.
-   `AFT` [Date](#date-format)
    
    Meaning: after the given date.
-   `BET` [Date](#date-format) `AND` [Date](#date-format) 
    
    Meaning: between the given dates.

    The first date SHOULD be earlier than the second date.
-   `ABT` [Date](#date-format)
    
    Meaning: about; the given date is not exact.
-   `CAL` [Date](#date-format)
    
    Meaning: calculated mathematically, for example, from an event date and age.
-   `EST` [Date](#date-format)

    Meaning: estimated based on some other event date.
-   `INT` [Date](#date-format) `(`arbitrary text`)`

    Meaning: interpreted from knowledge about the associated date phrase included in parentheses.
-   `(`arbitrary text`)`
    
    The text gives information about when an event occurred but is not recognizable to a date parser.


## The `elf:Time` datatype {#time}

ELF uses the `elf:Time` *datatype* to represent *times* using the 24-hour
clock in *hours*, *minutes* and *seconds*, with these components
separated by a colon (U+003A).  The *hours* and *minutes* components are
*required*, and the *seconds* component *should* be provided.  A
fractional *seconds* component *may* be provided.  

{.example}  The value "`15:30:00`" is a valid *time*, represented using
the `elf:Time` *datatype*.  It represents half past three in the
afternoon.

The `elf:Time` *datatype* is typically used in conjunction with a value
of type `elf:DateExact` called its **associated date**.

{.example ...}  In [ELF Data Model], *times* are found as `TIME`
subelements of a `DATE` element which has a payload of *datatype*
`elf:DateExact`.

    2 DATE 10 DEC 2018
    3 TIME 13:52:00

In this example, "`10 DEC 2018`" is the *associated date* for the time
"`13:52:00`".
{/}

{.note}  As specified here, the *associated date* will always be
expressed in the Gregorian calendar.

*Strings* in the *lexical space* of the `elf:Time` *datatype* *shall*
match the following `Time` production, as well as the other constraints
given here on the numerical value of each component.  *Whitespace* is
not permitted anywhere in an `elf:Time` value.

    Time     ::=  HH ":" MM (":" SS)? TZD?  

    HH       ::= [0-9] [0-9]
    MM       ::= [0-9] [0-9]
    SS       ::= [0-9] [0-9] ("." [0-9]+)?
    TZD      ::= "Z" | ("+" | "-") HH ":" MM

The `HH` production encodes the *hours* component of the *time*,
zero-padded to two digits.  It *shall* be a decimal integer between `00`
and `24`, inclusive.  Values outside this range are outside the *lexical
space* of `elf:Time`.  The *hours* component *shall* only be `24` if the
*minutes* and *seconds* components are both zero or absent; any other
uses of `24` as an *hours* component is outside the *lexical space* of
the *datatype*.

{.example}  The *strings* "`30:00`" and "`24:30`" are both outside the
*lexical space* of this *datatype*.  The former is invalid because the
*hours* component of `30` is not between `00` to `24`; the latter is
invalid because it has an *hours* component of `24` and a non-zero
*minutes* component.

The *string* "`24:00:00`" is the **end-of-day instant** and denote the
final *instant* of a *calendar day*.  It is the same *instant* as the
first *instant* of the following *calendar day* (which is denoted
`00:00:00`).  *Conformant* applications *must* accept *end-of-day
instants* as valid input but *must not* create new instances of them.
A *conformant* application *may* convert an *end-of-day instant* to
`00:00:00`, but only if it has an *associated date* and that is
simultaneously incremented by one day.

{.example} A *time* of "`24:00:00`" with an *associated date* of "`30
NOV 2018`" *may* be converted to a *time* of "`00:00:00`" with an
*associated date* of "`1 DEC 2018`".

{.note} [GEDCOM 5.5.1] does not specify whether or not the *end-of-day
instant* is legal, and existing applications are unlikely to produce it.
It is supported by `elf:Time` for compatibility with [ISO 8601] and the
`xsd:time` *datatype* defined in [XSD Pt2].

The `MM` production encodes the *minutes* component of the *time*,
zero-padded to two digits.  It *shall* be a decimal integer between `00`
and `59`, inclusive.  Values outside this range are outside the *lexical
space* of `elf:Time`. 

The `SS` production encodes the *seconds* component of the *time*,
zero-padded to two digits and followed by an *optional* fractional
component.  It *shall* be a decimal greater than or equal to `00` and
strictly less than `61`.  Values outside this range are outside the
*lexical space* of `elf:Time`.

Applications *must* preserve at least the first three decimal digits of
a fractional *seconds* component, but *may* truncate or round the
fractional part of the *seconds* component beyond that.  Applications
*may* add or remove trailing zeros on the frational part of the
*seconds* component, and *should* add a *seconds* component of `:00` if
none was given.

{.note}  These provisions allows applications to process *times* using
the standard data structures and facilities provided in many program
languages, without preserving the original lexical form of the *time*.

{.note}  A future version of this standard is likely to make the
*seconds* component *required* to make this *datatype* fully compatible
with the `xsd:time` *datatype* defined in [XSD Pt2].  

A *seconds* component greater than or equal to `60`, and strictly less
than `61` is a **leap second** component.  Any use of a *leap second*
component is part of the *lexical space* of `elf:Time`, but *leap
second* components *shall* only be used to represent a leap seconds
inserted by the International Earth Rotation Service or its successor.

*Conformant* applications encountering a *leap seconds* component *may*
convert it to an ordinary *seconds* component by subtracting one from
its value.  This *should not* be done if the application supports
leap seconds and knows the specified *time* was a leap second.

{.example}  The *string* "`12:56:60.800`" is in the *lexical space* of
this *datatype* and has a *leap second* component of `60.800`.  As leap
seconds are always been inserted at midnight UTC and there is no
timezone in which this *time* is midnight UTC, this *time* could not
arise in practice and therefore *conformant* applications *must not*
generate such a *time*.  *Conformant* applications *must* accept such
*times* but *may* subtract one second to convert it to "`12:56:59.800`".

{.note}  [GEDCOM 5.5.1] makes no mention of leap seconds, but existing
applications are likely to generate such *times* if they happen to save
a file during the inserted leap second.  Leap seconds are also supported
in [ISO 8601], but not in the `xsd:time` *datatype* defined in [XSD Pt2].
These rules allow compatibility with these standards and with possible
existing use, while also allowing applications to ignore the leap
second.

The *lexical space* of the `elf:Time` *datatype* allows the inclusion of
a **time zone designator** matching the `TZD` production.  *Conformant*
applications *must* accept *time zone designators* on *dates* in input,
but *should* ignore them and *may* remove them.  *Conformant*
applications *must not* include *time zone designators* on newly
generated *times*.

{.note}  Syntactic support for *time zone designators* is an extention to
[GEDCOM 5.5.1], and is included in ELF for forwards compatibility. This
standard does not specify the meaning conveyed by a *time zone
designator*, but the syntax used is compatible with [ISO 8601] and the
`xsd:time` *datatype* defined in [XSD Pt2], and a future version of this
standard is likely to define by reference to the latter standard.

Formally, the `elf:Time` *datatype* is a *structured non-language-tagged
datatype* which has the following *properties*:

: Datatype definition

------           -----------------------------------------------
Name             `https://terms.fhiso.org/elf/Time`
Type             `http://www.w3.org/2000/01/rdf-schema#Datatype`
Pattern          `(([01][0-9]|2[0-3]):[0-5][0-9](:([0-5][0-9]|60)(\.[0-9]+)?)?`
                 `|24:00:00(\.0+)?)(Z|(\+|-)([01][0-9]|2[0-3]):[0-5][0-9])?`
Supertype        *No non-trivial supertypes*
Abstract         `false`
------           -----------------------------------------------

{.note} The *pattern* in the table above has been split on to two
lines for convenience of presentation; it is, however, really one
*pattern* and contains no *whitespace* or line breaks.
really one single line.  Any functional difference between the `Time`
production and the *pattern* specified above is unintentional.

## Calendars                                                      {#calendars}

### The Gregorian calendar                                        {#gregorian}

Dual years are not allowed.  

{.note} Deviation from [GEDCOM 5.5.1].

*Epoch names*:  BC, B.C., AD, A.D.

### The Julian calendar                                              {#julian}

Dual years are only allowed when they differ by exactly plus or minus
one to allow for different year starts.

{.note} Deviation from [GEDCOM 5.5.1].

### The Hebrew calendar                                              {#hebrew}

### The French Republican calendar                                   {#french}

{.ednote}  Should it only be defined for the years 1 to 14, and
exceptionally the year 79?  Leap years were 3, 7 and 11 at first, but
contradictory rules make it unclear how this would have continued.

## References

### Normative references

[Basic Concepts]
:   FHISO (Family History Information Standards Organisation).
    *Basic Concepts for Genealogical Standards*.  First public draft.
    (See <https://fhiso.org/TR/basic-concepts>.)

[RFC 2119]
:   IETF (Internet Engineering Task Force).
    *RFC 2119:
    Key words for use in RFCs to Indicate Requirement Levels.*
    Scott Bradner, 1997.
    (See <http://tools.ietf.org/html/rfc2119>.)

[XML]
:   W3C (World Wide Web Consortium).
    *Extensible Markup Language (XML) 1.1*, 2nd edition.
    Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, 
    and John Cowan eds., 2006.  W3C Recommendation.
    (See <https://www.w3.org/TR/xml11/>.)

### Other references

[ELF Data Model]
:   FHISO (Family History Information Standards Organisation).
    *Extended Legacy Format (ELF): Data Model*.  Exploratory draft.
    (See <https://fhiso.org/TR/elf-data-model>.)

[ELF Serialisation]
:   FHISO (Family History Information Standards Organisation).
    *Extended Legacy Format (ELF): Serialisation Format*.  Exploratory draft.
    (See <https://fhiso.org/TR/elf-serialisation>.)

[GEDCOM 5.5]
:   The Church of Jesus Christ of Latter-day Saints.
    *The GEDCOM Standard*, release 5.5.  2 Jan 1996, as amended by the
    errata sheet dated 10 Jan 1996.

[GEDCOM 5.5.1]
:   The Church of Jesus Christ of Latter-day Saints.
    *The GEDCOM Standard*, draft release 5.5.1.  2 Oct 1999.

[GEDCOM X Dates]
:    Intellectual Reserve Inc.  *The GEDCOM X Date Format*.
     Stable draft, accessed December 2018.  See <http://gedcomx.org/>.

[ISO 8601]
:   ISO (International Organization for Standardization).  *ISO
    8601:2004.  Data elements and interchange formats — Information
    interchange — Representation of dates and times*.  2004.

[ISO 8601-2]
:   ISO (International Organization for Standardization).  *ISO
    8601-2:2009.  Data elements and interchange formats — Information
    interchange — Part 2: Extensions*.  Draft, 15 Feb 2016.

[XSD Pt2]
:   W3C (World Wide Web Consortium). *W3C XML Schema Definition Language 
    (XSD) 1.1 Part 2: Datatypes*.  David Peterson, Shudi Gao (高殊镝),
    Ashok Malhotra, C. M. Sperberg-McQueen and Henry S. Thompson, ed., 2012.
    W3C Recommendation.  (See <https://www.w3.org/TR/xmlschema11-2/>.)

